

# 常见笔记

## 新项目构建

### 一、maven配置

```xml
<?xml version="1.0" encoding="UTF-8" ?>
 
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
 
<!--
 | This is the configuration file for Maven. It can be specified at two levels:
 |
 |  1. User Level. This settings.xml file provides configuration for a single user,
 |                 and is normally provided in ${user.home}/.m2/settings.xml.
 |
 |                 NOTE: This location can be overridden with the CLI option:
 |
 |                 -s /path/to/user/settings.xml
 |
 |  2. Global Level. This settings.xml file provides configuration for all Maven
 |                 users on a machine (assuming they're all using the same Maven
 |                 installation). It's normally provided in
 |                 ${maven.home}/conf/settings.xml.
 |
 |                 NOTE: This location can be overridden with the CLI option:
 |
 |                 -gs /path/to/global/settings.xml
 |
 | The sections in this sample file are intended to give you a running start at
 | getting the most out of your Maven installation. Where appropriate, the default
 | values (values used when the setting is not specified) are provided.
 |
 |-->
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">
    <!-- localRepository
     | The path to the local repository maven will use to store artifacts.
     |
     | Default: ${user.home}/.m2/repository
    <localRepository>/path/to/local/repo</localRepository>
    -->
    <!--自定义本地仓库路径-->
    <localRepository>E:\JAVA\Maven</localRepository>
    <!-- interactiveMode
     | This will determine whether maven prompts you when it needs input. If set to false,
     | maven will use a sensible default value, perhaps based on some other setting, for
     | the parameter in question.
     |
     | Default: true
    <interactiveMode>true</interactiveMode>
    -->
 
    <!-- offline
     | Determines whether maven should attempt to connect to the network when executing a build.
     | This will have an effect on artifact downloads, artifact deployment, and others.
     |
     | Default: false
    <offline>false</offline>
    -->
 
    <!-- pluginGroups
     | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.
     | when invoking a command line like "mvn prefix:goal". Maven will automatically add the group identifiers
     | "org.apache.maven.plugins" and "org.codehaus.mojo" if these are not already contained in the list.
     |-->
    <pluginGroups>
        <!-- pluginGroup
         | Specifies a further group identifier to use for plugin lookup.
        <pluginGroup>com.your.plugins</pluginGroup>
        -->
    </pluginGroups>
 
    <!-- proxies
     | This is a list of proxies which can be used on this machine to connect to the network.
     | Unless otherwise specified (by system property or command-line switch), the first proxy
     | specification in this list marked as active will be used.
     |-->
    <proxies>
        <!-- proxy
         | Specification for one proxy, to be used in connecting to the network.
         |
        <proxy>
          <id>optional</id>
          <active>true</active>
          <protocol>http</protocol>
          <username>proxyuser</username>
          <password>proxypass</password>
          <host>proxy.host.net</host>
          <port>80</port>
          <nonProxyHosts>local.net|some.host.com</nonProxyHosts>
        </proxy>
        -->
    </proxies>
 
    <!-- servers
     | This is a list of authentication profiles, keyed by the server-id used within the system.
     | Authentication profiles can be used whenever maven must make a connection to a remote server.
     |-->
    <servers>
        <!-- server
         | Specifies the authentication information to use when connecting to a particular server, identified by
         | a unique name within the system (referred to by the 'id' attribute below).
         |
         | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are
         |       used together.
         |
        <server>
          <id>deploymentRepo</id>
          <username>repouser</username>
          <password>repopwd</password>
        </server>
        -->
 
        <!-- Another sample, using keys to authenticate.
        <server>
          <id>siteServer</id>
          <privateKey>/path/to/private/key</privateKey>
          <passphrase>optional; leave empty if not used.</passphrase>
        </server>
        -->
    </servers>
 
    <!-- mirrors
     | This is a list of mirrors to be used in downloading artifacts from remote repositories.
     |
     | It works like this: a POM may declare a repository to use in resolving certain artifacts.
     | However, this repository may have problems with heavy traffic at times, so people have mirrored
     | it to several places.
     |
     | That repository definition will have a unique id, so we can create a mirror reference for that
     | repository, to be used as an alternate download site. The mirror site will be the preferred
     | server for that repository.
     |-->
    <mirrors>
        <!-- mirror
         | Specifies a repository mirror site to use instead of a given repository. The repository that
         | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used
         | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.
         |
        <mirror>
          <id>mirrorId</id>
          <mirrorOf>repositoryId</mirrorOf>
          <name>Human Readable Name for this Mirror.</name>
          <url>http://my.repository.com/repo/path</url>
        </mirror>
         -->
 
        <mirror>
            <id>alimaven-central</id>
            <mirrorOf>central</mirrorOf>
            <name>aliyun maven</name>
            <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>
        </mirror>
        <mirror>
            <id>jboss-public-repository-group</id>
            <mirrorOf>central</mirrorOf>
            <name>JBoss Public Repository Group</name>
            <url>http://repository.jboss.org/nexus/content/groups/public</url>
        </mirror>
 
        <!--<mirror>
            <id>alimaven</id>
            <name>aliyun maven</name>
            <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
            <mirrorOf>central</mirrorOf>
        </mirror>
        <mirror>
            <id>ibiblio</id>
            <mirrorOf>central</mirrorOf>
            <name>Human Readable Name for this Mirror.</name>
            <url>http://mirrors.ibiblio.org/pub/mirrors/maven2/</url>
        </mirror>
        <mirror>
            <id>central</id>
            <name>Maven Repository Switchboard</name>
            <url>http://repo1.maven.org/maven2/</url>
            <mirrorOf>central</mirrorOf>
        </mirror>
        <mirror>
            <id>repo2</id>
            <mirrorOf>central</mirrorOf>
            <name>Human Readable Name for this Mirror.</name>
            <url>http://repo2.maven.org/maven2/</url>
        </mirror>-->
 
    </mirrors>
 
    <!-- profiles
     | This is a list of profiles which can be activated in a variety of ways, and which can modify
     | the build process. Profiles provided in the settings.xml are intended to provide local machine-
     | specific paths and repository locations which allow the build to work in the local environment.
     |
     | For example, if you have an integration testing plugin - like cactus - that needs to know where
     | your Tomcat instance is installed, you can provide a variable here such that the variable is
     | dereferenced during the build process to configure the cactus plugin.
     |
     | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles
     | section of this document (settings.xml) - will be discussed later. Another way essentially
     | relies on the detection of a system property, either matching a particular value for the property,
     | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a
     | value of '1.4' might activate a profile when the build is executed on a JDK version of '1.4.2_07'.
     | Finally, the list of active profiles can be specified directly from the command line.
     |
     | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact
     |       repositories, plugin repositories, and free-form properties to be used as configuration
     |       variables for plugins in the POM.
     |
     |-->
    <profiles>
        <!-- profile
         | Specifies a set of introductions to the build process, to be activated using one or more of the
         | mechanisms described above. For inheritance purposes, and to activate profiles via <activatedProfiles/>
         | or the command line, profiles have to have an ID that is unique.
         |
         | An encouraged best practice for profile identification is to use a consistent naming convention
         | for profiles, such as 'env-dev', 'env-test', 'env-production', 'user-jdcasey', 'user-brett', etc.
         | This will make it more intuitive to understand what the set of introduced profiles is attempting
         | to accomplish, particularly when you only have a list of profile id's for debug.
         |
         | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.
        <profile>
          <id>jdk-1.4</id>
          <activation>
            <jdk>1.4</jdk>
          </activation>
          <repositories>
            <repository>
              <id>jdk14</id>
              <name>Repository for JDK 1.4 builds</name>
              <url>http://www.myhost.com/maven/jdk14</url>
              <layout>default</layout>
              <snapshotPolicy>always</snapshotPolicy>
            </repository>
          </repositories>
        </profile>
        -->
        <profile>
            <id>jdk18</id>
            <activation>
                <jdk>1.8</jdk>
                <activeByDefault>true</activeByDefault>
            </activation>
            <properties>
                <maven.compiler.source>1.8</maven.compiler.source>
                <maven.compiler.target>1.8</maven.compiler.target>
                <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
            </properties>
        </profile>
 
        <!--
         | Here is another profile, activated by the system property 'target-env' with a value of 'dev',
         | which provides a specific path to the Tomcat instance. To use this, your plugin configuration
         | might hypothetically look like:
         |
         | ...
         | <plugin>
         |   <groupId>org.myco.myplugins</groupId>
         |   <artifactId>myplugin</artifactId>
         |
         |   <configuration>
         |     <tomcatLocation>${tomcatPath}</tomcatLocation>
         |   </configuration>
         | </plugin>
         | ...
         |
         | NOTE: If you just wanted to inject this configuration whenever someone set 'target-env' to
         |       anything, you could just leave off the <value/> inside the activation-property.
         |
        <profile>
          <id>env-dev</id>
          <activation>
            <property>
              <name>target-env</name>
              <value>dev</value>
            </property>
          </activation>
          <properties>
            <tomcatPath>/path/to/tomcat/instance</tomcatPath>
          </properties>
        </profile>
        -->
    </profiles>
 
    <!-- activeProfiles
     | List of profiles that are active for all builds.
     |
    <activeProfiles>
      <activeProfile>alwaysActiveProfile</activeProfile>
      <activeProfile>anotherAlwaysActiveProfile</activeProfile>
    </activeProfiles>
    -->
</settings>
```



### 二、springboot配置

#### 1、pom

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.6.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.top20.learn</groupId>
    <artifactId>learning-project</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>learning-project</name>
    <description>Demo project for Spring Boot</description>
    <properties>
        <java.version>1.8</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <!--Spring boot Web容器-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!--Spring boot Redis-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>

        <!-- fastjson -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.70</version>
        </dependency>

        <!--Spring boot 核心-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <!--lombok依赖-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <!--hutool工具包-->
        <dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-all</artifactId>
            <version>5.1.1</version>
        </dependency>
        <!-- 工具包 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.9</version>
        </dependency>
        <!--单元测试-->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <scope>test</scope>
            <version>4.12</version>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.16</version>
        </dependency>

        <!--druid数据源驱动-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
            <version>1.1.24</version>
        </dependency>

        <!-- Swagger UI 相关 -->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.9.2</version>
            <exclusions>
                <exclusion>
                    <groupId>io.swagger</groupId>
                    <artifactId>swagger-annotations</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>io.swagger</groupId>
                    <artifactId>swagger-models</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.9.2</version>
        </dependency>
        <dependency>
            <groupId>io.swagger</groupId>
            <artifactId>swagger-annotations</artifactId>
            <version>1.5.21</version>
        </dependency>
        <dependency>
            <groupId>io.swagger</groupId>
            <artifactId>swagger-models</artifactId>
            <version>1.5.21</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>

```



## 泛型

参考文档：

https://www.cnblogs.com/jian0110/p/10690483.html

### 一、不要使用原生态类型

#### 1. 什么是原生态类型？

**原生态类型（Raw type），即不带任何实际类型参数的泛型名称。如与List<E>对应的原生态类型List。不推荐List list = new ArrayList()这样的方式，主要就会丢掉安全性**（为什么不安全呢？具体请往下看），应使用List<MyClass> list = new ArrayList()明确类型。或者使用List<Object>（那么List与List<Object>有啥区别呢？具体可以看泛型的子类型规则部分）

#### 2. 为什么不推荐使用原生态类型？

当我们使用原生态类型List创建一个集合，并往其中放入Stamp类与Coin类，并迭代循环获取List集合中的元素。

![image-20201028185858351](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201028185858.png)



![image-20201028185938908](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201028185939.png)

由此可见，原生类型是不推荐使用，**是不安全**的！

**问1：那为什么Java还要允许使用原生态类型呢？**

> ***\*是为了提升兼容性，Java1.5之前已经存在很多的原生态类型的代码，那么为了让代码保持合法，并且能够兼容新代码，因此Java才对原生态类型支持！\****

**问2：那我们使用List<Object>是不是就可以了呢，两个有啥区别呢？**

> **两者都可以插入任意类型的对象。不严格来说，前者原生态类型List逃避了泛型检查，后者参数化类型List<Object>明确告诉编译器能够持有任意类型的对象。但是两个的区别主要是泛型存在子类型规则，具体请往下看**

#### 3. 泛型的子类型规则

**子类型规则，即任何参数化的类型是原生态类型的一个子类型，比如List<String>是原生态类型List的一个子类型，而不是参数化List<Object>的子类型。**

由于子类型规则的存在，我们可以将List<String>传递给List类型的参数

![image-20201028190322583](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201028190322.png)

#### 4. 无限制的通配符类型

　使用原生态类型是很危险的，但是如果不确定或不关心实际的类型参数，**那么在Java 1.5之后Java有一种安全的替换方法，称之为无限制的通配符类型（unbounded wildcard type），可以用一个“?”代替，比如Set<?>表示某个类型的集合，可以持有任何集合。**

那么无限制通配类型与原生态类型有啥区别呢？**原生态类型**是可以**插入任何类型**的元素，但是**无限制通配**类型的话，**不能添加**任何元素（null除外）。

![img](https://img2018.cnblogs.com/blog/1352849/201904/1352849-20190411173552784-418864754.png)



　**问：那么这样的通配符类型有意义吗？因为你并不知道它到底能加入啥样的元素，但是又美其名曰“无限制”。**

> **不能说没有意义，因为它的出现归根结底是为了防止破坏集合类型约束条件，并且可以根据需要使用泛型方法或者有限制的通配符类型（bound wildcard type）接口某些限制，提高安全性。**

### 二、有限制的通配符类型

之前提到过的无限制的通配符类型就提到过，无限制的通配符单纯只使用"?"（如Set<?>），而**有限制的通配**符往往有如下形式，通过有限制的通配符类型可以大大提升API的灵活性。

#### （1）E的某种超类集合(接口)

​	Collection<? super E>、Interface<? super E>、

#### （2）E的某个子类集合(接口)

​	Collection<? extends E>、Interface<? extends E>

![image-20201028191641859](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201028191642.png)

##### **举例说明：生产者**

1）你不能在List<? extends Number>中add操作，**因为你增加Integer可能会指向List<Double>，你增加Double可能会指向Integer。根本不能确保列表中最终保存的是什么类型。换句话说Number的所有子类从类关系上来说都是平级的，毫无联系的。并不能依赖类型推导（类型转换），编译器是无法确实的实际类型的！**

![img](https://img2018.cnblogs.com/blog/1352849/201904/1352849-20190412115746800-1844584962.png)

2）**但是你可以读取其中的元素，并保证读取出来的一定是Number的子类（包括Number），编译并不会报错，换句话说编译器知道里面的元素都是Number的子类，不管是Integer还是Double，编译器都可以向下转型**

![img](https://img2018.cnblogs.com/blog/1352849/201904/1352849-20190412115615326-182146503.png)

##### **举例说明：消费者**

 1）编译器不知道存入列表中的Number的超类具体是哪一个，**只能使用Object去接收**

![img](https://img2018.cnblogs.com/blog/1352849/201904/1352849-20190412135134653-1190854738.png)

2）但是**只可以添加Interger及其子类（因为Integer子类也是Integer，向上转型）**，不能添加Object、Number。因为插入Number对象可以指向List<Integer>对象，你插入Object，因为可能会指向List<Ineger>对象

![img](https://img2018.cnblogs.com/blog/1352849/201904/1352849-20190412135931083-1109475758.png)

```
注意：Comparable/Comparator都是消费者，通常使用Comparator<? Super T>），可以将上述的max方法进行改造：
```









### 附1：相关泛型术语

　　**1）参数化的类型：List<String>**

　　**2）实际类型参数：String**

　　**3）泛型：List<E>**

　　**4）形式类型参数：E**

　　**5）无限制通配符类型：List<?>**

　　**6）原生态类型：List**

　　**7）递归类型限制：<T extends Comparable<T>>**

　　**8）有限制的通配符类型：List<? extends Number>**

　　**9）泛型方法：static <E> List<E> union()**

　　**10）类型令牌：String.class**

### 附2：常用的形式类型参数

　　**1）T 代表一般的任何类。**

　　**2）E 代表 Element 的意思，或者 Exception 异常的意思。**

　　**3）K 代表 Key 的意思。**

　　**4）V 代表 Value 的意思，通常与 K 一起配合使用。**

　　**5）S 代表 Subtype 的意思**

### 三、泛型上下边界

在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入**某种类型的父类或某种类型的子类**。

为泛型**添加上边界**，即传入的类型实参必须是**指定类型的子类型**

![image-20201028185603404](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201028185603.png)

#### 3.1 上界

![image-20210325163752475](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210325163753.png)

![image-20210325163812944](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210325163813.png)



#### 3.2 下界

![image-20210325163852892](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210325163853.png)

#### 3.3 **上下界通配符的副作用**

> 边界让Java不同泛型之间的转换更容易了。但不要忘记，这样的转换也有一定的副作用。那就是容器的部分功能可能失效。
>
> 还是以刚才的Plate为例。我们可以对盘子做两件事，往盘子里set( )新东西，以及从盘子里get( )东西。

![image-20210325164216553](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210325164216.png)

##### **3.3.1  上界<? extends T>不能往里存，只能往外取**

![image-20210325164153520](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210325164153.png)



##### 3.3.2 **下界<? super T>不影响往里存，但往外取只能放在Object对象里**

![image-20210325164329008](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210325164329.png)

#### 3.4 **PECS原则**

最后看一下什么是**PECS（Producer Extends Consumer Super）原则**，已经很好理解了。

1、**频繁往外读取内容的，适合用上界Extends**。

2、**经常往里插入的，适合用下界Super**。

## JAVAWEB

#### 一、request获取上下文路径、URL、URI、Servlet路径等方法

```java
String getContextPath()：返回上下文路径，例如：/hello
String getQueryString()：返回请求URL中的参数，例如：name=zhangSan
String getRequestURI()：返回请求URI路径，例如：/hello/oneServlet
StringBuffer getRequestURL()：返回请求URL路径，例如：http://localhost/hello/oneServlet，即返回除了参数以外的路径信息；
String getServletPath()：返回Servlet路径，例如：/oneServlet
String getRemoteAddr()：返回当前客户端的IP地址；
String getRemoteHost()：返回当前客户端的主机名，但这个方法的实现还是获取IP地址；
String getScheme()：返回请求协议，例如：http；
String getServerName()：返回主机名，例如：localhost
int getServerPort()：返回服务器端口号，例如：8080
```

![这里写图片描述](https://img-blog.csdn.net/20180125111649869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVsaTUyMGxqZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

在做微信开发的时候，需要用到签名信息，签名信息是需要用到当前访问地址的。所以，如何获取当前页面的url呢？

```java
@RestController
@RequestMapping(value="/test")
public class TestControllor {

    Logger logger = Logger.getLogger(TestControllor.class);
    
    @Autowired
    private HttpServletRequest request;
    
    @GetMapping("/blog")
    public String operation(){
        
        String url = "";
        url = request.getScheme() +"://" + request.getServerName()  
                        + ":" +request.getServerPort() 
                        + request.getServletPath();
        if (request.getQueryString() != null){
            url += "?" + request.getQueryString();
        }
        
        System.out.println(url);
        
        return "";
    }
}
```

输入test.nssiot.cn/test/blog?id=test

控制台中可以看到：
[http://test.nssiot.cn/test/blog?id=test](https://link.jianshu.com/?t=http://test.nssiot.cn/test/blog?id=test)

## Map

### 一、Map遍历

方法1

```java
/**
* 最常见也是大多数情况下用的最多的，一般在键值对都需要使用
 */
Map <String,String>map = new HashMap<String,String>();
map.put("熊大", "棕色");
map.put("熊二", "黄色");
for(Map.Entry<String, String> entry : map.entrySet()){
    String mapKey = entry.getKey();
    String mapValue = entry.getValue();
    System.out.println(mapKey+":"+mapValue);
}
```

方法2

```java
/**
* 最常见也是大多数情况下用的最多的，一般在键值对都需要使用
 */
Map <String,String>map = new HashMap<String,String>();
map.put("熊大", "棕色");
map.put("熊二", "黄色");
for(Map.Entry<String, String> entry : map.entrySet()){
    String mapKey = entry.getKey();
    String mapValue = entry.getValue();
    System.out.println(mapKey+":"+mapValue);
}
```

方法3

```java
Iterator<Entry<String, String>> entries = map.entrySet().iterator();
while(entries.hasNext()){
    Entry<String, String> entry = entries.next();
    String key = entry.getKey();
    String value = entry.getValue();
    System.out.println(key+":"+value);
}
```

方法四

```java
for(String key : map.keySet()){
    String value = map.get(key);
    System.out.println(key+":"+value);
}
```

### 二、JAVA8新增的方法

> 得益于 Java 8 的 default 方法特性，Java 8 对 Map 增加了不少实用的默认方法，像 getOrDefault, forEach, replace, replaceAll, putIfAbsent, remove(key, value), computeIfPresent, computeIfAbsent, compute 和merge 方法。另外与 Map 相关的 Map.Entry 也新加了多个版本的 comparingByKey 和 comparingByValue 方法。
>
> 为达到熟练运用上述除 getOrDefault 和 forEach 外的其他方法，有必要逐一体验一番，如何调用，返回值以及调用后的效果如何。看看每个方法不至于 Java 8 那么多年还总是  if(map.containsKey(key))... 那样的老套操作。
>
> 前注：Map 新增方法对  present 的判断是 map.containsKey(key) && map.get(key) != null，简单就是  map.get(key) != null，也就是即使 key 存在，但对应的值为 null 的话也视为 absent。absent 就是 map.get(key) == null。
>
> 不同 Map 实现对 key/value 是否能为 null 有不同的约束, HashMap, LinkedHashMap, key 和 value 都可以为 null 值，TreeMap 的 key 为不能为 null, 但 value 可以为 null, 而 Hashtable, ConcurrentMap 则 key 和 value 都不同为 null。一句话 absent/present 的判断是 map.get(key) 是否为 null。
>
> 方法介绍的顺序是它们相对于本人的生疏程度而定的。每个方法介绍主要分两部分，参考实现代码与示例代码执行效果。参考实现代码摘自 JDK 官方的 Map JavaDoc。

#### 2.1 putIfAbsent 方法

![image-20210330104630692](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210330104631.png)

#### 2.2 computeIfPresent 方法

![image-20210330105222316](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210330105222.png)

#### 2.3  computeIfAbsent 方法

 ![image-20210330112515840](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210330112516.png)

#### 2.4 replace(K key, V value) 方法

![image-20210330113748695](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210330113748.png)

#### 2.5 replaceAll 方法

![image-20210330114332379](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210330114332379.png)

#### 2.6  remove(key, value)

![image-20210330114409760](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210330114409.png)

#### 2.7  compute 方法

![image-20210330114547763](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210330114547.png)

#### 2.8  merge 方法

![image-20210330115434657](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210330115434.png)

#### 2.9 Map.Entry comparingByKey 和 comparingByValue 方法

![image-20210330115535629](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210330115535.png)

### 三、TreeMap

![image-20210412142536574](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210412142540.png)



##### API

```java
Map.Entry<K,V> 	ceilingEntry(K key)
        返回与大于或等于给定键的最小键相关联的键值映射，如果没有此键，则 null 。
K 	ceilingKey(K key)
        返回大于或等于给定键的 null键，如果没有此键，则返回 null 。
void 	clear()
        从这张地图中删除所有的映射。
Object 	clone()
        返回此 TreeMap实例的浅拷贝。
Comparator<? super K> 	comparator()
        返回用于订购此地图中的键的比较器，或null如果此地图使用其键的natural ordering 。
boolean 	containsKey(Object key)
        如果此映射包含指定键的映射，则返回 true 。
boolean 	containsValue(Object value)
        如果此地图将一个或多个键映射到指定值，则返回 true 。
NavigableSet<K> 	descendingKeySet()
        返回此地图中包含的键的相反顺序NavigableSet 。
NavigableMap<K,V> 	descendingMap()
        返回此映射中包含的映射的反向排序视图。
Set<Map.Entry<K,V>> 	entrySet()
        返回此地图中包含的映射的Set视图。
Map.Entry<K,V> 	firstEntry()
        返回与该地图中的最小键相关联的键值映射，如果地图为空，则返回 null 。
K 	firstKey()
        返回此地图中当前的第一个（最低）键。
Map.Entry<K,V> 	floorEntry(K key)
        返回与小于或等于给定键的最大键相关联的键值映射，如果没有此键，则 null 。
K 	floorKey(K key)
        返回小于或等于给定键的最大键，如果没有这样的键，则返回 null 。
void 	forEach(BiConsumer<? super K,? super V> action)
        对此映射中的每个条目执行给定的操作，直到所有条目都被处理或操作引发异常。
V 	get(Object key)
        返回到指定键所映射的值，或 null如果此映射包含该键的映射。
SortedMap<K,V> 	headMap(K toKey)
        返回此地图部分的视图，其密钥严格小于 toKey 。
NavigableMap<K,V> 	headMap(K toKey, boolean inclusive)
        返回此地图部分的视图，其键值小于（或等于，如果 inclusive为真） toKey 。
Map.Entry<K,V> 	higherEntry(K key)
        返回与最小密钥相关联的密钥值映射严格大于给定密钥，如果没有这样的密钥则 null 。
K 	higherKey(K key)
        返回严格大于给定键的最小键，如果没有这样的键，则返回 null 。
Set<K> 	keySet()
        返回此地图中包含的键的Set视图。
Map.Entry<K,V> 	lastEntry()
        返回与该地图中最大关键字关联的键值映射，如果地图为空，则返回 null 。
K 	lastKey()
        返回当前在此地图中的最后（最高）键。
Map.Entry<K,V> 	lowerEntry(K key)
        返回与最大密钥相关联的密钥值映射严格小于给定密钥，如果没有这样的密钥，则 null 。
K 	lowerKey(K key)
        返回严格小于给定键的最大键，如果没有这样的键，则返回 null 。
NavigableSet<K> 	navigableKeySet()
        返回此地图中包含的键的NavigableSet视图。
Map.Entry<K,V> 	pollFirstEntry()
        删除并返回与该地图中的最小键相关联的键值映射，如果地图为空，则返回 null 。
Map.Entry<K,V> 	pollLastEntry()
        删除并返回与该地图中最大密钥相关联的键值映射，如果地图为空，则返回 null 。
V 	put(K key, V value)
        将指定的值与此映射中的指定键相关联。
void 	putAll(Map<? extends K,? extends V> map)
        将指定地图的所有映射复制到此地图。
V 	remove(Object key)
        从此TreeMap中删除此键的映射（如果存在）。
V 	replace(K key, V value)
        只有当目标映射到某个值时，才能替换指定键的条目。
boolean 	replace(K key, V oldValue, V newValue)
        仅当当前映射到指定的值时，才能替换指定键的条目。
void 	replaceAll(BiFunction<? super K,? super V,? extends V> function)
        将每个条目的值替换为对该条目调用给定函数的结果，直到所有条目都被处理或该函数抛出异常。
int 	size()
        返回此地图中键值映射的数量。
NavigableMap<K,V> 	subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
        返回此地图部分的视图，其关键范围为 fromKey至 toKey 。
SortedMap<K,V> 	subMap(K fromKey, K toKey)
        返回此地图部分的视图，其关键字范围从 fromKey （含）到 toKey ，独占。
SortedMap<K,V> 	tailMap(K fromKey)
        返回此地图部分的视图，其键大于等于 fromKey 。
NavigableMap<K,V> 	tailMap(K fromKey, boolean inclusive)
        返回此地图部分的视图，其键大于（或等于，如果 inclusive为真） fromKey 。
Collection<V> 	values()
        返回此地图中包含的值的Collection视图。

```









## JSON转换

#### json转map

```java
public class JsonToMapTest01 {  
  
    public static void main(String[] args){  
  
        String str = "{\"0\":\"zhangsan\",\"1\":\"lisi\",\"2\":\"wangwu\",\"3\":\"maliu\"}";  
        //第一种方式  
        Map maps = (Map)JSON.parse(str);  
        System.out.println("这个是用JSON类来解析JSON字符串!!!");  
        for (Object map : maps.entrySet()){  
            System.out.println(((Map.Entry)map).getKey()+"     " + ((Map.Entry)map).getValue());  
        }  
        //第二种方式  
        Map mapTypes = JSON.parseObject(str);  
        System.out.println("这个是用JSON类的parseObject来解析JSON字符串!!!");  
        for (Object obj : mapTypes.keySet()){  
            System.out.println("key为："+obj+"值为："+mapTypes.get(obj));  
        }  
        //第三种方式  
        Map mapType = JSON.parseObject(str,Map.class);  
        System.out.println("这个是用JSON类,指定解析类型，来解析JSON字符串!!!");  
        for (Object obj : mapType.keySet()){  
            System.out.println("key为："+obj+"值为："+mapType.get(obj));  
        }  
        //第四种方式  
        /** 
         * JSONObject是Map接口的一个实现类 
         */  
        Map json = (Map) JSONObject.parse(str);  
        System.out.println("这个是用JSONObject类的parse方法来解析JSON字符串!!!");  
        for (Object map : json.entrySet()){  
            System.out.println(((Map.Entry)map).getKey()+"  "+((Map.Entry)map).getValue());  
        }  
        //第五种方式  
        /** 
         * JSONObject是Map接口的一个实现类 
         */  
        JSONObject jsonObject = JSONObject.parseObject(str);  
        System.out.println("这个是用JSONObject的parseObject方法来解析JSON字符串!!!");  
        for (Object map : json.entrySet()){  
            System.out.println(((Map.Entry)map).getKey()+"  "+((Map.Entry)map).getValue());  
        }  
        //第六种方式  
        /** 
         * JSONObject是Map接口的一个实现类 
         */  
        Map mapObj = JSONObject.parseObject(str,Map.class);  
        System.out.println("这个是用JSONObject的parseObject方法并执行返回类型来解析JSON字符串!!!");  
        for (Object map: json.entrySet()){  
            System.out.println(((Map.Entry)map).getKey()+"  "+((Map.Entry)map).getValue());  
        }  
        String strArr = "{{\"0\":\"zhangsan\",\"1\":\"lisi\",\"2\":\"wangwu\",\"3\":\"maliu\"}," +  
                "{\"00\":\"zhangsan\",\"11\":\"lisi\",\"22\":\"wangwu\",\"33\":\"maliu\"}}";  
       // JSONArray.parse()  
        System.out.println(json);  
    }  
}  
```

#### JSON嵌套转bean对象

https://www.jb51.cc/json/288879.html

```java
package com.lxk.json;
 
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
 
/**
 * JSON 转换
 */
public final class JsonUtils {
 
    /**
     * 把Java对象转换成json字符串
     *
     * @param object 待转化为JSON字符串的Java对象
     * @return json 串 or null
     */
    public static String parSEObjToJson(Object object) {
        String string = null;
        try {
            //string = JSON.toJSONString(object);
            string = JSONObject.toJSONString(object);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        return string;
    }
 
    /**
     * 将Json字符串信息转换成对应的Java对象
     *
     * @param json json字符串对象
     * @param c    对应的类型
     */
    public static <T> T parseJsonToObj(String json,Class<T> c) {
        try {
            //两个都是可行的，起码我测试的时候是没问题的。
            //JSONObject jsonObject = JSONObject.parSEObject(json);
            JSONObject jsonObject = JSON.parSEObject(json);
            return JSON.toJavaObject(jsonObject,c);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        return null;
    }
}
```





## String 工具之StrSubstitutor字符替换

它是[apache工具包下的一个类](https://commons.apache.org/proper/commons-lang/javadocs/api-3.4/org/apache/commons/lang3/text/StrSubstitutor.html)；然后来学习学习它的简单调用。

### **1、 简单的调用**

![image-20201102135513475](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201102135513.png)

### **2、 简单的调用-设置变量的默认值**

![image-20201102135818869](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201102135819.png)

### **3、 简单的调用-自定义匹配符**

![image-20201102160743010](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201102160743.png)

### **4、StrSubstitutor会递归地替换变量**

![image-20201102161616640](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201102161616.png)

## AviatorEvaluator表达式引擎

#### Aviator简介

> Aviator是一个高性能、轻量级的java语言实现的表达式求值引擎，主要用于各种表达式的动态求值。现在已经有很多开源可用的java表达式求值引擎，为什么还需要Avaitor呢？
>  Aviator的设计目标是轻量级和高性能，相比于Groovy、JRuby的笨重，Aviator非常小，加上依赖包也才450K,不算依赖包的话只有70K；当然，Aviator的语法是受限的，它不是一门完整的语言，而只是语言的一小部分集合。
>  其次，Aviator的实现思路与其他轻量级的求值器很不相同，其他求值器一般都是通过解释的方式运行，而Aviator则是直接将表达式编译成Java字节码，交给JVM去执行。简单来说，Aviator的定位是介于Groovy这样的重量级脚本语言和IKExpression这样的轻量级表达式引擎之间。

#### Aviator的特性

> 支持大部分运算操作符，包括算术操作符、关系运算符、逻辑操作符、正则匹配操作符(=~)、三元表达式?:，并且支持操作符的优先级和括号强制优先级，具体请看后面的操作符列表。
>
> 支持函数调用和自定义函数
>
> 支持正则表达式匹配，类似Ruby、Perl的匹配语法，并且支持类Ruby的$digit指向匹配分组。
>
> 自动类型转换，当执行操作的时候，会自动判断操作数类型并做相应转换，无法转换即抛异常。
>
> 支持传入变量，支持类似a.b.c的嵌套变量访问。
>
> 性能优秀

#### Aviator的限制

> - 没有if else、do while等语句，没有赋值语句，没有位运算符
> - 仅支持逻辑表达式、算术表达式、三元表达式和正则匹配

#### Aviator用法

##### 最新jar包

```xml
    <dependency>
        <groupId>com.googlecode.aviator</groupId>
        <artifactId>aviator</artifactId>
        <version>2.3.4</version>
    </dependency>
```

##### 算术表达式

![image-20201102164037982](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201102164038.png)

##### **三元表达式(if-else)**

![image-20201102203008306](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201102203008.png)

##### **编译表达式：提高性能**

![image-20201102203259205](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201102203259.png)







## SpEl表达式

### **Spel能干什么?**

表达式语言一般是用最简单的形式完成最主要的工作，减少我们的工作量。

SpEL支持如下表达式：

**一、基本表达式：** 字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算及Elivis表达式、正则表达式、括号优先级表达式；

**二、类相关表达式：** 类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；

**三、集合相关表达式：** 内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；

**四、其他表达式**：模板表达式。

**注：SpEL表达式中的关键字是不区分大小写的。**

### **SpEL基础**

**HelloWorld**

首先准备支持SpEL的Jar包：“org.springframework.expression-3.0.5.RELEASE.jar”将其添加到类路径中。

SpEL在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。

让我们看下代码片段吧：

```java
package com.javacode2018.spel;

import org.junit.Test;
import org.springframework.expression.EvaluationContext;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;

public class SpelTest {
    @Test
    public void test1() {
        ExpressionParser parser = new SpelExpressionParser();
        Expression expression = parser.parseExpression("('Hello' + ' World').concat(#end)");
        EvaluationContext context = new StandardEvaluationContext();
        context.setVariable("end", "!");
        System.out.println(expression.getValue(context));
    }
}
```

接下来让我们分析下代码：

1）创建解析器：**SpEL使用ExpressionParser接口表示解析器，提供SpelExpressionParser默认实现；**

2）解析表达式：使用ExpressionParser的parseExpression来解析相应的表达式为Expression对象。

3）构造上下文：准备比如变量定义等等表达式需要的上下文数据。

4）求值：通过Expression接口的getValue方法根据上下文获得表达式值。

是不是很简单，接下来让我们看下其具体实现及原理吧。

### **SpEL原理及接口**

![image-20210408151045101](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210408151045101.png)

#### **工作原理**

```java
1.首先定义表达式：“1+2”；
2.定义解析器ExpressionParser实现，SpEL提供默认实现SpelExpressionParser；
  2.1.SpelExpressionParser解析器内部使用Tokenizer类进行词法分析，即把字符串流分析为记号流，记号在SpEL使用Token类来表示；
  2.2.有了记号流后，解析器便可根据记号流生成内部抽象语法树；在SpEL中语法树节点由SpelNode接口实现代表：如OpPlus表示加操作节点、IntLiteral表示int型字面量节点；使用SpelNodel实现组成了抽象语法树；
  2.3.对外提供Expression接口来简化表示抽象语法树，从而隐藏内部实现细节，并提供getValue简单方法用于获取表达式值；SpEL提供默认实现为SpelExpression；
3.定义表达式上下文对象（可选），SpEL使用EvaluationContext接口表示上下文对象，用于设置根对象、自定义变量、自定义函数、类型转换器等，SpEL提供默认实现StandardEvaluationContext；
4.使用表达式对象根据上下文对象（可选）求值（调用表达式对象的getValue方法）获得结果。
```

#### **ExpressionParser接口**

表示解析器，默认实现是org.springframework.expression.spel.standard包中的SpelExpressionParser类，使用parseExpression方法将字符串表达式转换为Expression对象，对于ParserContext接口用于定义字符串表达式是不是模板，及模板开始与结束字符：

```java
public interface ExpressionParser {
 Expression parseExpression(String expressionString) throws ParseException;
 Expression parseExpression(String expressionString, ParserContext context) throws ParseException;
}
```

![image-20210408152004784](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210408152005.png)

#### **EvaluationContext接口**

> 表示上下文环境，默认实现是org.springframework.expression.spel.support包中的StandardEvaluationContext类，使用setRootObject方法来设置根对象，使用setVariable方法来注册自定义变量，使用registerFunction来注册自定义函数等等。

#### **Expression接口**

> 表示表达式对象，默认实现是org.springframework.expression.spel.standard包中的SpelExpression，提供getValue方法用于获取表达式值，提供setValue方法用于设置对象值。

### **SpEL语法**

https://zhuanlan.zhihu.com/p/174786047

#### **基本表达式**

##### **1、字面量表达式**

SpEL支持的字面量包括：字符串、数字类型（int、long、float、double）、布尔类型、null类型。

```java
@Test
public void test2() {
    ExpressionParser parser = new SpelExpressionParser();

    String str1 = parser.parseExpression("'Hello World!'").getValue(String.class);
    int int1 = parser.parseExpression("1").getValue(Integer.class);
    long long1 = parser.parseExpression("-1L").getValue(long.class);
    float float1 = parser.parseExpression("1.1").getValue(Float.class);
    double double1 = parser.parseExpression("1.1E+2").getValue(double.class);
    int hex1 = parser.parseExpression("0xa").getValue(Integer.class);
    long hex2 = parser.parseExpression("0xaL").getValue(long.class);
    boolean true1 = parser.parseExpression("true").getValue(boolean.class);
    boolean false1 = parser.parseExpression("false").getValue(boolean.class);
    Object null1 = parser.parseExpression("null").getValue(Object.class);

    System.out.println("str1=" + str1);
    System.out.println("int1=" + int1);
    System.out.println("long1=" + long1);
    System.out.println("float1=" + float1);
    System.out.println("double1=" + double1);
    System.out.println("hex1=" + hex1);
    System.out.println("hex2=" + hex2);
    System.out.println("true1=" + true1);
    System.out.println("false1=" + false1);
    System.out.println("null1=" + null1);
}
```

![image-20210408152433899](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210408152434.png)

##### **算数运算表达式**

![image-20210408153532014](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210408153532.png)

##### **关系表达式**

![image-20210408153725165](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210408153725.png)

##### **逻辑表达式**

且（and或者&&）、或(or或者||)、非(!或NOT)。

```java
@Test
public void test4() {
    ExpressionParser parser = new SpelExpressionParser();

    boolean result1 = parser.parseExpression("2>1 and (!true or !false)").getValue(boolean.class);
    boolean result2 = parser.parseExpression("2>1 && (!true || !false)").getValue(boolean.class);

    boolean result3 = parser.parseExpression("2>1 and (NOT true or NOT false)").getValue(boolean.class);
    boolean result4 = parser.parseExpression("2>1 && (NOT true || NOT false)").getValue(boolean.class);

    System.out.println("result1=" + result1);
    System.out.println("result2=" + result2);
    System.out.println("result3=" + result3);
    System.out.println("result4=" + result4);
}
```

![image-20210408153855508](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210408153855.png)

##### **字符串连接及截取表达式**

> 使用“+”进行字符串连接，使用“'String'[0] [index]”来截取一个字符，目前只支持截取一个，如“'Hello ' + 'World!'”得到“Hello World!”；而“'Hello World!'[0]”将返回“H”。



##### **三目运算**

> 三目运算符 **“表达式1?表达式2:表达式3”**用于构造三目运算表达式，如“2>1?true:false”将返回true；

##### **Elivis运算符**

> Elivis运算符**“表达式1?:表达式2”**从Groovy语言引入用于简化三目运算符的，当表达式1为非null时则返回表达式1，当表达式1为null时则返回表达式2，简化了三目运算符方式“表达式1? 表达式1:表达式2”，如“null?:false”将返回false，而“true?:false”将返回true；

##### **正则表达式**

> 使用“str matches regex，如“'123' matches '\d{3}'”将返回true；

##### **括号优先级表达式**

> 使用“(表达式)”构造，括号里的具有高优先级。

#### **2、类相关表达式**

##### **类类型表达式**

> 使用“T(Type)”来表示java.lang.Class实例，“Type”必须是类全限定名，“java.lang”包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。
>
> 具体使用方法如下：

```java
@Test
public void testClassTypeExpression() {
    ExpressionParser parser = new SpelExpressionParser();
    //java.lang包类访问
    Class<String> result1 = parser.parseExpression("T(String)").getValue(Class.class);
    System.out.println(result1);

    //其他包类访问
    String expression2 = "T(com.javacode2018.spel.SpelTest)";
    Class<SpelTest> value = parser.parseExpression(expression2).getValue(Class.class);
    System.out.println(value == SpelTest.class);

    //类静态字段访问
    int result3 = parser.parseExpression("T(Integer).MAX_VALUE").getValue(int.class);
    System.out.println(result3 == Integer.MAX_VALUE);

    //类静态方法调用
    int result4 = parser.parseExpression("T(Integer).parseInt('1')").getValue(int.class);
    System.out.println(result4);
}
```

> 对于java.lang包里的可以直接使用“T(String)”访问；其他包必须是类全限定名；可以进行静态字段访问如“T(Integer).MAX_VALUE”；也可以进行静态方法访问如“T(Integer).parseInt('1')”。

##### **类实例化**

> 类实例化同样使用java关键字“new”，类名必须是全限定名，但java.lang包内的类型除外，如String、Integer。

```java
@Test
public void testConstructorExpression() {
    ExpressionParser parser = new SpelExpressionParser();
    String result1 = parser.parseExpression("new String('路人甲java')").getValue(String.class);
    System.out.println(result1);

    Date result2 = parser.parseExpression("new java.util.Date()").getValue(Date.class);
    System.out.println(result2);
}
```

![image-20210408165132315](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210408165132.png)

##### **instanceof表达式**

> SpEL支持instanceof运算符，跟Java内使用同义；如“'haha' instanceof T(String)”将返回true。

```java
@Test
public void testInstanceOfExpression() {
    ExpressionParser parser = new SpelExpressionParser();
    Boolean value = parser.parseExpression("'路人甲' instanceof T(String)").getValue(Boolean.class);
    System.out.println(value);
}
```

##### **变量定义及引用**

> 变量定义通过EvaluationContext接口的setVariable(variableName, value)方法定义；在表达式中使用`"#variableName"`引用；除了引用自定义变量，SpE还允许引用根对象及当前上下文对象，使用**`"#root"`引用根对象**，使用**`"#this"`引用当前上下文对象**；

![image-20210408194649076](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210408194650.png)

##### **自定义函数**

> 目前只支持类静态方法注册为自定义函数；SpEL使用StandardEvaluationContext的registerFunction方法进行注册自定义函数，其实完全可以使用setVariable代替，两者其实本质是一样的；

```java
@Test
public void testFunctionExpression() throws SecurityException, NoSuchMethodException {
    //定义2个函数,registerFunction和setVariable都可以，不过从语义上面来看用registerFunction更恰当
    StandardEvaluationContext context = new StandardEvaluationContext();
    Method parseInt = Integer.class.getDeclaredMethod("parseInt", String.class);
    context.registerFunction("parseInt1", parseInt);
    context.setVariable("parseInt2", parseInt);

    ExpressionParser parser = new SpelExpressionParser();
    System.out.println(parser.parseExpression("#parseInt1('3')").getValue(context, int.class));
    System.out.println(parser.parseExpression("#parseInt2('3')").getValue(context, int.class));
    
    String expression1 = "#parseInt1('3') == #parseInt2('3')";
    boolean result1 = parser.parseExpression(expression1).getValue(context, boolean.class);
    System.out.println(result1);
}
```

此处可以看出“registerFunction”和“setVariable”都可以注册自定义函数，但是两个方法的含义不一样，推荐使用“registerFunction”方法注册自定义函数。

运行输出

```java
3
3
true
```

使用`Expression#setValue`方法可以给表达式赋值

```java
@Test
public void testAssignExpression1() {
    Object user = new Object() {
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        @Override
        public String toString() {
            return "$classname{" +
                    "name='" + name + '\'' +
                    '}';
        }
    };
    {
        //user为root对象
        ExpressionParser parser = new SpelExpressionParser();
        EvaluationContext context = new StandardEvaluationContext(user);
        parser.parseExpression("#root.name").setValue(context, "路人甲java");
        System.out.println(parser.parseExpression("#root").getValue(context, user.getClass()));
    }
    {
        //user为变量
        ExpressionParser parser = new SpelExpressionParser();
        EvaluationContext context = new StandardEvaluationContext();
        context.setVariable("user", user);
        parser.parseExpression("#user.name").setValue(context, "路人甲java");
        System.out.println(parser.parseExpression("#user").getValue(context, user.getClass()));
    }
}
```

##### **表达式赋值**

使用`Expression#setValue`方法可以给表达式赋值

```java
@Test
public void testAssignExpression1() {
    Object user = new Object() {
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        @Override
        public String toString() {
            return "$classname{" +
                    "name='" + name + '\'' +
                    '}';
        }
    };
    {
        //user为root对象
        ExpressionParser parser = new SpelExpressionParser();
        EvaluationContext context = new StandardEvaluationContext(user);
        parser.parseExpression("#root.name").setValue(context, "路人甲java");
        System.out.println(parser.parseExpression("#root").getValue(context, user.getClass()));
    }
    {
        //user为变量
        ExpressionParser parser = new SpelExpressionParser();
        EvaluationContext context = new StandardEvaluationContext();
        context.setVariable("user", user);
        parser.parseExpression("#user.name").setValue(context, "路人甲java");
        System.out.println(parser.parseExpression("#user").getValue(context, user.getClass()));
    }
}
```

运行输出

```java
$classname{name='路人甲java'}
$classname{name='路人甲java'}
```

##### **对象属性存取及安全导航表达式**

> 对象属性获取非常简单，即使用如“a.property.property”这种点缀式获取，SpEL对于属性名首字母是不区分大小写的；SpEL还引入了Groovy语言中的安全导航运算符“**(对象|属性)?.属性**”，用来避免“?.”前边的表达式为**null时抛出空指针异常，而是返回null**；修改对象属性值则可以通过赋值表达式或Expression接口的setValue方法修改。



```java
public static class Car {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Car{" +
                "name='" + name + '\'' +
                '}';
    }
}

public static class User {
    private Car car;

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        this.car = car;
    }

    @Override
    public String toString() {
        return "User{" +
                "car=" + car +
                '}';
    }
}

@Test
public void test5() {
    User user = new User();
    EvaluationContext context = new StandardEvaluationContext();
    context.setVariable("user", user);

    ExpressionParser parser = new SpelExpressionParser();
    //使用.符号，访问user.car.name会报错，原因：user.car为空
    try {
        System.out.println(parser.parseExpression("#user.car.name").getValue(context, String.class));
    } catch (EvaluationException | ParseException e) {
        System.out.println("出错了：" + e.getMessage());
    }
    //使用安全访问符号?.，可以规避null错误
    System.out.println(parser.parseExpression("#user?.car?.name").getValue(context, String.class));

    Car car = new Car();
    car.setName("保时捷");
    user.setCar(car);

    System.out.println(parser.parseExpression("#user?.car?.toString()").getValue(context, String.class));
}
```

运行输出

```java
出错了：EL1007E: Property or field 'name' cannot be found on null
null
Car{name='保时捷'}
```

##### **对象方法调用**

> 对象方法调用更简单，跟Java语法一样；如“'haha'.substring(2,4)”将返回“ha”；而对于根对象可以直接调用方法；

##### **Bean引用**

SpEL支持使用“@”符号来引用Bean，在引用Bean时需要使用BeanResolver接口实现来查找Bean，Spring提供BeanFactoryResolver实现。

```java
@Test
public void test6() {
    DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
    User user = new User();
    Car car = new Car();
    car.setName("保时捷");
    user.setCar(car);
    factory.registerSingleton("user", user);

    StandardEvaluationContext context = new StandardEvaluationContext();
    context.setBeanResolver(new BeanFactoryResolver(factory));

    ExpressionParser parser = new SpelExpressionParser();
    User userBean = parser.parseExpression("@user").getValue(context, User.class);
    System.out.println(userBean);
    System.out.println(userBean == factory.getBean("user"));
}
```

运行输出

```java
User{car=Car{name='保时捷'}}
true
```

#### **3、集合相关表达式**

###### **内联List**

从Spring3.0.4开始支持内联List，使用{表达式，……}定义内联List，如“{1,2,3}”将返回一个整型的ArrayList，而“{}”将返回空的List，对于字面量表达式列表，SpEL会使用java.util.Collections.unmodifiableList方法将列表设置为不可修改。

```java
@Test
public void test7() {
    ExpressionParser parser = new SpelExpressionParser();
    //将返回不可修改的空List
    List<Integer> result2 = parser.parseExpression("{}").getValue(List.class);
    //对于字面量列表也将返回不可修改的List
    List<Integer> result1 = parser.parseExpression("{1,2,3}").getValue(List.class);
    Assert.assertEquals(new Integer(1), result1.get(0));
    try {
        result1.set(0, 2);
    } catch (Exception e) {
        e.printStackTrace();
    }
    //对于列表中只要有一个不是字面量表达式，将只返回原始List，
    //不会进行不可修改处理
    String expression3 = "{{1+2,2+4},{3,4+4}}";
    List<List<Integer>> result3 = parser.parseExpression(expression3).getValue(List.class);
    result3.get(0).set(0, 1);
    System.out.println(result3);
    //声明二维数组并初始化
    int[] result4 = parser.parseExpression("new int[2]{1,2}").getValue(int[].class);
    System.out.println(result4[1]);
    //定义一维数组并初始化
    int[] result5 = parser.parseExpression("new int[1]").getValue(int[].class);
    System.out.println(result5[0]);
}
```

输出

```java
java.lang.UnsupportedOperationException
 at java.util.Collections$UnmodifiableList.set(Collections.java:1311)
 at com.javacode2018.spel.SpelTest.test7(SpelTest.java:315)
[[1, 6], [3, 8]]
2
0
```

###### **内联数组**

和Java 数组定义类似，只是在定义时进行多维数组初始化。

```java
int[][][] result4 = parser.parseExpression("new int[1][2][3]{{1}{2}{3}}").getValue(int[][][].class);
```

###### **集合，字典元素访问**

SpEL目前支持所有集合类型和字典类型的元素访问，使用“集合[索引]”访问集合元素，使用“map[key]”访问字典元素；

```java
//SpEL内联List访问  
int result1 = parser.parseExpression("{1,2,3}[0]").getValue(int.class);  

//SpEL目前支持所有集合类型的访问  
Collection<Integer> collection = new HashSet<Integer>();  
collection.add(1);  
collection.add(2);  

EvaluationContext context2 = new StandardEvaluationContext();  
context2.setVariable("collection", collection);  
int result2 = parser.parseExpression("#collection[1]").getValue(context2, int.class);  


//SpEL对Map字典元素访问的支持  
Map<String, Integer> map = new HashMap<String, Integer>();  
map.put("a", 1);  

EvaluationContext context3 = new StandardEvaluationContext();  
context3.setVariable("map", map);  
int result3 = parser.parseExpression("#map['a']").getValue(context3, int.class);  
```

###### **列表，字典，数组元素修改**

可以使用赋值表达式或Expression接口的setValue方法修改；

```java
@Test
public void test8() {
    ExpressionParser parser = new SpelExpressionParser();

    //修改list元素值
    List<Integer> list = new ArrayList<Integer>();
    list.add(1);
    list.add(2);

    EvaluationContext context1 = new StandardEvaluationContext();
    context1.setVariable("collection", list);
    parser.parseExpression("#collection[1]").setValue(context1, 4);
    int result1 = parser.parseExpression("#collection[1]").getValue(context1, int.class);
    System.out.println(result1);

    //修改map元素值
    Map<String, Integer> map = new HashMap<String, Integer>();
    map.put("a", 1);
    EvaluationContext context2 = new StandardEvaluationContext();
    context2.setVariable("map", map);
    parser.parseExpression("#map['a']").setValue(context2, 4);
    Integer result2 = parser.parseExpression("#map['a']").getValue(context2, int.class);
    System.out.println(result2);
}
```

输出

```java
4
4
```

###### **集合投影**

在SQL中投影指从表中选择出列，而在SpEL指根据集合中的元素中通过选择来构造另一个集合，该集合和原集合具有相同数量的元素；SpEL使用“（list|map）.![投影表达式]”来进行投影运算：

```java
@Test
public void test9() {
    ExpressionParser parser = new SpelExpressionParser();

    //1.测试集合或数组
    List<Integer> list = new ArrayList<Integer>();
    list.add(4);
    list.add(5);
    EvaluationContext context1 = new StandardEvaluationContext();
    context1.setVariable("list", list);
    Collection<Integer> result1 = parser.parseExpression("#list.![#this+1]").getValue(context1, Collection.class);
    result1.forEach(System.out::println);

    System.out.println("------------");
    //2.测试字典
    Map<String, Integer> map = new HashMap<String, Integer>();
    map.put("a", 1);
    map.put("b", 2);
    EvaluationContext context2 = new StandardEvaluationContext();
    context2.setVariable("map", map);
    List<Integer> result2 = parser.parseExpression("#map.![value+1]").getValue(context2, List.class);
    result2.forEach(System.out::println);
}
```

对于集合或数组使用如上表达式进行投影运算，其中投影表达式中“#this”代表每个集合或数组元素，可以使用比如“#this.property”来获取集合元素的属性，其中“#this”可以省略。

Map投影最终只能得到List结果，如上所示，对于投影表达式中的“#this”将是Map.Entry，所以可以使用“value”来获取值，使用“key”来获取键。

![image-20210409113941134](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210409113941.png)

###### **集合选择**

在SQL中指使用select进行选择行数据，而在SpEL指根据原集合通过条件表达式选择出满足条件的元素并构造为新的集合，SpEL使用“(list|map).?[选择表达式]”，其中选择表达式结果必须是boolean类型，如果true则选择的元素将添加到新集合中，false将不添加到新集合中。

```java
@Test
public void test10() {
    ExpressionParser parser = new SpelExpressionParser();

    //1.测试集合或数组
    List<Integer> list = new ArrayList<Integer>();
    list.add(1);
    list.add(4);
    list.add(5);
    list.add(7);
    EvaluationContext context1 = new StandardEvaluationContext();
    context1.setVariable("list", list);
    Collection<Integer> result1 = parser.parseExpression("#list.?[#this>4]").getValue(context1, Collection.class);
    result1.forEach(System.out::println);

    System.out.println("------------");
    
}
```

输出

```java
5
7
```

对于集合或数组选择，如“#collection.?[#this>4]”将选择出集合元素值大于4的所有元素。选择表达式必须返回布尔类型，使用“#this”表示当前元素。

```java
//2.测试字典
Map<String, Integer> map = new HashMap<String, Integer>();
map.put("a", 1);
map.put("b", 2);
map.put("c", 3);
EvaluationContext context2 = new StandardEvaluationContext();
context2.setVariable("map", map);
Map<String, Integer> result2 = parser.parseExpression("#map.?[key!='a']").getValue(context2, Map.class);
result2.forEach((key, value) -> {
    System.out.println(key + ":" + value);
});
System.out.println("------------");
List<Integer> result3 = parser.parseExpression("#map.?[key!='a'].![value+1]").getValue(context2, List.class);
result3.forEach(System.out::println);
```

输出

```java
b:2
c:3
------------
3
4
```

对于字典选择，如“#map.?[#this.key != 'a']”将选择键值不等于”a”的，其中选择表达式中“#this”是Map.Entry类型，而最终结果还是Map，这点和投影不同；集合选择和投影可以一起使用，如“#map.?[key != 'a'].![value+1]”将首先选择键值不等于”a”的，然后在选出的Map中再进行“value+1”的投影。

#### **4、表达式模板**

模板表达式就是由字面量与一个或多个表达式块组成。每个表达式块由“前缀+表达式+后缀”形式组成，如“${1+2}”即表达式块。在前边我们已经介绍了使用ParserContext接口实现来定义表达式是否是模板及前缀和后缀定义。在此就不多介绍了，如“Error ${#v0} ${#v1}”表达式表示由字面量“Error ”、模板表达式“#v0”、模板表达式“#v1”组成，其中v0和v1表示自定义变量，需要在上下文定义。

解析表达式的时候需要指定模板，模板通过`ParserContext`接口来定义

```java
public interface ParserContext {
 //是否是模板
 boolean isTemplate();
 //模板表达式前缀
 String getExpressionPrefix();
 //模板表达式后缀
 String getExpressionSuffix();
}
```

有个子类，我们直接可以拿来用：`TemplateParserContext`。

```java
@Test
public void test11() {
    //创建解析器
    SpelExpressionParser parser = new SpelExpressionParser();
    //创建解析器上下文
    ParserContext context = new TemplateParserContext("%{", "}");
    Expression expression = parser.parseExpression("你好:%{#name},我们正在学习:%{#lesson}", context);

    //创建表达式计算上下文
    EvaluationContext evaluationContext = new StandardEvaluationContext();
    evaluationContext.setVariable("name", "路人甲java");
    evaluationContext.setVariable("lesson", "spring高手系列!");
    //获取值
    String value = expression.getValue(evaluationContext, String.class);
    System.out.println(value);
}
```

运行输出

```java
你好:路人甲java,我们正在学习:spring高手系列!
```

#### **5、在Bean定义中使用spel表达式**

##### **xml风格的配置**

SpEL支持在Bean定义时注入，**默认使用“#{SpEL表达式}”表示**，其中“#root”根对象默认可以认为是ApplicationContext，只有ApplicationContext实现默认支持SpEL，获取根对象属性其实是获取容器中的Bean。

如：

```html
<bean id="world" class="java.lang.String">  
    <constructor-arg value="#{' World!'}"/>  
</bean>  

<bean id="hello1" class="java.lang.String">  
    <constructor-arg value="#{'Hello'}#{world}"/>  
</bean>    

<bean id="hello2" class="java.lang.String">  
    <constructor-arg value="#{'Hello' + world}"/>
</bean>  

<bean id="hello3" class="java.lang.String">  
    <constructor-arg value="#{'Hello' + @world}"/>  
</bean>
```

模板默认以前缀“#{”开头，以后缀“}”结尾，且不允许嵌套，如“#{'Hello'#{world}}”错误，如“#{'Hello' + world}”中“world”默认解析为Bean。当然可以使用“@bean”引用了。

是不是很简单，除了XML配置方式，Spring还提供一种注解方式@Value，接着往下看吧。

##### **注解风格的配置**

基于注解风格的SpEL配置也非常简单，使用@Value注解来指定SpEL表达式，该注解可以放到字段、方法及方法参数上。

测试Bean类如下，使用@Value来指定SpEL表达式：

```java
public class SpELBean {  
    @Value("#{'Hello' + world}")  
    private String value;  
}
```

##### **在Bean定义中SpEL的问题**

如果有同学问“#{我不是SpEL表达式}”不是SpEL表达式，而是公司内部的模板，想换个前缀和后缀该如何实现呢？

我们使用BeanFactoryPostProcessor接口提供postProcessBeanFactory回调方法，它是在IoC容器创建好但还未进行任何Bean初始化时被ApplicationContext实现调用，因此在这个阶段把SpEL前缀及后缀修改掉是安全的，具体代码如下：

```java
package com.javacode2018.spel.test1;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanExpressionResolver;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.context.expression.StandardBeanExpressionResolver;
import org.springframework.stereotype.Component;

@Component
public class SpelBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        BeanExpressionResolver beanExpressionResolver = beanFactory.getBeanExpressionResolver();
        if (beanExpressionResolver instanceof StandardBeanExpressionResolver) {
            StandardBeanExpressionResolver resolver = (StandardBeanExpressionResolver) beanExpressionResolver;
            resolver.setExpressionPrefix("%{");
            resolver.setExpressionSuffix("}");
        }
    }
}
```

上测试代码

```java
package com.javacode2018.spel.test1;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class LessonModel {
    @Value("你好,%{@name},%{@msg}")
    private String desc;

    @Override
    public String toString() {
        return "LessonModel{" +
                "desc='" + desc + '\'' +
                '}';
    }
}
```

@name：容器中name的bean

@msg：容器中msg的bean

下面我们来个配置类，顺便定义name和msg这2个bean，顺便扫描上面2个配置类

```java
package com.javacode2018.spel.test1;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@ComponentScan
@Configuration
public class MainConfig {
    @Bean
    public String name() {
        return "路粉";
    }

    @Bean
    public String msg() {
        return "欢迎和我一起学习java各种技术！";
    }
}
```

测试用例

```java
@Test
public void test12() {
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
    context.register(MainConfig.class);
    context.refresh();
    LessonModel lessonModel = context.getBean(LessonModel.class);
    System.out.println(lessonModel);
}
```

运行输出

```java
LessonModel{desc='你好,路粉,欢迎和我一起学习java各种技术！'}
```

#### **总结**

1. Spel功能还是比较强大的，可以脱离spring环境独立运行
2. spel可以用在一些动态规则的匹配方面，比如监控系统中监控规则的动态匹配；其他的一些条件动态判断等等
3. 本文内容比较长，建议大家把案例都敲一遍，可以设置一些断点去研究一下源码，有问题的，欢迎大家留言交流。



## 线程池

### 一、工具类

```java
package com.nd.elearning.school.courselib.core.util;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * @description:
 * @author: Chenql
 * @time: 2020/6/12 21:28
 */
public class ThreadPoolUtils {
    
    private static final int core_pool_size = Runtime.getRuntime().availableProcessors() + 1;
    
    private static final int max_pool_size = Runtime.getRuntime().availableProcessors() * 2;
    
    private static final long keep_alive_time = 2000;
    
    private static final int block_queue_size = 1000;
    
    private static BlockingQueue bQueue = new ArrayBlockingQueue(block_queue_size);
    
    private static ThreadFactory threadFactory = new ThreadFactory() {
        private final AtomicInteger atomicInteger = new AtomicInteger();
        
        @Override
        public Thread newThread(Runnable r) {
            return new Thread(r, "school_course_library:" + atomicInteger.getAndIncrement());
        }
    };
    
    private static ThreadPoolExecutor pool = new ThreadPoolExecutor(core_pool_size,
                                                                    max_pool_size,
                                                                    keep_alive_time,
                                                                    TimeUnit.MILLISECONDS,
                                                                    bQueue,
                                                                    threadFactory,
                                                                    new ThreadPoolExecutor.CallerRunsPolicy());
    
    static {
        pool.prestartAllCoreThreads();
    }
    
    public static ThreadPoolExecutor getPool() {
        return pool;
    }
    
    public static void execute(Runnable runnable) {
        pool.execute(runnable);
    }
    
    public static <V> Future<V> submit(Callable<V> callable) {
        return pool.submit(callable);
    }
    
    public static void shutDown() {
        pool.shutdown();
    }
}

```

### 二、线程池监控

> 如果你想监控某一个线程池的执行状态，线程池执行类 ThreadPoolExecutor 也给出了相关的 API, 能实时获取线程池的当前活动线程数、正在排队中的线程数、已经执行完成的线程数、总线程数等。
>
> 总线程数 = 排队线程数 + 活动线程数 + 执行完成的线程数。

```java
private static ExecutorService es = new ThreadPoolExecutor(50, 100, 0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<Runnable>(100000));
 
public static void main(String[] args) throws Exception {
  for (int i = 0; i < 100000; i++) {
    es.execute(() -> {
      System.out.print(1);
      try {
        Thread.sleep(1000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    });
  }
 
  ThreadPoolExecutor tpe = ((ThreadPoolExecutor) es);
 
  while (true) {
    System.out.println();
 
    int queueSize = tpe.getQueue().size();
    System.out.println("当前排队线程数：" + queueSize);
 
    int activeCount = tpe.getActiveCount();
    System.out.println("当前活动线程数：" + activeCount);
 
    long completedTaskCount = tpe.getCompletedTaskCount();
    System.out.println("执行完成线程数：" + completedTaskCount);
 
    long taskCount = tpe.getTaskCount();
    System.out.println("总线程数：" + taskCount);
 
    Thread.sleep(3000);
  }
 
}
```



## swagger注解

#### **1、创建基本信息的配置类**

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

/**
 * Swagger基本信息的配置
 * 
 * @author chy
 *
 */
@Configuration
public class SwaggerConfig {

	@Bean
	public Docket getDocket() {
		return new Docket(DocumentationType.SWAGGER_2).apiInfo(swaggerApiInfo()).select().build();
	}

	private ApiInfo swaggerApiInfo() {
		return new ApiInfoBuilder()
				// 联系人信息 name url email
				.contact(new Contact("时间静止不是简史", "https://blog.csdn.net/qq_43371556", "xxx@qq.com"))
				// 文档标题
				.title("这里是Swagger 的标题")
				// 文档描述
				.description("这里是Swagger 的描述")
				// 文档版本
				.version("1.0.0").build();
	}

}


```

#### 2、 设置扫描的包(类级别)

```java
@Configuration
public class SwaggerConfig {

	@Bean
	public Docket getDocket() {
		return new Docket(DocumentationType.SWAGGER_2).apiInfo(swaggerApiInfo())
				.select()
				//设置扫描的包
			    .apis(RequestHandlerSelectors.basePackage("ah.szxy.springcloud.provider.controller"))
				.build();
	}



	private ApiInfo swaggerApiInfo() {
		return new ApiInfoBuilder()
				// 联系人信息 name url email
				.contact(new Contact("时间静止不是简史", "https://blog.csdn.net/qq_43371556", "xxx@qq.com"))
				// 文档标题
				.title("这里是Swagger 的标题")
				// 文档描述
				.description("这里是Swagger 的描述")
				// 文档版本
				.version("1.0.0").build();
	}
	
	

}

```



在Java类中添加Swagger的注解即可生成Swagger接口，

#### 3、常用Swagger注解如下：

@Api：

修饰整个类，描述Controller的作用

@ApiOperation：

描述一个类的一个方法，或者说一个接口

@ApiParam：

单个参数描述

@ApiModel：

用对象来接收参数

@ApiModelProperty：

用对象接收参数时，描述对象的一个字段

@ApiResponse：

HTTP响应其中1个描述

@ApiResponses：

HTTP响应整体描述

@ApiIgnore：

使用该注解忽略这个API

@ApiError ：

发生错误返回的信息

@ApiImplicitParam：

一个请求参数

@ApiImplicitParams：

多个请求参数

@ApiImplicitParam

属性：


![image-20200709144044271](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200709144045.png)

![image-20200709171007046](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200709171008.png)

![image-20200709171027608](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200709171028.png)

#### 4、swagger2注解

##### （1） Api(修改controller名与描述信息)

> tags：类的名称。可以有多个值，多个值表示多个副本。
> description:描述信息，已过时。

![image-20200709173239905](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200709173240.png)

![image-20200709173302689](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200709173303.png)

##### （2）ApiOperation(修改Handle的描述和详细信息)

> value：接口描述
> notes：详细提示信息

![image-20200709173352793](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200709173353.png)

![image-20200709173410747](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200709173411.png)

##### （3）ApiParam(方法参数前)

> @ApiParam 写在**方法参数前面**。用于对参数进行描述或说明是否为必添项等说明。
> name：参数名称
> value：参数描述
> required：是否是必须

![image-20200709173503889](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200709173504.png)

![image-20200709173539569](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200709173540.png)

##### （4）ApiModel(类上)

> @ApiModel 是类上注解，主要应用Model，也就是说这个注解一般都是写在实体类上。
> value：名称
> description：描述

![image-20200709173654434](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200709173655.png)

##### （5）ApiModelProperty(方法或属性)

> @ApiModelProperty 可以用在 方法或属性 上。用于当对象作为参数时定义这个字段的内容。
> value：描述
> name：重写属性名
> required：是否是必须的
> example：示例内容
> hidden：是否隐藏。



![image-20200709173735280](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200709173736.png)

##### （6）ApiIgnore(类或方法或参数上)

> @ApiIgnore 用于 方法或类或参数 上，表示这个方法或类被忽略。
> 和之前讲解的自定义注解@NotIncludeSwagger 效果类似。
> 只是这个注解是Swagger 内置的注解，而@NotIncludeSwagger 是我们自定义的注解。

##### （7）ApiImplicitParam(方法上)

> @ApiImplicitParam 用在方法上，表示单独的请求参数，总体功能**和@ApiParam 类似。**
> name：属性名
> value：描述
> required：是否是必须的
> paramType：属性类型
> dataType：数据类型

![image-20200709175201693](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200709175202.png)

![image-20200709175214409](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200709175215.png)

Swagger其实就是在管理Controller中的Handle所对应的接口,
由于管理后的描述文件是 json/yml格式不易观看, 所以引入了一个Swagger UI图形化管理页面
方便开发人员操作使用, 后端人员只需要引入Swagger和UI的坐标并在启动类添加@EnableSwagger2注解,
前端人员只需要访问 UI页面就可以实时的动态的知晓最新的接口信息, 减少人员沟通, 提升开发效率
通过使用相关注解, 可以方便我们快捷的对UI 页面的信息进行有解释的有选择的显示

```dart
@Api：修饰整个类，描述Controller的作用
@ApiOperation：描述一个类的一个方法，或者说一个接
@ApiParam：单个参数描述
@ApiModel：用对象来接收参数
@ApiProperty：用对象接收参数时，描述对象的一个字段
@ApiResponse：HTTP响应其中1个描述
@ApiResponses：HTTP响应整体描述
@ApiIgnore：使用该注解忽略这个API
@ApiError ：发生错误返回的信息
@ApiImplicitParam：一个请求参数
@ApiImplicitParams：多个请求参数
```

```java
@RestController
@Api(description = "关于用户接口",value = "用户接口",tags = {"用户接口"})  //使用@Api来修饰类
public class UserController {

    @Autowired
    private UserService userService;


    @GetMapping("/getUser/{userId}")    //使用RestFul风格
    //使用@ApiOperation注解来修饰接口
    @ApiOperation(value = "通过用户Id来获取用户信息",notes = "RestFul风格，需要传用户Id")
    //使用ApiImplcitParam修饰接口参数
    @ApiImplicitParam(name = "userId",value = "用户Id",required = true)
    public User getUserById(@PathVariable("userId") Integer userId){
        return userService.selectById(userId);
    }
}
```

#### 5、spring boot和swagger中隐藏请求参数

低版本的swagger不支持,高版本的swagger(目前已知2.6.0 及以上版本支持)

  则可使用 hidden = true 隐藏参数







## 缓存注解

#### 使用@EnableCaching注解开启缓存

![image-20201010172423912](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201010172424.png)

#### 简单介绍常用注解

> @Cacheable ，作用在方法上，触发缓存读取操作
> @CacheEvict ，作用在方法上，触发缓存失效操作
> @CachePut ，作用在方法上，触发缓存更新操作。
> @Cache ，作用在方法上，综合上面的各种操作，在有些场景下 ，调用业务会触发多种缓存操作。
> @CacheConfig ，在类上设置当前缓存 一些公共设置。



#### @Cacheable

> @Cacheable可以标记在一个方法上，也可以**标记在一个类**上。当标记在一个方法上时表示该方法是支持缓存的，当标记在一个类上时则表示该类**所有的方法都是支持缓存**的。对于一个支持缓存的方法，Spring会在其被调用后**将其返回值缓存起来**，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。Spring在缓存方法的返回值时是以键值对进行缓存的，**值就是方法的返回结果**，至于键的话，Spring又支持两种策略，默认策略和自定义策略，这个稍后会进行说明。需要注意的是当一个支持缓存的方法在**对象内部被调用时是不会触发缓存功能**的。@Cacheable可以指定三个属性，value、key和condition。

![image-20200714172231410](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200714172231.png)

##### value属性指定Cache名称

> value属性是必须指定的，其表示当前方法的返回值是会被缓存在哪个Cache上的，对应Cache的名称。其可以是一个Cache也可以是多个Cache，当需要指定多个Cache时其是一个数组。

```java
@Cacheable("cache1")//Cache是发生在cache1上的
   public User find(Integer id) {
      returnnull;
   }
  @Cacheable({"cache1", "cache2"})//Cache是发生在cache1和cache2上的
   public User find(Integer id) {
      returnnull;
   }
```

##### **使用key属性自定义key**

> key属性是用来指定Spring缓存方法的返回结果时对应的key的。该属性支持SpringEL表达式。当我们没有指定该属性时，Spring将使用默认策略生成key。我们这里先来看看自定义策略，至于默认策略会在后文单独介绍。
>        自定义策略是指我们可以**通过Spring的EL表达式来指定我们的key**。这里的EL表达式可以使用方法参数及它们对应的属性。使用方法参数时我们可以直接使用**“#参数名”或者“#p参数index”**。下面是几个使用参数作为key的示例。

```java
/**
* key 是指传入时的参数
*
*/
   @Cacheable(value="users", key="#id")
   public User find(Integer id) {
      returnnull;
   }
// 表示第一个参数
  @Cacheable(value="users", key="#p0")
   public User find(Integer id) {
      returnnull;
   }
// 表示User中的id值
   @Cacheable(value="users", key="#user.id")
   public User find(User user) {
      returnnull;
   }
 // 表示第一个参数里的id属性值
   @Cacheable(value="users", key="#p0.id")
   public User find(User user) {
      returnnull;
   }
```

除了上述使用方法参数作为key之外，Spring还为我们提供了一个***<u>root对象</u>***可以用来生成key。通过该root对象我们可以获取到以下信息。

![image-20200714172709563](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200714172709.png)

```java
    // key值为: user中的name属性的值
  @Cacheable(value={"users", "xxx"}, key="caches[1].name")
   public User find(User user) {
      returnnull;
   }
```

##### condition属性指定发生的条件

> 有的时候我们可能并不希望缓存一个方法所有的返回结果。通过condition属性可以实现这一功能。condition属性默认为空，表示将缓存所有的调用情形。其值是通过SpringEL表达式来指定的，当为true时表示进行缓存处理；当为false时表示不进行缓存处理，即每次调用该方法时该方法都会执行一次。如下示例表示只有当user的id为偶数时才会进行缓存。

```java
    // 根据条件判断是否缓存
    @Cacheable(value={"users"}, key="#user.id", condition="#user.id%2==0")
   public User find(User user) {
      System.out.println("find user by user " + user);
      return user;
   }
```

##### cacheManager

> 类型为：`org.springframework.cache.CacheManager` 的bean的名称。该bean需要我们在spring配置文件中配置。在SpringBoot中，如果检测到有对应的缓存框架，则会自动配置一个名称为`cacheManager`的bean。
>
> 用于指定使用哪个缓存管理器，非必需。只有当有多个时才需要使用

##### cacheResolver

> 类型为：`org.springframework.cache.interceptor.CacheResolver` 的bean的名称。
>
> 用于指定使用那个缓存解析器，非必需。需通过org.springframework.cache.interceptor.CacheResolver接口来实现自己的缓存解析器，并用该参数指定。

##### unless

类型为字符串，结果是SpEL表达式，和`condition`不同的是，该表示式是在方法调用会进行计算的，用来否决方法的缓存。默认是空字符串，意味着从来不否决缓存结果。

##### sync

> 类型是boolean，4.3版本开始支持。表示在多个线程同时`加载`同一个缓存key对应的资源时，是否进行同步。默认值为false。
>
> 如果设置为true, 则能避免重复加载。该属性的功能能否起作用取决于如下条件：
>
> 1. 不支持unless
> 2. 只能指定一个缓存（cacheName取值唯一）
> 3. 不能和其它缓存相关的操作进行组合

##### 自定义缓存 key 的生成器 KeyGenerator

> 根据前面介绍可知，默认情况下缓存的 **key** 是方法的参数。如果不想使用默认的 **key**，可以使用自定义 **key**（使用参数定义 **key** 的方式、或者使用 **root** 对象来生成 **key**)
>   如果这些 **key** 不能满足开发需求，我们也可以自定义缓存 **key** 的生成器 **KeyGenerator**

###### 1、创建自定义 KeyGenerator

![image-20201010173915348](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201010173915.png)

###### 2.使用MyKeyGenerator自定义的key生成策略

![image-20201010173943435](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201010173943.png)

##### 缓存key的计算规则

> 上面提到缓存`key`的格式为SpEL表达式。默认的计算规则如下：
>
> - 如果方法没有参数，则返回0
> - 如果方法只有一个参数，则返回该参数。
> - 如果方法有多余一个参数，则key的值由所有参数的hashcode计算而来。具体可以参考`SimpleKeyGenerator`
> - spEL使用"T(Type)"来表示 java.lang.Class 实例

![image-20201010173019810](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201010173019.png)



#### **@Cacheable 的一些注意点**

> 1、因为@Cacheable 由AOP 实现，所以，如果该方法被其它注解切入，当缓存命中的时候，则其它注解不能正常切入并执行，@Before 也不行，当缓存没有命中的时候，其它注解可以正常工作
>
> 2、@Cacheable 方法不能进行内部调用，否则缓存无法创建
>
> 3、@Cacheable标注的方法，如果其所在的类实现了某一个接口，那么该方法也必须出现在接口里面，否则cache无效。
> 具体的原因是， Spring把实现类装载成为Bean的时候，会用代理包装一下，所以从Spring Bean的角度看，只有接口里面的方法是可见的，其它的都隐藏了，自然课看不到实现类里面的非接口方法，@Cacheable不起作用。
>
> 
> 解决办法：把待cache的方法移到接口里面。
>
>
> 另外衍生两个小问题：
> \1. @Cacheable放接口里面可以吗？答案是：不行。
> \2. 如果某一个Bean并没有实现任何接口，@Cacheable标注的方法有什么要求？
>   答案是public即可。这种Bean也被Spring产生了代理， 看得到的只有public方法。
>
> 本质是Spring代理的问题，很多的基础设施可能都会遇到类似的问题。比如安全，事务，日志等等。



#### @CachePut

在支持Spring Cache的环境下，对于使用@Cacheable标注的方法，Spring在每次执行前都会检查Cache中是否存在相同key的缓存元素，如果存在就不再执行该方法，而是直接从缓存中获取结果进行返回，否则才会执行并将返回结果存入指定的缓存中。@CachePut也可以声明一个方法支持缓存功能。与@Cacheable不同的是使用@CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。

```java
 //@CachePut也可以标注在类上和方法上。使用@CachePut时我们可以指定的属性跟@Cacheable是一样的。
   @CachePut("users")//每次都会执行方法，并将结果存入指定的缓存中
   public User find(Integer id) {
      returnnull;
   }
```

#### @CacheEvict

>  @CacheEvict是用来标注在需要清除缓存元素的方法或类上的。当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。@CacheEvict可以指定的属性有value、key、condition、allEntries和beforeInvocation。其中value、key和condition的语义与@Cacheable对应的属性类似。即value表示清除操作是发生在哪些Cache上的（对应Cache的名称）；key表示需要清除的是哪个key，如**未指定则会使用默认策略生成的key**；condition表示**清除操作发生的条件**。下面我们来介绍一下新出现的两个属性allEntries和beforeInvocation。

##### allEntries属性

>   allEntries是boolean类型，表示是否需要清除缓存中的所有元素。默认为false，表示不需要。当指定了allEntries为true时，Spring Cache**将忽略指定的key**。有的时候我们需要Cache一下清除所有的元素，这比一个一个清除元素更有效率。

##### beforeInvocation属性

> 清除操作默认是在对应方法***成功执行***之后触发的，即方法如果因为抛出异常而**未能成功**返回时也**不会触发清除操作**。使用beforeInvocation可以改变触发清除操作的时间，当我们指定该属性值为true时，Spring会在**调用该方法之前清除缓存中的指定元素**。

```java
   @CacheEvict(value="users", beforeInvocation=true)
   public void delete(Integer id) {
      System.out.println("delete user by id: " + id);
   }
```

#### @Caching

> @Caching注解可以让我们在一个方法或者类上同时**指定多个**Spring Cache相关的注解。其拥有三个属性：cacheable、put和evict，分别用于指定@Cacheable、@CachePut和@CacheEvict。

```java
   @Caching(cacheable = @Cacheable("users"), evict = { @CacheEvict("cache2"),
   @CacheEvict(value = "cache3", allEntries = true) })
   public User find(Integer id) {
      return null;
   }
```













## Spring Data Jpa

### 一、实体类继承抽象类

#### 1、在抽象父类上加上注解@MappedSuperclass

```java
@MappedSuperclass
public class Pet {
    private Integer id;//id
    private String name;//名字
    private String variety;//品种
    private double weight;//体重
    private Integer age;//年龄
    private char vaccine;//是否注射疫苗 y:已注射 n:未注射 d:未知
    private Integer ownerId;//主人id
    private char LookingForOwner;//是否在寻找主人 y:正在寻找 n:未在寻找
    private String pic;//照片地址
    @Id
    @GeneratedValue
    public String getPic() {
        return pic;
    }
/剩下的get set方法省略
```

#### 子类直接继承抽象父类并加上@Entity注解

并用@Table(name = "t_dog")指明映射的表

```java
@Entity
@Table(name = "t_dog")
public class Dog extends Pet{
```

此时运行项目生成的表中有父类中的属性，并且id作为自增主键

#### 2.实体类常用注解

**@Entity**

标识这个实体类是一个JPA实体，告诉JPA在程序运行的时候记得生成这个实体类所对应的表

**@Table（name = "自定义的表名"）**

自定义设置这个实体类在数据库所对应的表名，默认是实体类名。注：Mysql关键字不要设置为实体类，会发生创建表不成功的问题。例如：leave

**@org.hibernate.annotations.Table(appliesTo = "t_holiday_info", comment = "节假日信息表")**

定义表的注释，用来了解表的内容

**@Id**

把这个类里面所在的变量设置为主键Id

**@GeneratedValue**

> 设置主键的生成策略，这种方式依赖于具体的数据库，如果数据库不支持自增主键，那么这个类型是没法用的
>
> @GeneratedValue(strategy = GenerationType.SEQUENCE,generator = "repair_seq")：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。

例如：

![img](https://img2018.cnblogs.com/i-beta/1844119/201911/1844119-20191107161701008-515169858.png)



**@Basic**

> 表示一个简单的属性到数据库表的字段的映射,对于没有任何标注的getXxxx()方法,默认 即为 @Basic fetch: 表示该属性的读取策略,有EAGER和LAZY两种,分别表示主支抓取和延迟加载,默认为EAGER.

**@Column**

> @Column表示列的说明，如果字段名与列名相同，则可以省略。@Column注解属性详细说明
>
> （1）name属性：被标注字段在数据库表中所对应字段的名称；
> （2）length属性：表示该字段的长度，当字段的类型为varchar时，该属性才有效果，默认为255个字符；
> （3）nullable属性：表示该字段是否可以为null值，默认是true。
> （4）unique属性：表示该字段是否为唯一标识，默认fasle。
> （5）precision和scale属性：precision属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。
>
> 描述数据库表中该字段的定义,具有一下属性 
> name：表示数据库表中该字段的名称，默认情形属性名称一致。 
> nullable：表示该字段是否允许为null，默认为true。 
> unique：表示该字段是否是唯一标识，默认为false。 
> length：表示该字段的大小，仅对String类型的字段有效。 
> insertable：表示在ORM框架执行插入操作时，该字段是否应出现INSETRT语句中，默认为true。 
> updateable：表示在ORM框架执行更新操作时，该字段是否应该出现在UPDATE语句中，默认为true。对于一经创建就不可以更改的字段，该属性非常有用，如对于birthday字段。 
> columnDefinition：表示该字段在数据库中的实际类型。通常ORM框架可以根据属性类型自动判断数据库中字段的类型，但是对于Date类型仍无法确定数据库中字段类型究竟是DATE，TIME还是TIMESTAMP。此外，String的默认映射类型为VARCHAR，如果要将String类型映射到特定数据库的BLOB或TEXT字段类型，该属性非常有用。

**@Transient**

> 表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性. 如果一个属性并非数据库表的字段映射,就务必将其标示为 @Transient ,否则,ORM框架默认其注 解为 @Basic

**@Temporal**

> @Temporal注解表示格式化时间日期。有三种，默认是@Temporal(TemporalType.TIMESTAMP)。具体如下：
> （1）@Temporal(TemporalType.DATE)：日期，页面取得结果格式如：2016-08-05
> （2）@Temporal(TemporalType.TIME)：时间，页面取得结果是： 13:46:25
> （3）@Temporal(TemporalType.TIMESTAMP):时间和日期，页面取得结果是：2016-08-05 13:46:25
>
> 注解方式有两种：　
>
> 写在字段上：

```java
    @Temporal(TemporalType.TIMESTAMP)
    private Date birthday;
```

写在 getXxx方法上：

```java
    @Temporal(TemporalType.DATE)
    @Column(name = "birthday", length = 10)
    public Date getBirthday() {
        return this.birthday;
    }
```

**@Enumerated（"需要定义存入数据库的类型”)**

**使用@Enumerated映射枚举字段，我这里为性别建立了性别的枚举类型，而后面跟上的是存入数据库以String类型存入。**

实体类示例（Customer）：

![img](https://img2018.cnblogs.com/i-beta/1844119/201911/1844119-20191107172212365-61890947.png)



![img](https://img2018.cnblogs.com/i-beta/1844119/201911/1844119-20191107172327994-1728109875.png)

![img](https://img2018.cnblogs.com/i-beta/1844119/201911/1844119-20191107172427908-1261228053.png)



**@DateTimeFormat**

> 因为传入的参数是 String 类型的，而用来接收参数的 DateVo 的 date 属性是 java.util.Date 类型的，类型无法转换
>
> 可以使用 Spring 的 @DateTimeFormat 注解格式化参数
>
> 假如注解为：
>
> @DateTimeFormat(pattern="yyyy/MM/dd HH:mm:ss")
>
> 则传入的参数应该是这样的：
>
> 2018/08/02 22:05:55
>
> 否则会抛出异常。

**@JsonFormat**

 1.使用maven引入@JsonFormat所需要的jar包，我贴一下我这里的pom文件的依赖

```xml
<!--JsonFormat-->
  
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-annotations</artifactId>
            <version>2.8.8</version>
        </dependency>
  
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.8.8</version>
        </dependency>
  
        <dependency>
            <groupId>org.codehaus.jackson</groupId>
            <artifactId>jackson-mapper-asl</artifactId>
            <version>1.9.13</version>
        </dependency>
```

2.在你需要查询出来的时间的数据库字段对应的实体类的属性上添加@JsonFormat

```java
import java.util.Date;
  
import com.fasterxml.jackson.annotation.JsonFormat;
  
public class TestClass {
  
    //设置时区为上海时区，时间格式自己据需求定。
    @JsonFormat(pattern="yyyy-MM-dd",timezone = "GMT+8")
    private Date testTime;
  
     
    public Date gettestTime() {
        return testTime;
    }
  
    public void settestTime(Date testTimee) {
        this.testTime= testTime;
    }
}
```

> 这里解释一下：@JsonFormat(pattern="yyyy-MM-dd",timezone = "GMT+8")
>
>   pattern:是你需要转换的时间日期的格式
>
>   timezone：是时间设置为东八区，避免时间在转换中有误差
>
>  提示：@JsonFormat注解可以在属性的上方，同样可以在属性对应的get方法上，两种方式没有区别
>
> 3.完成上面两步之后，我们用对应的实体类来接收数据库查询出来的结果时就完成了时间格式的转换，再返回给前端时就是一个符合我们设置的时间格式了
>
> 注解@JsonFormat主要是后台到前台的时间格式的转换
>
> 注解@DataFormat主要是前后到后台的时间格式的转换





### 二、反射获取字段

https://wanghuohuo.blog.csdn.net/article/details/103236778?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.control



https://blog.csdn.net/wency935486/article/details/79289741?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control

```java
//通过EntityManager获取factory
EntityManagerFactory entityManagerFactory = (你自己的entityManager对象).getEntityManagerFactory();
SessionFactoryImpl sessionFactory = (SessionFactoryImpl)entityManagerFactory.unwrap(SessionFactory.class);
Map<String, EntityPersister> persisterMap = sessionFactory.getEntityPersisters();
//Map<String, EntityPersister> persisterMap = sessionFactory.getMetamodel().entityPersisters();
for(Map.Entry<String,EntityPersister> entity : persisterMap.entrySet()){
    Class targetClass = entity.getValue().getMappedClass();
    SingleTableEntityPersister persister = (SingleTableEntityPersister)entity.getValue();
    Iterable<AttributeDefinition> attributes = persister.getAttributes();
    String entityName = targetClass.getSimpleName();//Entity的名称
    String tableName = persister.getTableName();//Entity对应的表的英文名
 
    System.out.println("类名：" + entityName + " => 表名：" + tableName);
 
    //属性
    for(AttributeDefinition attr : attributes){
        String propertyName = attr.getName(); //在entity中的属性名称
        String[] columnName = persister.getPropertyColumnNames(propertyName); //对应数据库表中的字段名
        String type = "";
        PropertyDescriptor targetPd = BeanUtils.getPropertyDescriptor(targetClass, propertyName);
        if(targetPd != null){
            type = targetPd.getPropertyType().getSimpleName();
        }
        System.out.println("属性名：" + propertyName + " => 类型：" + type + " => 数据库字段名：" + columnName[0]);
    }
 
}
```

```java
import javax.persistence.Column;
import javax.persistence.Id;
import javax.persistence.Table;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
 
/**
 * @author caizw
 * @createDate 2018/2/8
 * @description 反射工具类
 */
public class ReflectUtils {
 
    /**
     * 获取实体类主键
     *
     * @param clazz
     * @return
     */
    public static Field getIdField(Class<?> clazz) {
        Field[] fields = clazz.getDeclaredFields();
        Field item = null;
        for (Field field : fields) {
            Id id = field.getAnnotation(Id.class);
            if (id != null) {
                field.setAccessible(true);
                item = field;
                break;
            }
        }
        if (item == null) {
            Class<?> superclass = clazz.getSuperclass();
            if (superclass != null) {
                item = getIdField(superclass);
            }
        }
        return item;
    }
 
    /**
     * 根据主键名称获取实体类主键属性值
     *
     * @param clazz
     * @param pkName
     * @return
     */
    public static Object getPkValueByName(Object clazz, String pkName) {
        try {
            String firstLetter = pkName.substring(0, 1).toUpperCase();
            String getter = "get" + firstLetter + pkName.substring(1);
            Method method = clazz.getClass().getMethod(getter, new Class[]{});
            Object value = method.invoke(clazz, new Object[]{});
            return value;
        } catch (Exception e) {
            return null;
        }
    }
 
    /**
     * 通过反射将 class1不为空的值赋值给class2
     *
     * @param class1
     * @param class2
     * @throws Exception
     */
    public static void reflectClass1ToClass2(Object class1, Object class2) throws Exception {
        Field[] field = class1.getClass().getDeclaredFields();
        for (int i = 0; i < field.length; i++) {
            String name = field[i].getName();
            if ("serialVersionUID".equals(name)) {
                continue;
            }
            name = name.substring(0, 1).toUpperCase() + name.substring(1);
            Method m1 = class1.getClass().getMethod("get" + name);
            Object value = m1.invoke(class1);
            if (value != null) {
                Field f = field[i];
                f.setAccessible(true);
                f.set(class2, value);
            }
        }
    }
 
    /**
     * 获取实体类 @Column 的其中一个属性名称
     *
     * @param clazz
     * @return
     */
    public static Map<String, String> getColumnName(Class<?> clazz) {
        Map<String, String> map = new ConcurrentHashMap<>();
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            if (field.isAnnotationPresent(Column.class)) {
                /**
                 * 获取字段名
                 */
                Column declaredAnnotation = field.getDeclaredAnnotation(Column.class);
                String column = declaredAnnotation.name();
                map.put("fieldNames", field.getName());
                map.put("column", column);
                break;
            }
        }
        return map;
    }
 
    /**
     * 通过获取类上的@Table注解获取表名称
     *
     * @param clazz
     * @return
     */
    public static Map<String, String> getTableName(Class<?> clazz) {
        Map<String, String> map = new ConcurrentHashMap<>();
        Table annotation = clazz.getAnnotation(Table.class);
        String name = annotation.name();
        String className = clazz.getSimpleName();
        map.put("tableName", name);
        map.put("className", className);
        return map;
    }
}
```

https://blog.csdn.net/fangjuanyuyue/article/details/94721371?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control

```java
List<String[]> list = new ArrayList<>();
        ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);
        scanner.addIncludeFilter(new AnnotationTypeFilter(Table.class));
        for (BeanDefinition bd : scanner.findCandidateComponents("com.test.domain.*")) {
            Class<?> clazz = Class.forName(bd.getBeanClassName());
            Table myClassAnnotation = clazz.getAnnotation(Table.class);
            String tableNm = myClassAnnotation.name().toUpperCase();

            // 获得字段注解
            Field fields[] = clazz.getDeclaredFields();
            for (Field field : fields) {
            	// 获取普通属性的@Column注解
                Column myFieldAnnotation = field.getAnnotation(Column.class);
                if (myFieldAnnotation != null) {
                    String fieldNm = myFieldAnnotation.name().toUpperCase();
                    String[] obj = { tableNm, fieldNm };
                    list.add(obj);
                }
				// 获取联合主键的字段列名
                EmbeddedId embeddedAnno = field.getAnnotation(EmbeddedId.class);
                if(embeddedAnno != null) {
                    Class subClazz = field.getType();
                    Field subFileds[] = subClazz.getDeclaredFields();
                    for (Field subFiled : subFileds) {
                        Column myFieldSub = subFiled.getAnnotation(Column.class);
                        if (myFieldSub != null) {
                            String fieldNm = myFieldSub.name().toUpperCase();
                            String[] obj = {tableNm, fieldNm};
                            list.add(obj);
                        }
                    }
                }
            }
            // 获取方法上的@Column 注解
            Method methods[] = clazz.getMethods();
            for(Method method: methods) {
                Column methodAnno = method.getAnnotation(Column.class);
                if(methodAnno != null) {
                    String fieldNm = methodAnno.name().toUpperCase();
                    String[] obj = { tableNm, fieldNm };
                    list.add(obj);
                }
            }
        }


```

### 三、实现MYSQL批量插入

1、使用JdbcTemplate的方法构造SQL语句，实现批量插入。

```
 
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils;
import org.springframework.stereotype.Service;
 
import java.util.List;
 
/**
 * @author Marion
 * @date 2020/8/13
 */
@Service
public class JdbcService {
 
    @Autowired
    private NamedParameterJdbcTemplate namedParameterJdbcTemplate;
 
    public <T> void saveMsgItemList(List<T> list) {
        // 这里注意VALUES要用实体的变量，而不是字段的Column值
        String sql = "INSERT INTO t_msg_item(groupid, sender_uid) " +
                "VALUES (:groupId, :senderUid)";
        updateBatchCore(sql, list);
    }
 
    /**
     * 一定要在jdbc url 加&rewriteBatchedStatements=true才能生效
     * @param sql  自定义sql语句，类似于 "INSERT INTO chen_user(name,age) VALUES (:name,:age)"
     * @param list
     * @param <T>
     */
    public <T> void updateBatchCore(String sql, List<T> list) {
        SqlParameterSource[] beanSources = SqlParameterSourceUtils.createBatch(list.toArray());
        namedParameterJdbcTemplate.batchUpdate(sql, beanSources);
    }
 
}
```

.2、将插入的数据切割成100一条一次，推荐不超过1000条数据，循环插入。

```java
    @Autowired
    private JdbcService jdbcService;
 
    private void multiInsertMsgItem(List<Long> uids, String content, boolean hide) {
        int size = uids.size();
        List<MsgItemEntity> data = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            MsgItemEntity mIE = MsgItemEntity.buildMsgItem(MessageGroupType.SYSTEM.getValue(), content, MessageType.TEXT, uids.get(i), hide);
            data.add(mIE);
            if (i % 100 == 0) {
                jdbcService.saveMsgItemList(data);
                data.clear();
            }
        }
        if (data.size() > 0) {
            jdbcService.saveMsgItemList(data);
        }
    }
```

3、jdbc批量插入

```java
/**
	 * 批量插入
	 * 
	 * @param tableName
	 * @param datas
	 * @return
	 */
	public boolean insertBatch(String tableName, List<Map<String, Object>> datas) {
		PreparedStatement prepared = null;
		Connection connect = new Mysql().getConnection();
		try {
			connect.setAutoCommit(false); // 设置手动提交
			StringBuffer fieldString = new StringBuffer();
			StringBuffer paraNo = new StringBuffer(); // 预处理字段“？”
			List<Object> values = new ArrayList<Object>();
			boolean flag = true;
			for (int i = 0; i < datas.size(); i++) {
				for (Object element : datas.get(i).keySet()) {
					if (flag) {
						fieldString.append("," + element);
						paraNo.append(",?");
					}
					values.add(datas.get(i).get(element));
				}
				flag = false;

				if (prepared == null) {
					// 所有参数组成的数组
					String queryString = "INSERT INTO " + tableName + " (" + fieldString.toString().substring(1)
							+ ") VALUES (" + paraNo.substring(1) + ")";
					prepared = connect.prepareStatement(queryString);
				}
				// 设置对应参数值
				for (int j = 0; j < datas.get(i).size(); j++) {
					prepared.setObject(j + 1, values.get(j));
				}
				prepared.addBatch();
				if (i % 10000 == 0) {
					prepared.executeBatch();
					connect.commit();
				}
				values.clear();
			}
			prepared.executeBatch();
			connect.commit();
			return true;
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e.getMessage());
		} finally {
			try {
				if (connect != null) {
					connect.close();
				}
				if (prepared != null) {
					prepared.close();
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}
import java.io.IOException;
import java.io.InputStream;
import java.sql.*;
import java.util.Properties;


/**
 * 单数据库模式 单数据库模式 需要扩展多数据库或使用主从数据库 在此处进行扩展指定连接数据库 同时修改数据库配置
 * 
 */
public class Mysql {
	// 连接数据库的参数
	private static String url = null;
	private static String username = null;
	private static String driver = null;
	private static String passwd = null;

	private static Properties propertie = null;
	private static InputStream configStream = null;
	/**
	 * 加载驱动，只需要一次，用静态代码块 单数据库模式，需要扩展多数据库或使用主从数据库在此处进行扩展
	 */
	static {
		try {
			propertie = new Properties();
			configStream = Mysql.class.getClassLoader().getResourceAsStream("mysql.properties");
			propertie.load(configStream);

			url = propertie.getProperty("url");
			driver = propertie.getProperty("driver");
			username = propertie.getProperty("username");
			passwd = propertie.getProperty("password");

			Class.forName(driver);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			try {
				configStream.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
			configStream = null;
		}

	}

	/**
	 * 获取数据库链接
	 * 
	 * @return
	 */
	public Connection getConnection() {
		Connection con = null;
		try {
			con = DriverManager.getConnection(url, username, passwd);
		} catch (Exception e) {
			e.printStackTrace();
		}

		return con;
	}
}

//调用方法

List<Map<String, Object>> datas = new ArrayList<>();
Map<String,Object> user = new HashMap<>();
user.put(字段,对应值);
datas.add(user);
insertBatch(表名, datas);

```

### 四、查询

#### 1、**JpaSpecificationExecutor**

```java
findOne(Specification<T> spec);  
List<T> findAll(Specification<T> spec);
Page<T> findAll(Specification<T> spec, Pageable pageable);
List<T> findAll(Specification<T> spec, Sort sort);
long count(Specification<T> spec);
```

![image-20210322113734557](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210322113737.png)

##### **（1）Specification** 

![image-20210322113907279](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210322113907.png)

###### 1.1 查询单个对象

![image-20210322114040933](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210322114041.png)



###### 1.2多条件查询

案例：根据客户名（传智播客）和客户所属行业查询（it教育）

```java
    @Test
    public void testSpec1() {
        /**
         *  root:获取属性
         *      客户名
         *      所属行业
         *  cb：构造查询
         *      1.构造客户名的精准匹配查询
         *      2.构造所属行业的精准匹配查询
         *      3.将以上两个查询联系起来
         */
        Specification<Customer> spec = new Specification<Customer>() {
            @Override
            public Predicate toPredicate(Root<Customer> root, CriteriaQuery<?> query, CriteriaBuilder cb) {
                Path<Object> custName = root.get("custName");//客户名
                Path<Object> custIndustry = root.get("custIndustry");//所属行业

                //构造查询
                //1.构造客户名的精准匹配查询
                Predicate p1 = cb.equal(custName, "传智播客");//第一个参数，path（属性），第二个参数，属性的取值
                //2..构造所属行业的精准匹配查询
                Predicate p2 = cb.equal(custIndustry, "it教育");
                //3.将多个查询条件组合到一起：组合（满足条件一并且满足条件二：与关系，满足条件一或满足条件二即可：或关系）
                Predicate and = cb.and(p1, p2);//以与的形式拼接多个查询条件
                // cb.or();//以或的形式拼接多个查询条件
                return and;
            }
        };
        Customer customer = customerDao.findOne(spec);
        System.out.println(customer);
    }
```

###### 1.3查询全部（加入排序）

```java
    @Test
    public void testSpec3() {
        Specification<Customer> spec = new Specification<Customer>() {
            @Override
            public Predicate toPredicate(Root<Customer> root, CriteriaQuery<?> query, CriteriaBuilder cb) {
                Path<Object> custName = root.get("custName");
                Predicate like = cb.like(custName.as(String.class), "传智播客%");
                return like;
            }
        };
        //添加排序
        //创建排序对象,需要调用构造方法实例化sort对象
        //第一个参数：排序的顺序（倒序，正序）
        //   Sort.Direction.DESC:倒序
        //   Sort.Direction.ASC ： 升序
        //第二个参数：排序的属性名称
        Sort sort = new Sort(Sort.Direction.DESC,"custId");
        List<Customer> list = customerDao.findAll(spec, sort);
        for (Customer customer : list) {
            System.out.println(customer);
        }
    }
```

###### 1.4查询全部（加入分页）

```java
    /**
     * 分页查询
     *      Specification: 查询条件
     *      Pageable：分页参数
     *          分页参数：查询的页码，每页查询的条数
     *          findAll(Specification,Pageable)：带有条件的分页
     *          findAll(Pageable)：没有条件的分页
     *  返回：Page（springDataJpa为我们封装好的pageBean对象，数据列表，共条数）
     */
    @Test
    public void testSpec4() {

        Specification spec = null;
        //PageRequest对象是Pageable接口的实现类
        /**
         * 创建PageRequest的过程中，需要调用他的构造方法传入两个参数
         *      第一个参数：当前查询的页数（从0开始）
         *      第二个参数：每页查询的数量
         */
        Pageable pageable = new PageRequest(0,2);
        //分页查询
        Page<Customer> page = customerDao.findAll(null, pageable);
        System.out.println(page.getContent()); //得到数据集合列表
        System.out.println(page.getTotalElements());//得到总条数
        System.out.println(page.getTotalPages());//得到总页数
    }
```

###### 1.5 、具体案例

```java
public class TaskProjectSpecs {
    public static Specification<Task> where(Map params, String userId, List<String> taskIds) {
        //lambda表达式
        return (Root<Task> root, CriteriaQuery<?> query, CriteriaBuilder criteriaBuilder) -> {
            //开始
            Predicate finalConditions = criteriaBuilder.conjunction();
            
            //提取参数
            String taskFast = MapUtils.getString(params, "taskFast");

            //lile 和join 用法 join可跟,JoinType.LEFT等
            if (StringUtils.isNotBlank(taskFast)) {
                Predicate taskFastPre = criteriaBuilder.like(root.join("taskType",JoinType.LEFT).<String>get("id"), "%" + taskFast + "%");
                finalConditions = criteriaBuilder.and(finalConditions, taskFastPre);
            }
            //between用法
            if ((null != createBegin) && (null != createEnd)) {
                Predicate datePredicate = null;
                if (createBegin.after(createEnd)) {
                    datePredicate = criteriaBuilder.between(root.get("gmtCreate"), createEnd, createBegin);
                } else {
                    datePredicate = criteriaBuilder.between(root.get("gmtCreate"), createBegin, createEnd);
                }
                finalConditions = criteriaBuilder.and(finalConditions, datePredicate);
            }
            //equale
            if (null != emergency && 0 != emergency) {
                finalConditions = criteriaBuilder.and(finalConditions, criteriaBuilder.equal(root.get("emergencyLevel"), emergency));
            }
            //大于 不等于
            if (status != null) {
                finalConditions = criteriaBuilder.and(finalConditions, criteriaBuilder.greaterThan(root.get("startDate"), new Date()));
                finalConditions = criteriaBuilder.and(finalConditions, criteriaBuilder.notEqual(root.get("status"), 1));
                
            }
            // or 
            if (StringUtils.isNotBlank(keyword)) {
                finalConditions = criteriaBuilder.and(finalConditions, criteriaBuilder.or(
                        criteriaBuilder.like(root.get("taskName"), "%" + keyword + "%"),
                        criteriaBuilder.like(root.join("project").get("name"), "%" + keyword + "%"))
                );
            }
            //in
            if (taskIds.size() > 0) {
                CriteriaBuilder.In<Object> in = criteriaBuilder.in(root.get("id"));
                for (String id : taskIds) {
                    in.value(id);
                }
                finalConditions = criteriaBuilder.and(finalConditions, in);
            }
            return query.where(finalConditions).getRestriction();
        };
    }
}


```

```java
import com.wmx.entity.TV;
import com.wmx.repository.TVRepository;
import com.wmx.service.TVService;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import javax.annotation.Resource;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
@Service
public class TVServiceImpl implements TVService {
    @Resource
    private TVRepository tvRepository;
 
    @Override
    public List<TV> findAll(Date start, Date end, String tvName) {
        //直接使用匿名内部类实现接口
        Specification specification = new Specification<TV>() {
            @Override
            public Predicate toPredicate(Root<TV> root, CriteriaQuery<?> query, CriteriaBuilder cb) {
                List<Predicate> predicateList = new ArrayList<>();
                //条件1：查询 tvName 为 海信 的数据，root.get 中的值与 TV 实体中的属性名称对应
                if (tvName != null && !"".equals(tvName)) {
                    predicateList.add(cb.equal(root.get("tvName").as(String.class), tvName));
                }
 
                //条件2：TV 生产日期（dateOfProduction）大于等于 start 的数据，root.get 中的 dateOfProduction 必须对应 TV 中的属性
                predicateList.add(cb.greaterThanOrEqualTo(root.get("dateOfProduction").as(Date.class), start));
 
                //条件3：TV 生产日期（dateOfProduction）小于等于 end
                predicateList.add(cb.lessThanOrEqualTo(root.get("dateOfProduction").as(Date.class), end));
 
                Predicate[] pre = new Predicate[predicateList.size()];
                pre = predicateList.toArray(pre);
                return query.where(pre).getRestriction();
            }
        };
        return tvRepository.findAll(specification);//没有数据时，返回空列表
    }
 
    @Override
    public Page<TV> findAll(Date start, int page, int size) {
        page--;
        page = page < 0 ? 0 : page;//page 为页码，数据库从0页开始
        //可以使用重载的 of(int page, int size, Sort sort) 方法指定排序字段
        Pageable pageable = PageRequest.of(page, size);
        //创建查询规范
        Specification<TV> tvSpecification = new Specification<TV>() {
            @Override
            public Predicate toPredicate(Root<TV> root, CriteriaQuery<?> query, CriteriaBuilder cb) {
                List<Predicate> predicateList = new ArrayList<>();
                //查询生产日期在 start 与当期时间之间的数据，闭区间
                predicateList.add(cb.between(root.get("dateOfProduction").as(Date.class), start, new Date()));
                
                return query.where(predicateList.toArray(new Predicate[0]).getRestriction();
            }
        };
        return tvRepository.findAll(tvSpecification, pageable);//无数据时返回空列表
    }
 
    @Override
    public List<TV> findAllLike(String tvNameLike) {
        Specification<TV> tvSpecification = new Specification<TV>() {
            @Override
            public Predicate toPredicate(Root<TV> root, CriteriaQuery<?> query, CriteriaBuilder cb) {
                Predicate[] predicates = new Predicate[1];
                //like(Expression<String> x, String pattern):参数 pattern 表示匹配的格式
                predicates[0] = cb.like(root.get("tvName").as(String.class), "%" + tvNameLike + "%");
                //同理以 xxx 开头，则为 tvNameLike + "%"
                return query.where(predicates).getRestriction();
            }
        };
        //规范查询的同时，指定以主键 tvId 倒序排序
        return tvRepository.findAll(tvSpecification, Sort.by(Sort.Direction.DESC, "tvId"));
    }
}
```





#### 2、JPQL查询

> JPQL语言( Java Persistence Query Language )是一种和SQL非常类似的中间件和对象化查询语言，它最终会被编译成针对不同底层数据库的SQL语言，从而屏蔽不同数据库的差异。
>
> JPQL语言通过Query接口封装执行，Query接口封装了执行数据库查询的相关方法。调用EntityManager的Query、NamedQuery、NativeQuery方法可以获得查询对象，进而可调用Query接口的方法来执行查询操作。
>
> JPQL是面向对象进行查询的语言。可以通过自定义的JPQL完成UPDATE和DELETE操作。JPQL不支持使用INSERT。对于UPDATE和DELETE操作，必须使用注解@Modifying进行修饰

![image-20210324174848696](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210324174848.png)

- 查询一个表中的一些字段

```mysql
方法一：这段代码返回的是一个Object类型
@Query(value = "select b.title, b.state,b.remark,b.publisherTime,b.publisherId from BizNotice b where b.lineId = ?1 AND b.bidspartId = ?2 AND b.areaId = ?3")
	public List<BizNotice> noticeList(String lineId, String bidspartId, String areaId);

方法二：这段代码返回的是一个对象形式
@Query(value = "select new BizNotice(b.title,b.id,b.content,b.publisherId,b.state)  from BizNotice b where b.lineId = ?1 AND b.bidspartId = ?2 AND b.areaId = ?3")
	public List<BizNotice> noticeList(String lineId, String bidSpartId, String areaId);

```

#### 3、原生的SQL查询

> 在使用原生SQL查询时，也使用注解@Query。此时，nativeQuery参数需要设置为true。



![image-20210324175123539](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210324175123.png)

可以看到，@Query与@Modifying这两个注解一起声明，可以定义个性化更新操作

#### 4、ExampleMatcher查询

Spring Data 可以通过Example对象来构造JPQL查询。代码如下：

![image-20210324175320952](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210324175321.png)

#### 5、@Valid 注解类型的使用

@Null

限制只能为null

@NotNull

限制必须不为null

@AssertFalse

限制必须为false

@AssertTrue

限制必须为true

@DecimalMax(value)

限制必须为一个不大于指定值的数字

@DecimalMin(value)

限制必须为一个不小于指定值的数字

@Digits(integer,fraction)

限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction

@Future

限制必须是一个将来的日期

@Max(value)

限制必须为一个不大于指定值的数字

@Min(value)

限制必须为一个不小于指定值的数字

@Past

限制必须是一个过去的日期

@Pattern(value)

限制必须符合指定的正则表达式

@Size(max,min)

限制字符长度必须在min到max之间

@Past

验证注解的元素值（日期类型）比当前时间早

@NotEmpty

验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0）

@NotBlank

验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格

@Email

验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式

**注意，不要错用了异常类型，比如在int上不可用@size**

###### 5.1 嵌套校验

> 一个待验证的pojo类，其中还包含了待验证的对象，需要在待验证对象上注解@Valid，才能验证待验证对象中的成员属性，这里不能使用@Validated。

需要约束校验的bean：

```java
public class TeacherBean {
    @NotEmpty(message = "老师姓名不能为空")
    private String teacherName;
    @Min(value = 1, message = "学科类型从1开始计算")
    private int type;
```

```java
public class StudentBean implements Serializable{
    @NotBlank(message = "用户名不能为空")
    private String name;
    @Min(value = 18, message = "年龄不能小于18岁")
    private Integer age;
    @Pattern(regexp = "^((13[0-9])|(14[5,7,9])|(15([0-3]|[5-9]))|(166)|(17[0,1,3,5,6,7,8])|(18[0-9])|(19[8|9]))\\d{8}$", message = "手机号格式错误")
    private String phoneNum;
    @Email(message = "邮箱格式错误")
    private String email;
    @MyConstraint
    private String className;
 
    @NotNull(message = "任课老师不能为空")
    @Size(min = 1, message = "至少有一个老师")
    private List<TeacherBean> teacherBeans;
```

注意：

这里对teacherBeans只校验了NotNull, 和 Size，并没有对teacher信息里面的字段进行校验，具体测试如下： 

![img](https://img-blog.csdnimg.cn/20190107202208141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlcm9qdWljZQ==,size_16,color_FFFFFF,t_70)



这里teacher中的type明显是不符合约束要求的，但是能检测通过，是因为在student中并没有做 嵌套校验

可以在teacherBeans中加上 @Valid，具体如下：

![img](https://img-blog.csdnimg.cn/2019010720264066.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlcm9qdWljZQ==,size_16,color_FFFFFF,t_70)



![img](https://img-blog.csdnimg.cn/2019010720264066.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlcm9qdWljZQ==,size_16,color_FFFFFF,t_70)





@Valid是使用Hibernate validation的时候使用

@Validated是只用Spring Validator校验机制使用

说明：java的JSR303声明了@Valid这类接口，而Hibernate-validator对其进行了实现

@Validation对@Valid进行了二次封装，在使用上并没有区别，但在分组、注解位置、嵌套验证等功能上有所不同，这里主要就这几种情况进行说明。

注解位置：
@Validated：用在类型、方法和方法参数上。但不能用于成员属性（field）

@Valid：可以用在方法、构造函数、方法参数和成员属性（field）上

如： 

 ![img](https://img-blog.csdnimg.cn/20190107200509415.png)

如果@Validated注解在成员属性上，则会报  不适用于field错误


总结一下@Validated和@Valid在嵌套验证功能上的区别：

@Validated：用在方法入参上无法单独提供嵌套验证功能。不能用在成员属性（字段）上，也无法提示框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。

@Valid：用在方法入参上无法单独提供嵌套验证功能。能够用在成员属性（字段）上，提示验证框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。



######  5.2 service层方法校验

@Validated,@NotNull,@Valid

![image-20201010172210168](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201010172210.png)

> 可以发现,@NotNull加到接口,@Validated加到实现或者接口都可以
>
> 那么,@Validated加到哪里比较好呢?
>
> 放到实现上的原因:
>
> (1).更灵活,如果一个接口多个实现的话,需要校验的实现可以对其进行校验,不需要校验的就不用校验参数
>
> (2).避免坑,如果实现和接口是在不同的maven项目下,接口就可以不用引用hibernate-validator这个包,避免包冲突的坑
>
> (3).更符合规范,接口是定义方法的规范,@Validated是实现校验,应该放到实现中
>
> 综上,@Validated放到实现上,@NotNull,@Valid等声明放到接口上



#### 6、NamedParameterJdbcTemplate

NamedParameterJdbcTemplate类拓展了JdbcTemplate类，对JdbcTemplate类进行了封装从而支持命名参数特性。
NamedParameterJdbcTemplate主要提供以下三类方法：execute方法、query及queryForXXX方法、update及batchUpdate方法。

数据库结构

![这里写图片描述](https://img-blog.csdn.net/20170708123802956?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTE3OTk5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

##### 6.1. 支持类

###### SqlParameterSource 简介

> 可以使用SqlParameterSource实现作为来实现为命名参数设值，默认实现有 ：
>
> MapSqlParameterSource实现非常简单，只是封装了java.util.Map；
>
> BeanPropertySqlParameterSource封装了一个JavaBean对象，通过JavaBean对象属性来决定命名参数的值。
>
> EmptySqlParameterSource 一个空的SqlParameterSource ，常用来占位使用

###### RowMapper简介

> 这个接口为了实现sql查询结果和对象间的转换，可以自己实现，也可以使用系统实现，主要实现类有：
>
> SingleColumnRowMapper ，sql结果为一个单列的数据，如List<String> , List<Integer>,String,Integer等
>
> BeanPropertyRowMapper， sql结果匹配到对象 List< XxxVO> , XxxVO

##### 6.2. 插入/修改/删除数据

######  使用Map作为参数

```java
API: int update(String sql, Map<String, ?> paramMap)
```

```java
示例：

Map<String, Object> paramMap = new HashMap<>();
paramMap.put("id", UUID.randomUUID().toString());
paramMap.put("name", "小明");
paramMap.put("age", 33);
paramMap.put("homeAddress", "乐山");
paramMap.put("birthday", new Date());
template.update( 
     "insert into student(id,name,age,home_address,birthday) values (:id,:name,:age,:homeAddress,:birthday)",
     paramMap
);
```

###### BeanPropertySqlParameterSource

```java
API: int update(String sql, SqlParameterSource paramSource)
```

```java
public class StudentDTO{
    private String id;
    private String name;
    private String homeAddress;

     //getter,setter

}

StudentDTO dto=new StudentDTO();//这个DTO为传入数据
dto.setId(UUID.randomUUID().toString());
dto.setName("小红");
dto.setHomeAddress("成都");
//------------------------------
template.update("insert into student(id,name,home_address) values (:id,:name,:homeAddress)",
                new BeanPropertySqlParameterSource(dto));
```



###### MapSqlParameterSource 

```java
API: int update(String sql, SqlParameterSource paramSource)
```

```java
//使用 MapSqlParameterSource 作为参数

MapSqlParameterSource mapSqlParameterSource = new MapSqlParameterSource()
        .addValue("id", UUID.randomUUID().toString())
        .addValue("name", "小王")
        .addValue("homeAddress", "美国");
template.update("insert into student(id,name,home_address) values    
                   (:id,:name,:homeAddress)",mapSqlParameterSource);

或者

Map<String, Object> paramMap = new HashMap<>();
paramMap.put("id", UUID.randomUUID().toString());
paramMap.put("name", "小明");
paramMap.put("homeAddress", "乐山");
//---------------
MapSqlParameterSource mapSqlParameterSource = new MapSqlParameterSource(paramMap);
```



##### 6.3. 查询

###### 6.3.1 返回单行单列数据

```java
API: public < T > T queryForObject(String sql, Map<String, ?> paramMap, Class<T> requiredType)

API: public < T > T queryForObject(String sql, SqlParameterSource paramSource, Class<T> requiredType)
```

```java
示例(注意EmptySqlParameterSource的使用)：

Integer count = template.queryForObject(
                "select count(*) from student", new HashMap<>(), Integer.class);

String name = template.queryForObject( "select name from student where home_address  limit 1 ", EmptySqlParameterSource.INSTANCE, String.class); 
```

###### 6.3.2 返回 (多行)单列 数据

```java
API: public < T> List< T> queryForList(String sql, Map<String, ?> paramMap, Class< T > elementType)

API: public < T> List< T> queryForList(String sql, SqlParameterSource paramSource, Class< T> elementType)
```

```java
示例：

List< String> namelist = template.queryForList("select name from student", new HashMap<>(), String.class);
1
返回单行数据
API: public < T> T queryForObject(String sql, Map< String, ?> paramMap, RowMapper< T>rowMapper)

API: public < T> T queryForObject(String sql, SqlParameterSource paramSource, RowMapper< T> rowMapper)
示例：

Student  stu = template.queryForObject(
                "select * from student limit 1", new HashMap<>(), new BeanPropertyRowMapper<Student>(Student.class));
//BeanPropertyRowMapper会把下划线转化为驼峰属性
//结果对象可比实际返回字段多或者少
```


注意：这两个API也可以使用SingleColumnRowMapper返回单行单列数据

```java
String name = template.queryForObject(
                "select name from student limit 1", EmptySqlParameterSource.INSTANCE, new SingleColumnRowMapper<>(String.class));
```

###### 6.3.3 返回Map形式的单行数据

```java
API: public Map< String, Object> queryForMap(String sql, Map< String, ?> paramMap)

API: public Map< String, Object> queryForMap(String sql, SqlParameterSource paramSource)
```

```java
示例：

 Map< String, Object> studentMap = template.queryForMap("select * from student limit 1", new HashMap<>());
```

###### 6.3.4 返回多行数据

```java
API: public < T> List< T> query(String sql, Map< String, ?> paramMap, RowMapper< T> rowMapper)
API: public < T> List< T> query(String sql, SqlParameterSource paramSource, RowMapper< T> rowMapper)
API: public < T> List< T> query(String sql, RowMapper< T> rowMapper)
```

示例：

```java
List< Student> studentList = template.query(
                "select * from student",  
                new BeanPropertyRowMapper<>(Student.class)
);    
```


同理，也可以使用SingleColumnRowMapper返回单行列表List< String>,List< Integer>等

###### 6.3.4  返回多行数据(Map)

```java
API: public List< Map< String, Object>> queryForList(String sql, Map< String, ?> paramMap)
API: public List< Map< String, Object>> queryForList(String sql, SqlParameterSource paramSource)
```

```java
示例：

List<Map<String, Object>> mapList = template.queryForList(
                "select * from student", new HashMap<>());
```

> 总结
> 开发中尽量使用NamedParameterJdbcTemplate代替JdbcTemplate，如果想使用JdbcTemplate，也可以通过NamedParameterJdbcTemplate#getJdbcOperations()获取
> 不建议使用查询结构为Map的API

### 五、多数据源配置

```java
package com.nd.auxo.tools.application.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import javax.sql.DataSource;

/**
 * @author llb
 * @date 2018/6/21 0021
 */
@Configuration
public class DataSourceConfig {

    @Bean(name = "primaryDataSource")
    @Qualifier("primaryDataSource")
    @Primary
    @ConfigurationProperties(prefix="spring.datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean(name = "secondaryDataSource")
    @Qualifier("secondaryDataSource")
    @ConfigurationProperties(prefix="spring.datasource.secondary")
    public DataSource secondaryDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean(name = "primaryNamedParameterJdbcTemplate")
    @Primary
    public NamedParameterJdbcTemplate primaryNamedParameterJdbcTemplate(
            @Qualifier("primaryDataSource") DataSource dataSource) {
        return new NamedParameterJdbcTemplate(dataSource);
    }

    @Bean(name = "secondaryNamedParameterJdbcTemplate")
    public NamedParameterJdbcTemplate secondaryNamedParameterJdbcTemplate(
            @Qualifier("secondaryDataSource") DataSource dataSource) {
        return new NamedParameterJdbcTemplate(dataSource);
    }
}

```

```java
package com.nd.auxo.tools.application.config;

import com.nd.gaea.repository.ms.GaeaRepositoryFactoryBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;
import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.persistence.EntityManager;
import javax.sql.DataSource;
import java.util.Map;

@Configuration
@EnableJpaRepositories(repositoryFactoryBeanClass = GaeaRepositoryFactoryBean.class,
        entityManagerFactoryRef="entityManagerFactoryPrimary",
        transactionManagerRef="transactionManagerPrimary",
        basePackages = {"com.nd.auxo.tools.core.repository.jpa"})
@EnableTransactionManagement
@EntityScan("com.nd.auxo.tools.core.repository.jpa")
public class JpaConfig {

    @Autowired
    @Qualifier("primaryDataSource")
    private DataSource primaryDataSource;

    @Primary
    @Bean(name = "entityManagerPrimary")
    public EntityManager entityManager(EntityManagerFactoryBuilder builder) {
        return entityManagerFactoryPrimary(builder).getObject().createEntityManager();
    }

    @Primary
    @Bean(name = "entityManagerFactoryPrimary")
    public LocalContainerEntityManagerFactoryBean entityManagerFactoryPrimary (EntityManagerFactoryBuilder builder) {
        return builder
                .dataSource(primaryDataSource)
                .properties(getVendorProperties(primaryDataSource))
                .packages("com.nd.auxo.tools.core.repository.jpa") //设置实体类所在位置
                .persistenceUnit("primaryPersistenceUnit")
                .build();
    }

    @Autowired
    private JpaProperties jpaProperties;

    private Map<String, String> getVendorProperties(DataSource dataSource) {
        return jpaProperties.getHibernateProperties(dataSource);
    }

    @Primary
    @Bean(name = "transactionManagerPrimary")
    public PlatformTransactionManager transactionManagerPrimary(EntityManagerFactoryBuilder builder) {
        return new JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject());
    }
}

```

```java
package com.nd.auxo.tools.application.config;

import com.nd.gaea.repository.ms.GaeaRepositoryFactoryBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;
import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.persistence.EntityManager;
import javax.sql.DataSource;
import java.util.Map;

@Configuration
@EnableJpaRepositories(repositoryFactoryBeanClass = GaeaRepositoryFactoryBean.class,
        entityManagerFactoryRef="entityManagerFactorySecondary",
        transactionManagerRef="transactionManagerSecondary",
        basePackages = {"com.nd.auxo.tools.pms.repository.jpa"})
@EnableTransactionManagement
@EntityScan("com.nd.auxo.tools.pms.repository.jpa")
public class SecondaryJpaConfig {

    @Autowired
    @Qualifier("secondaryDataSource")
    private DataSource secondaryDataSource;

    @Bean(name = "entityManagerSecondary")
    public EntityManager entityManager(EntityManagerFactoryBuilder builder) {
        return entityManagerFactorySecondary(builder).getObject().createEntityManager();
    }

    @Bean(name = "entityManagerFactorySecondary")
    public LocalContainerEntityManagerFactoryBean entityManagerFactorySecondary (EntityManagerFactoryBuilder builder) {
        return builder
                .dataSource(secondaryDataSource)
                .properties(getVendorProperties(secondaryDataSource))
                .packages("com.nd.auxo.tools.pms.repository.jpa") //设置实体类所在位置
                .persistenceUnit("secondaryPersistenceUnit")
                .build();
    }

    @Autowired
    private JpaProperties jpaProperties;

    private Map<String, String> getVendorProperties(DataSource dataSource) {
        return jpaProperties.getHibernateProperties(dataSource);
    }

    @Bean(name = "transactionManagerSecondary")
    PlatformTransactionManager transactionManagerSecondary(EntityManagerFactoryBuilder builder) {
        return new JpaTransactionManager(entityManagerFactorySecondary(builder).getObject());
    }
}

```







## SpringBoot

### 一、同一接口的实现类注入map和list

https://blog.csdn.net/inrgihc/article/details/104742206

在SpringBoot开发中，当一个接口A有多个实现类时，spring会很智能的将bean注入到List<A>或Map<String,A>变量中。

#### 1、将bean注入List或Map

![image-20210120163101740](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210120163102.png)

![image-20210120163146544](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210120163146.png)

![image-20210120163244847](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210120163244.png)

#### 2、策略模式：根据配置使用对应的实现类

![image-20210120163647573](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210120163647.png)

![image-20210120163707509](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210120163707.png)





### 二、读取配置文件

#### 1、yaml中的不同类型数据的写法

##### 1.1 字符串数字

```yaml
# 报文版本号，固定5.1.0，请勿改动

version: '5.1.0'

# 签名方式，证书方式固定01，请勿改动

signMethod: '01'
```



##### 1.2 单个数组：(以- 开头的，就是代表着数组)

###### 方式一：

```yaml
card-expire-notify:

  templateIds: [95,96,97,98,99,100]
```

###### 方式二：

```yaml
card-expire-notify:

  templateIds:

   - 95

   - 96

   - 97

   - 98

   - 99

   - 100
```

###### 读取方法：

```java
@Configuration

@ConfigurationProperties(prefix = "card-expire-notify")

@Data

public class NotifyConfig {

    private String getActivityCardUrl;

    private String wechatTemplateId;

    private String accessToken;

   ** private List<Long> templateIds;**

}
```

> 注意：yaml中的数组，map，list 只能用对象去接收，不能用@Value直接注入，需要通过配置类去接收

![img](https://upload-images.jianshu.io/upload_images/3840587-1f17799192463b5a.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

##### 1.3 对象数组：

```yaml
umsPay:

  msgSrc: ccccccc

  msgSrcId: 6788

  businessTypes:

    - type: qrCode

      instMid: yuiuiyiuiy

      msgType: bills.getQRCode

      payUrl:

      notifyUrl: ${server.host}ums/v0/api/qr-code/call-back

      returnUrl:

    - type: h5AliPay

      instMid: yiyuiyi

      msgType: trade.h5Pay

      payUrl: ${umsPay.ums-host}netpay-portal/webpay/pay.do

      notifyUrl: ${server.host}ums/v0/api/wap/call-back

      returnUrl: ${server.host}pay/success/

    - type: wxPublic

      instMid: tyfthhfh

      msgType: WXPay.jsPay

      payUrl: ${umsPay.ums-host}netpay-portal/webpay/pay.do

      notifyUrl: ${server.host}ums/v0/api/wap/call-back

      returnUrl: ${server.host}pay/success/
```

###### 读取方法：

```java
@Component

@ConfigurationProperties(prefix = "umsPay")

@Data

public class PayConfig {

    /**

     * 消息来源编号

     */

    private String msgSrcId;

    /**

     * 消息来源

     */

    private String msgSrc;

    /**

     * 终端号

     */

    private String tid;

    /**

     * 加密私钥

     */

    private String privateKey;

    /**

     * 业务类型

     */

   ** private List<BusinessType> businessTypes = new ArrayList<>();**

}
```

#### 2、yaml配置文件的读取方法

##### 2.1 应用配置文件

###### 属性配置文件的位置

> spring会从classpath下的/config目录或者classpath的根目录查找application.properties或application.yml。
>
> /config优先于classpath根目录

##### 2.2 @PropertySource

> 这个注解可以指定具体的属性配置文件，优先级比较低。

##### 2.3 setDefaultProperties



```java
SpringApplication application = new SpringApplication(Application.class);

Map<String, Object> defaultMap = new HashMap<String, Object>();

defaultMap.put("name", "Isea-Blog");

//还可以是Properties对象

application.setDefaultProperties(defaultMap);

application.run(args);
```



```yaml
list: 
  li: 
    - 11
    - 13
```

```java
@Component
@ConfigurationProperties(prefix="list")
public class IgnoreImageIdConfig {
	private List<Integer> li =new ArrayList<Integer>();
 
	public List<Integer> getLi() {
		return li;
	}
 
	public void setLi(List<Integer> li) {
		this.li = li;
	}
 
}
```

> 利用配置Javabean的形式来获得值，值得注意的是，对象里面的引用名字（'li'）,必须和yml文件中的（‘li’）一致，不然就会取不到数据，另外一点是，数组这个对象必须先new出来，如果没有对象的话也会取值失败的，（同理map形式也必须先将map对应的对象new出来）。

#### 3、实践

https://www.freesion.com/article/86871349524/



##### 3.1 创建两个pojo：dog+person

```java
package com.thhh.pojo;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class Dog {
    @Value("旺财")
    private String name;
    @Value("3")
    private Integer age;

    public Dog() {
    }

    public Dog(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
1234567891011121314151617181920212223242526272829303132333435363738394041424344
```

```java
package com.thhh.pojo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Date;
import java.util.List;
import java.util.Map;

@Component
public class Person {
   private String name;
   private Integer age;
   private boolean happy;
   private Date birth;
   private Map<String,Object> map;
   private List<Object> list;
   @Autowired
   private Dog dog;

   public Person() {
   }

   public Person(String name, Integer age, boolean happy, Date birth, Map<String, Object> map, List<Object> list, Dog dog) {
       this.name = name;
       this.age = age;
       this.happy = happy;
       this.birth = birth;
       this.map = map;
       this.list = list;
       this.dog = dog;
   }

   public String getName() {
       return name;
   }

   public void setName(String name) {
       this.name = name;
   }

   public Integer getAge() {
       return age;
   }

   public void setAge(Integer age) {
       this.age = age;
   }

   public boolean isHappy() {
       return happy;
   }

   public void setHappy(boolean happy) {
       this.happy = happy;
   }

   public Date getBirth() {
       return birth;
   }

   public void setBirth(Date birth) {
       this.birth = birth;
   }

   public Map<String, Object> getMap() {
       return map;
   }

   public void setMap(Map<String, Object> map) {
       this.map = map;
   }

   public List<Object> getList() {
       return list;
   }

   public void setList(List<Object> list) {
       this.list = list;
   }

   public Dog getDog() {
       return dog;
   }

   public void setDog(Dog dog) {
       this.dog = dog;
   }

   @Override
   public String toString() {
       return "Person{" +
               "name='" + name + '\'' +
               ", age=" + age +
               ", happy=" + happy +
               ", birth=" + birth +
               ", map=" + map +
               ", list=" + list +
               ", dog=" + dog +
               '}';
   }
}

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103
```

注意：上面我并没有使用偷懒工具lombok，主要还是回忆一下pojo手动怎么写

- 测试是否赋值成功

  ```java
  package com.thhh;
  
  import com.thhh.pojo.Dog;
  import org.junit.jupiter.api.Test;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.boot.test.context.SpringBootTest;
  
  @SpringBootTest
  class Springboot02ConfigApplicationTests {
      @Autowired
      private Dog dog;
      @Test
      void contextLoads() {
          System.out.println(dog);
      }
  
  }
  1234567891011121314151617
  ```

![在这里插入图片描述](https://www.freesion.com/images/637/1052b002c66acd63e621c938ff69591d.png)

------

- 上面的测试中我们使用的是@value给属性赋值，当我们需要修改属性值的时候是需要修改源代码的，为了解决这个问题我们采用yaml对对象属性进行赋值

##### 3.2  详细的复杂配置

- ```yml
  person:
    name: 张三
    age: 18
    happy: true
    birth: 2020/02/02
    map: {k1: v1,k2: v2} #map集合按照一个对象来处理，k为成员属性，v为属性值
    dog:
      name: 旺财
      age: 3
    list:	#list按照数组来处理
      - code
      - music
      - girl
  12345678910111213
  ```

- 在需要注入属性值的类上面添加注解@ConfigurationProperties(prefix = “ymal中对象属性的名称”)

- 但是使用这个注解的时候IDEA会爆红
  ![在这里插入图片描述](https://www.freesion.com/images/664/73f22e99466dbdc8eb9c134c8deb7628.png)
  ![在这里插入图片描述](https://www.freesion.com/images/393/2a825b2ff0e13dac04938813c3a6e8c9.png)

- 测试对象属性是否注入成功

  ```java
  package com.thhh;
  
  import com.thhh.pojo.Dog;
  import com.thhh.pojo.Person;
  import org.junit.jupiter.api.Test;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.boot.test.context.SpringBootTest;
  
  @SpringBootTest
  class Springboot02ConfigApplicationTests {
      @Autowired
      private Person person;
      @Test
      void contextLoads() {
          System.out.println(person);
      }
  }
  1234567891011121314151617
  ```

![在这里插入图片描述](https://www.freesion.com/images/370/4f4c6c20a47926760cc258415ee92812.png)

- **注意**：在ymal中写属性的时候，我故意将属性dog和属性list的顺序进行了颠倒，但是结果还是赋值成功，这说明ymal对象属性的自动注入与编写顺序无关，它是按照属性名称进行的匹配，我们可以将yaml中person对象的属性名称进行修改，使得和pojo中属性名称不一致，最终结果你会发现属性名称不一致的成员属性赋值失败，它的值为其对应数据类型的默认值

  ###### 3.2.1  @ConfigurationProperties作用

> 1. 将配置文件中配置的每一个属性的值，映射到这个组件中;
> 2. 告诉springBoot将本类中的所有属性和配置文件中相关的配置进行绑定
> 3. 参数 prefix = "person”:将配置文件中的person下面的所有属性==——对应==
> 4. 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能

##### 3.3 扩展

1. 在实际开发的时候我们可以选用yaml和properties两种方式，上面我们使用了yaml，使用properties的时候我们需要使用注解@PropertySource(“properties文件路径”)，然后在对应的属性上面使用spring的EL表达式${properties文件中的key}就可以实现属性的赋值；但是这样做步骤就多一些，使用配置文件的好处也仅限于修改属性值的时候不会动源码，来赋值操作都和直接使用@value进行的步骤相同；使用的时候需要设置IDEA配置文件的字符编码
   ![在这里插入图片描述](https://www.freesion.com/images/619/69a653b5f184c841df0a72d68e2e0683.png)

   

   ##### 3.3.2 使用一些spring的EL表达式

   1. 使用表达式作为属性值
   2. 使用默认值作为属性值

   ```yml
   person:
     name: ${random.uuid}  #使用表达式
     age: ${random.int}   #使用表达式
     happy: true
     birth: 2020/02/02
     map: {k1: v1,k2: v2} #map集合按照一个对象来处理，k为成员属性，v为属性值
     dog:
       name: ${person.hello:hello}_旺财 #使用默认值
       age: 3
     list: #list按照数组来处理
       - code
       - music
       - girl
   12345678910111213
   ```

- 上面的 ${random.uuid}就可以随机生成一个uuid作为name的值

- ${person.hello:hello}_旺财，这个就更加厉害，首先我们使用 ${person.hello}去取person对象属性的hello的值，如果这个值不存在那么就会使用":"后面的值 " hello"和后面的 "_旺财"进行拼接
  ![在这里插入图片描述](https://www.freesion.com/images/760/9f9139ca0c9baeb1856f04ad33fc6068.png)

- 如果person对象属性中有hello属性
  ![在这里插入图片描述](https://www.freesion.com/images/329/a80d48987b7fafb8a1cb2bd13b6c80d1.png)
  ![在这里插入图片描述](https://www.freesion.com/images/684/6e5179494c69d37491299dcf65781ff4.png)

- 上面的功能可以在配置文件中实现，我们的代码就可以减轻响应的工作量，这就是yaml的强大之处，也是springBoot官方推荐使用它的原因

- 对比使用yaml和properties

  

  - cp只需要写一次即可，value则需要每个字段都添加
  - 松散绑定:这个什么意思呢?比如我的yml中写的last-name，这个和lastName是一样的，-后面跟着的字母默认是大写的，这就是松散绑定(就是属性字段使用驼峰命名，yaml文件中使用"-"将名称中单词隔开就行，可以直接都使用小写，这样属性值也是可以实现注入的)
  - JSR303数据校验，这个就是我们可以在字段是增加一层过滤器验证，可以保证数据的合法性
  - 复杂类型封装，yml中可以封装对象，使用@value就不支持

**结论**

- 配置yml和配置properties都可以获取到值，强烈推荐yml
- 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下@value
- 如果说，我们专门编写了一个JavaBean来和配置文件进行映射，就直接使用@configurationProperties，不要犹豫!



### 三、拦截器

#### 1、新建拦截器

既然要使用拦截器，那肯定需要有一个自己定义的拦截器，所以新建一个拦截器：

> 自定义拦截器需要继承HandlerInterceptorAdapter并重写preHandle方法

![image-20210324173325439](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210324173325.png)

#### 2、注册拦截器

新建配置类继承WebMvcConfigurerAdapter类，重写addInterceptors方法。如下：

既然要增加自己的拦截器，那当然要得到springboot加入拦截器的入口，然后把我们自己写的拦截器也注册到springboot中让其起作用。

```java
/**
 * 和springmvc的webmvc拦截配置一样
 * @author BIANP
 */
@Configuration
public class WebConfigurer implements WebMvcConfigurer {
	 @Override
	 public void addInterceptors(InterceptorRegistry registry) {
        // 拦截所有请求，通过判断是否有 @LoginRequired 注解 决定是否需要登录
        registry.addInterceptor(LoginInterceptor()).addPathPatterns("/**");
        registry.addInterceptor(AuthorityInterceptor()).addPathPatterns("/**");
	 }
	 
	 @Bean
	 public LoginInterceptor LoginInterceptor() {
		 return new LoginInterceptor();
	 }
	 
	 @Bean
	 public AuthorityInterceptor AuthorityInterceptor() {
		 return new AuthorityInterceptor();
	 }
}
```

> 1、一定要加[@Configuration](https://my.oschina.net/pointdance) 这个注解，在启动的时候在会被加载。
>
> 2、有一些教程是用的“WebMvcConfigurerAdapter”，不过在spring5.0版本后这个类被丢弃了 WebMvcConfigurerAdapter ，虽然还可以用，但是看起来不好。
>
> 3、也有一些教程使用的WebMvcConfigurationSupport，我使用后发现，classpath:/META/resources/，classpath:/resources/，classpath:/static/，classpath:/public/）不生效。具体可以原因，大家可以看下源码因为：WebMvcAutoConfiguration上有个条件注解：
>
> ```
> @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
> ```
>
> 所以还是建议使用WebMvcConfigurer， 其实springMVC很多东西，都可以搬到springboot中来使用，只需要把配置文件的模式，改成 对应[@Configuration](https://my.oschina.net/pointdance) 类就好了。



![image-20210324173416229](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210324173416.png)

#### 3、拦截器的注解用法

实际开发中有一些方法是需要拦截的，有一下方法是不需要拦截的，因此如果要在每个方法中写明需不需要拦截就变得非常麻烦，因此用Java中的反射和注解机制来简化操作：

##### 编写注解类如下：

```java
/**
 * 在需要登录验证的Controller的方法上使用此注解
 */
@Target({ElementType.METHOD})// 可用在方法名上
@Retention(RetentionPolicy.RUNTIME)// 运行时有效
public @interface LoginRequired {
	
}
```

之后在需要被拦截的方法上使用该**注释**标注。

在第一步中的AuthInterceptor类中的preHandle方法判断被拦截的方法是否带有我们的注释LoginRequired：

```java
public class AuthorityInterceptor extends HandlerInterceptorAdapter{
	
	 @Override
	 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
	 	// 如果不是映射到方法直接通过
        if (!(handler instanceof HandlerMethod)) {
            return true;
        }
        // ①:START 方法注解级拦截器
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        Method method = handlerMethod.getMethod();
        // 判断接口是否需要登录
        LoginRequired methodAnnotation = method.getAnnotation(LoginRequired.class);
        // 有 @LoginRequired 注解，需要认证
        if (methodAnnotation != null) {
            // 这写你拦截需要干的事儿，比如取缓存，SESSION，权限判断等
            System.out.println("====================================");
            return true;
        }
        return true;
	}
}
```

#### 4、测试

1. 在需要拦截的方法上加上`@LoginRequired`注解。
2. 在AuthInterceptor中写相应的处理代码即可使用。



### 四、Spring Boot 中处理跨域

#### Cors是什么

CORS全称为Cross Origin Resource Sharing（跨域资源共享）, 每一个页面需要返回一个名为Access-Control-Allow-Origin的http头来允许外域的站点访问，你可以仅仅暴露有限的资源和有限的外域站点访问。

我们可以理解为：如果一个请求需要允许跨域访问，则需要在http头中设置Access-Control-Allow-Origin来决定需要允许哪些站点来访问。如假设需要允许https://www.dustyblog.c这个站点的请求跨域，则可以设置：

Access-Control-Allow-Origin:https://www.dustyblog.cn。





HTML 5中新增的跨域资源访问（Cross-Origin Resource Sharing）特性可以让我们在开发后端系统的时候决定资源是否允许被跨域访问。所谓跨域指的是域名不同或者端口不同或者协议不同，比如当从mrbrid.cc网站访问mrbird.cc:8080网站资源就会存在跨域问题。Spring从4.2版本开始就提供了跨域的支持，开箱即用。这里介绍如何在Spring Boot开发中解决跨域的问题，主要分为注解驱动和接口编程的方式。



#### 模拟跨域

要解决跨域问题，我们就得先模拟一个跨域情景。新建Spring Boot项目，版本为2.1.0.RELEASE，并引如下依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```



项目结构如下所示：

![QQ截图20190301150006.png](https://mrbird.cc/img/QQ截图20190301150006.png)

在`com.example.demo`路径下新建`controller`包，并创建`TestController`：

```java
@Controller
public class TestController {

    @RequestMapping("index")
    public String index () {
        return "index";
    }

    @RequestMapping("hello")
    @ResponseBody
    public String hello(){
        return "hello";
    }
}
```



然后在resources/templates下新建index.html：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>跨域测试</title>
    <script src="http://libs.baidu.com/jquery/1.11.3/jquery.min.js"></script>
</head>
<body>
<div id="hello"></div>
</body>
<script>
    $(function () {
        $.get("http://test.mrbird.cc:8080/hello", function (data) {
            $("#hello").text(data);
        })
    })
</script>
</html>
```



编辑本地hosts文件，将[http://test.mrbird.cc](http://test.mrbird.cc/)网址映射到127.0.0.1上：

![QQ截图20190301150336.png](https://mrbird.cc/img/QQ截图20190301150336.png)

启动项目访问http://localhost:8080/，会发现页面并没有成功显示hello，并且F12观察浏览器控制台会发现其报错了：

![QQ截图20190301150534.png](https://mrbird.cc/img/QQ截图20190301150534.png)

这是因为我们在http://localhost:8080/域名下试图访问[http://test.mrbird.cc:8080](http://test.mrbird.cc:8080/)下的hello接口，这就存在跨域问题，接下来我们来解决这个问题。

#### 注解驱动

Spring 4.2后提供了`@CrossOrigin`注解，该注解可以标注于方法或者类上，包含了以下属性:

| 属性             | 含义                                                         |
| :--------------- | :----------------------------------------------------------- |
| value            | 指定所支持域的集合，`*`表示所有域都支持，默认值为`*`。这些值对应HTTP请求头中的`Access-Control-Allow-Origin` |
| origins          | 同value                                                      |
| allowedHeaders   | 允许请求头中的header，默认都支持                             |
| exposedHeaders   | 响应头中允许访问的header，默认为空                           |
| methods          | 支持请求的方法，比如`GET`，`POST`，`PUT`等，默认和Controller中的方法上标注的一致。 |
| allowCredentials | 是否允许cookie随请求发送，使用时必须指定具体的域             |
| maxAge           | 预请求的结果的有效期，默认30分钟                             |

我们来改造`TestController`中的`hello`方法：

```java
@RequestMapping("hello")
@ResponseBody
@CrossOrigin(value = "*")
public String hello() {
    return "hello";
}
```

表示允许所有域都支持，重启项目，再次访问http://localhost:8080/：

![QQ截图20190301153418.png](https://mrbird.cc/img/QQ截图20190301153418.png)

#### 接口编程

除了使用`@CrossOrigin`注解外，我们可以使用接口编程的方式进行统一配置。

在`com.example.demo`路径下新建`config`包，然后创建`WebConfigurer`，实现`WebMvcConfigurer`，重写`addCorsMappings`默认实现：

```java
@Configuration
public class WebConfigurer implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowedMethods("GET");
    }
}
```

```java
/**
 * 跨域配置
 */
@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Bean
    public WebMvcConfigurer corsConfigurer()
    {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**").
                        allowedOrigins("https://www.dustyblog.cn"). //允许跨域的域名，可以用*表示允许任何域名使用
                        allowedMethods("*"). //允许任何方法（post、get等）
		                allowedHeaders("*"). //允许任何请求头
                        allowCredentials(true). //带上cookie信息
                        exposedHeaders(HttpHeaders.SET_COOKIE).maxAge(3600L); //maxAge(3600)表明在3600秒内，不需要再发送预检验请求，可以缓存该结果
            }
        };
    }
}

```

上面配置表示允许所有请求支持跨域访问，并且不限定域，但是支持持GET方法。将`hello`方法上的`@CrossOrigin`注解注释掉，重启项目，再次访问http://localhost:8080/，结果也是OK的。

#### 过滤器实现

查看官方文档，发现其还提供了基于过滤器的实现方式：

```java
@Bean
public FilterRegistrationBean corsFilter() {
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowCredentials(true);
    config.addAllowedOrigin("*");
    source.registerCorsConfiguration("/**", config);
    FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source));
    bean.setOrder(0);
    return bean;
}
```

```java
package net.ybclass.online_ybclass.interceptor;

import org.springframework.http.HttpMethod;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class CorsInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //表示接受任意域名的请求,也可以指定域名
        response.setHeader("Access-Control-Allow-Origin", request.getHeader("origin"));

        //该字段可选，是个布尔值，表示是否可以携带cookie
        response.setHeader("Access-Control-Allow-Credentials", "true");

        response.setHeader("Access-Control-Allow-Methods", "GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS");

        response.setHeader("Access-Control-Allow-Headers", "*");
        //这里可以不加，但是其他语言开发的话记得处理options请求
        /**
         * 非简单请求是对那种对服务器有特殊要求的请求，
         * 比如请求方式是PUT或者DELETE，或者Content-Type字段类型是application/json。
         * 都会在正式通信之前，增加一次HTTP请求，称之为预检。浏览器会先询问服务器，当前网页所在域名是否在服务器的许可名单之中，
         * 服务器允许之后，浏览器会发出正式的XMLHttpRequest请求
         */
        if (HttpMethod.OPTIONS.toString().equals(request.getMethod())) {
            return true;
        }
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}
```



#### Actuator跨域

如果项目里集成了`Actuator`相关功能，其暴露的接口也支持跨域，只需要在配置文件中添加如下配置即可：

ENDPOINTS CORS CONFIGURATION ([CorsEndpointProperties](https://github.com/spring-projects/spring-boot/blob/v2.1.0.RELEASE/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/CorsEndpointProperties.java))

```java
management.endpoints.web.cors.allow-credentials= # Whether credentials are supported. When not set, credentials are not supported.
management.endpoints.web.cors.allowed-headers= # Comma-separated list of headers to allow in a request. '*' allows all headers.
management.endpoints.web.cors.allowed-methods= # Comma-separated list of methods to allow. '*' allows all methods. When not set, defaults to GET.
management.endpoints.web.cors.allowed-origins= # Comma-separated list of origins to allow. '*' allows all origins. When not set, CORS support is disabled.
management.endpoints.web.cors.exposed-headers= # Comma-separated list of headers to include in a response.
management.endpoints.web.cors.max-age=1800s # How long the response from a pre-flight request can be cached by clients. If a duration suffix is not specified, seconds will be used.
```



> 源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/48.Spring-Boot-CORS-Support



### 五、Spring Boot中开启Spring Security

Spring Security是一款基于Spring的安全框架，主要包含认证和授权两大安全模块，和另外一款流行的安全框架Apache Shiro相比，它拥有更为强大的功能。Spring Security也可以轻松的自定义扩展以满足各种需求，并且对常见的Web安全攻击提供了防护支持。如果你的Web框架选择的是Spring，那么在安全方面Spring Security会是一个不错的选择。

这里我们使用Spring Boot来集成Spring Security，Spring Boot版本为`1.5.14.RELEASE`，Spring Security版本为`4.2.7RELEASE`。

#### 5.1 开启Spring Security

创建一个Spring Boot项目，然后引入spring-boot-starter-security：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```



接下来我们创建一个TestController，对外提供一个`/hello`服务：

```java
@RestController
public class TestController {
    @GetMapping("hello")
    public String hello() {
        return "hello spring security";
    }
}
```



这时候我们直接启动项目，访问http://localhost:8080/hello，可看到页面弹出了个HTTP Basic认证框：

![QQ截图20180707095933.png](https://mrbird.cc/img/QQ截图20180707095933.png)

当Spring项目中引入了Spring Security依赖的时候，项目会默认开启如下配置：

```yaml
security:
  basic:
    enabled: true
```



这个配置开启了一个HTTP basic类型的认证，所有服务的访问都必须先过这个认证，默认的用户名为user，密码由Sping Security自动生成，回到IDE的控制台，可以找到密码信息：

```xml
Using default security password: e9ed391c-93de-4611-ac87-d871d9e749ac
```



输入用户名user，密码e9ed391c-93de-4611-ac87-d871d9e749ac后，我们便可以成功访问`/hello`接口。

#### 5.2 基于表单认证

我们可以通过一些配置将HTTP Basic认证修改为基于表单的认证方式。

创建一个配置类`BrowserSecurityConfig`继承`org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter`这个抽象类并重写`configure(HttpSecurity http)`方法。`WebSecurityConfigurerAdapter`是由Spring Security提供的Web应用安全配置的适配器：

```java
@Configuration
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin() // 表单方式
                .and()
                .authorizeRequests() // 授权配置
                .anyRequest()  // 所有请求
                .authenticated(); // 都需要认证
    }
}
```



Spring Security提供了这种链式的方法调用。上面配置指定了认证方式为表单登录，并且所有请求都需要进行认证。这时候我们重启项目，再次访问http://localhost:8080/hello，可以看到认证方式已经是form表单的方式了：

![QQ截图20180707102535.png](https://mrbird.cc/img/QQ截图20180707102535.png)

用户名依旧是user，密码由Spring Security自动生成。当输入凭证错误时，页面上将显示错误信息：

![QQ截图20180707103009.png](https://mrbird.cc/img/QQ截图20180707103009.png)

如果需要换回HTTP Basic的认证方式，我们只需要简单修改`configure`方法中的配置：

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    // http.formLogin() // 表单方式
    http.httpBasic() // HTTP Basic方式
            .and()
            .authorizeRequests() // 授权配置
            .anyRequest()  // 所有请求
            .authenticated(); // 都需要认证
}
```

#### 5.3 基本原理

上面我们开启了一个最简单的Spring Security安全配置，下面我们来了解下Spring Security的基本原理。通过上面的的配置，代码的执行过程可以简化为下图表示：

![QQ截图20180707111356.png](https://mrbird.cc/img/QQ截图20180707111356.png)

如上图所示，Spring Security包含了众多的过滤器，这些过滤器形成了一条链，所有请求都必须通过这些过滤器后才能成功访问到资源。其中`UsernamePasswordAuthenticationFilter`过滤器用于处理基于表单方式的登录认证，而`BasicAuthenticationFilter`用于处理基于HTTP Basic方式的登录验证，后面还可能包含一系列别的过滤器（可以通过相应配置开启）。在过滤器链的末尾是一个名为`FilterSecurityInterceptor`的拦截器，用于判断当前请求身份认证是否成功，是否有相应的权限，当身份认证失败或者权限不足的时候便会抛出相应的异常。`ExceptionTranslateFilter`捕获并处理，所以我们在`ExceptionTranslateFilter`过滤器用于处理了`FilterSecurityInterceptor`抛出的异常并进行处理，比如需要身份认证时将请求重定向到相应的认证页面，当认证失败或者权限不足时返回相应的提示信息。

下面我们通过debug来验证这个过程（登录方式改回表单的方式）。

我们在`/hello`服务上打个断点：

![QQ截图20180707132345.png](https://mrbird.cc/img/QQ截图20180707132345.png)

在`FilterSecurityInterceptor`的invoke方法的`super.beforeInvocation`上打个断点：

![QQ截图20180707132824.png](https://mrbird.cc/img/QQ截图20180707132824.png)

当这行代码执行通过后，便可以调用下一行的`doFilter`方法来真正调用`/hello`服务，否则将抛出相应的异常。

当`FilterSecurityInterceptor`抛出异常时，异常将由`ExceptionTranslateFilter`捕获并处理，所以我们在`ExceptionTranslateFilter`的`doFilter`方法`catch`代码块第一行打个断点：

![QQ截图20180707133347.png](https://mrbird.cc/img/QQ截图20180707133347.png)

我们待会模拟的是用户未登录直接访问`/hello`，所以应该是抛出用户未认证的异常，所以接下来应该跳转到`UsernamePasswordAuthenticationFilter`处理表单方式的用户认证。在`UsernamePasswordAuthenticationFilter`的`attemptAuthentication`方法上打个断点：

![QQ截图20180707134106.png](https://mrbird.cc/img/QQ截图20180707134106.png)

准备完毕后，我们启动项目，然后访问http://localhost:8080/hello，代码直接跳转到`FilterSecurityInteceptor`的断点上：

![QQ截图20180707134540.png](https://mrbird.cc/img/QQ截图20180707134540.png)

往下执行，因为当前请求没有经过身份认证，所以将抛出异常并被`ExceptionTranslateFilter`捕获：

![QQ截图20180707134540.png](https://mrbird.cc/img/QQ截图20180707134915.png)

捕获异常后重定向到登录表单登录页面，当我们在表单登录页面输入信息点login后，代码跳转到`UsernamePasswordAuthenticationFilter`过滤器的`attemptAuthentication`方法上：

![QQ截图20180707135743.png](https://mrbird.cc/img/QQ截图20180707135743.png)

判断用户名和密码是否正确之后，代码又跳回`FilterSecurityInterceptor`的`beforeInvocation`方法执行上：

![QQ截图20180707140158.png](https://mrbird.cc/img/QQ截图20180707140158.png)

当认证通过时，`FilterSecurityInterceptor`代码往下执行`doFilter`，然后代码最终跳转到`/hello`上：

![QQ截图20180707140532.png](https://mrbird.cc/img/QQ截图20180707140532.png)

浏览器页面将显示`hello spring security`信息。

源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/34.Start-Spring-Security



#### 5.4 Spring Security自定义用户认证

在[Spring Boot中开启Spring Security](https://mrbird.cc/Spring-Boot&Spring-Security.html)一节中我们简单搭建了个Spring Boot + Spring Security的项目，认证的用户名和密码都是由Spring Security生成。Spring Security支持我们自定义认证的过程，如处理用户信息获取逻辑，使用我们自定义的登录页面替换Spring Security默认的登录页及自定义登录成功或失败后的处理逻辑等。这里将在上一节的源码基础上进行改造。

##### 5.4.1 自定义认证过程

自定义认证的过程需要实现Spring Security提供的`UserDetailService`接口，该接口只有一个抽象方法`loadUserByUsername`，源码如下：

```
public interface UserDetailsService {
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```



`loadUserByUsername`方法返回一个`UserDetail`对象，该对象也是一个接口，包含一些用于描述用户信息的方法，源码如下：

```
public interface UserDetails extends Serializable {

    Collection<? extends GrantedAuthority> getAuthorities();

    String getPassword();

    String getUsername();

    boolean isAccountNonExpired();

    boolean isAccountNonLocked();

    boolean isCredentialsNonExpired();

    boolean isEnabled();
}
```



这些方法的含义如下：

- `getAuthorities`获取用户包含的权限，返回权限集合，权限是一个继承了`GrantedAuthority`的对象；
- `getPassword`和`getUsername`用于获取密码和用户名；
- `isAccountNonExpired`方法返回boolean类型，用于判断账户是否未过期，未过期返回true反之返回false；
- `isAccountNonLocked`方法用于判断账户是否未锁定；
- `isCredentialsNonExpired`用于判断用户凭证是否没过期，即密码是否未过期；
- `isEnabled`方法用于判断用户是否可用。

实际中我们可以自定义`UserDetails`接口的实现类，也可以直接使用Spring Security提供的`UserDetails`接口实现类`org.springframework.security.core.userdetails.User`。

说了那么多，下面我们来开始实现`UserDetailService`接口的`loadUserByUsername`方法。

首先创建一个`MyUser`对象，用于存放模拟的用户数据（实际中一般从数据库获取，这里为了方便直接模拟）：

```
public class MyUser implements Serializable {
    private static final long serialVersionUID = 3497935890426858541L;

    private String userName;

    private String password;

    private boolean accountNonExpired = true;

    private boolean accountNonLocked= true;

    private boolean credentialsNonExpired= true;

    private boolean enabled= true;

    // get,set略
}
```



接着创建`MyUserDetailService`实现`UserDetailService`：

```
@Configuration
public class UserDetailService implements UserDetailsService {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 模拟一个用户，替代数据库获取逻辑
        MyUser user = new MyUser();
        user.setUserName(username);
        user.setPassword(this.passwordEncoder.encode("123456"));
        // 输出加密后的密码
        System.out.println(user.getPassword());

        return new User(username, user.getPassword(), user.isEnabled(),
                user.isAccountNonExpired(), user.isCredentialsNonExpired(),
                user.isAccountNonLocked(), AuthorityUtils.commaSeparatedStringToAuthorityList("admin"));
    }
}
```



这里我们使用了`org.springframework.security.core.userdetails.User`类包含7个参数的构造器，其还包含一个三个参数的构造器`User(String username, String password,Collection<? extends GrantedAuthority> authorities)`，由于权限参数不能为空，所以这里先使用`AuthorityUtils.commaSeparatedStringToAuthorityList`方法模拟一个admin的权限，该方法可以将逗号分隔的字符串转换为权限集合。

此外我们还注入了`PasswordEncoder`对象，该对象用于密码加密，注入前需要手动配置。我们在`BrowserSecurityConfig`中配置它：

```
@Configuration
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    ...
}
```



`PasswordEncoder`是一个密码加密接口，而`BCryptPasswordEncoder`是Spring Security提供的一个实现方法，我们也可以自己实现`PasswordEncoder`。不过Spring Security实现的`BCryptPasswordEncoder`已经足够强大，它对相同的密码进行加密后可以生成不同的结果。

这时候重启项目，访问http://localhost:8080/login，便可以使用任意用户名以及123456作为密码登录系统。我们多次进行登录操作，可以看到控制台输出的加密后的密码如下：

![QQ截图20180712210522.png](https://mrbird.cc/img/3ieuqei349h39.png)

可以看到，`BCryptPasswordEncoder`对相同的密码生成的结果每次都是不一样的。

##### 5.4.2 替换默认登录页

默认的登录页面过于简陋，我们可以自己定义一个登录页面。为了方便起见，我们直接在src/main/resources/resources目录下定义一个login.html（不需要Controller跳转）：

```
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>登录</title>
    <link rel="stylesheet" href="css/login.css" type="text/css">
</head>
<body>
    <form class="login-page" action="/login" method="post">
        <div class="form">
            <h3>账户登录</h3>
            <input type="text" placeholder="用户名" name="username" required="required" />
            <input type="password" placeholder="密码" name="password" required="required" />
            <button type="submit">登录</button>
        </div>
    </form>
</body>
</html>
```



要怎么做才能让Spring Security跳转到我们自己定义的登录页面呢？很简单，只需要在`BrowserSecurityConfig`的`configure`中添加一些配置：

```
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.formLogin() // 表单登录
            // http.httpBasic() // HTTP Basic
            .loginPage("/login.html") 
            .loginProcessingUrl("/login")
            .and()
            .authorizeRequests() // 授权配置
            .antMatchers("/login.html").permitAll()
            .anyRequest()  // 所有请求
            .authenticated(); // 都需要认证
}
```



上面代码中`.loginPage("/login.html")`指定了跳转到登录页面的请求URL，`.loginProcessingUrl("/login")`对应登录页面form表单的`action="/login"`，`.antMatchers("/login.html").permitAll()`表示跳转到登录页面的请求不被拦截，否则会进入无限循环。

这时候启动系统，访问http://localhost:8080/hello，会看到页面已经被重定向到了http://localhost:8080/login.html：

![QQ截图20180713211112.png](https://mrbird.cc/img/QQ截图20180713211112.png)

输入用户名和密码发现页面报错：

![QQ截图20180713212002.png](https://mrbird.cc/img/QQ截图20180713212002.png)

我们先把CSRF攻击防御关了，修改`BrowserSecurityConfig`的`configure`：

```java
Override
protected void configure(HttpSecurity http) throws Exception {
    http.formLogin() // 表单登录
            // http.httpBasic() // HTTP Basic
            .loginPage("/login.html") // 登录跳转 URL
            .loginProcessingUrl("/login") // 处理表单登录 URL
            .and()
            .authorizeRequests() // 授权配置
            .antMatchers("/login.html").permitAll() // 登录跳转 URL 无需认证
            .anyRequest()  // 所有请求
            .authenticated() // 都需要认证
            .and().csrf().disable();
}
```



重启项目便可正常登录。

假如现在有这样一个需求：在未登录的情况下，当用户访问html资源的时候跳转到登录页，否则返回JSON格式数据，状态码为401。

要实现这个功能我们将`loginPage`的URL改为`/authentication/require`，并且在`antMatchers`方法中加入该URL，让其免拦截:

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.formLogin() // 表单登录
            // http.httpBasic() // HTTP Basic
            .loginPage("/authentication/require") // 登录跳转 URL
            .loginProcessingUrl("/login") // 处理表单登录 URL
            .and()
            .authorizeRequests() // 授权配置
            .antMatchers("/authentication/require", "/login.html").permitAll() // 登录跳转 URL 无需认证
            .anyRequest()  // 所有请求
            .authenticated() // 都需要认证
            .and().csrf().disable();
}
```



然后定义一个控制器`BrowserSecurityController`，处理这个请求：

```java
@RestController
public class BrowserSecurityController {
    private RequestCache requestCache = new HttpSessionRequestCache();
    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();

    @GetMapping("/authentication/require")
    @ResponseStatus(HttpStatus.UNAUTHORIZED)
    public String requireAuthentication(HttpServletRequest request, HttpServletResponse response) throws IOException {
        SavedRequest savedRequest = requestCache.getRequest(request, response);
        if (savedRequest != null) {
            String targetUrl = savedRequest.getRedirectUrl();
            if (StringUtils.endsWithIgnoreCase(targetUrl, ".html"))
                redirectStrategy.sendRedirect(request, response, "/login.html");
        }
        return "访问的资源需要身份认证！";
    }
}
```



其中`HttpSessionRequestCache`为Spring Security提供的用于缓存请求的对象，通过调用它的`getRequest`方法可以获取到本次请求的HTTP信息。`DefaultRedirectStrategy`的`sendRedirect`为Spring Security提供的用于处理重定向的方法。

上面代码获取了引发跳转的请求，根据请求是否以`.html`为结尾来对应不同的处理方法。如果是以`.html`结尾，那么重定向到登录页面，否则返回”访问的资源需要身份认证！”信息，并且HTTP状态码为401（`HttpStatus.UNAUTHORIZED`）。

这样当我们访问http://localhost:8080/hello的时候页面便会跳转到http://localhost:8080/authentication/require，并且输出”访问的资源需要身份认证！”，当我们访问http://localhost:8080/hello.html的时候，页面将会跳转到登录页面。

##### 5.4.3 处理成功和失败

Spring Security有一套默认的处理登录成功和失败的方法：当用户登录成功时，页面会跳转会引发登录的请求，比如在未登录的情况下访问http://localhost:8080/hello，页面会跳转到登录页，登录成功后再跳转回来；登录失败时则是跳转到Spring Security默认的错误提示页面。下面我们通过一些自定义配置来替换这套默认的处理机制。

###### 自定义登录成功逻辑

要改变默认的处理成功逻辑很简单，只需要实现`org.springframework.security.web.authentication.AuthenticationSuccessHandler`接口的`onAuthenticationSuccess`方法即可：

```java
@Component
public class MyAuthenticationSucessHandler implements AuthenticationSuccessHandler {
    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                        Authentication authentication) throws IOException, ServletException {
        response.setContentType("application/json;charset=utf-8");
        response.getWriter().write(mapper.writeValueAsString(authentication));
    }
}
```



其中`Authentication`参数既包含了认证请求的一些信息，比如IP，请求的SessionId等，也包含了用户信息，即前面提到的`User`对象。通过上面这个配置，用户登录成功后页面将打印出`Authentication`对象的信息。

要使这个配置生效，我们还的在`BrowserSecurityConfig`的`configure`中配置它：

```java
@Configuration
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private MyAuthenticationSucessHandler authenticationSucessHandler;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin() // 表单登录
                // http.httpBasic() // HTTP Basic
                .loginPage("/authentication/require") // 登录跳转 URL
                .loginProcessingUrl("/login") // 处理表单登录 URL
                .successHandler(authenticationSucessHandler) // 处理登录成功
                .and()
                .authorizeRequests() // 授权配置
                .antMatchers("/authentication/require", "/login.html").permitAll() // 登录跳转 URL 无需认证
                .anyRequest()  // 所有请求
                .authenticated() // 都需要认证
                .and().csrf().disable();
    }
}
```



我们将`MyAuthenticationSucessHandler`注入进来，并通过`successHandler`方法进行配置。

这时候重启项目登录后页面将会输出如下JSON信息：

```
{
  "authorities": [
    {
      "authority": "admin"
    }
  ],
  "details": {
    "remoteAddress": "0:0:0:0:0:0:0:1",
    "sessionId": "8D50BAF811891F4397E21B4B537F0544"
  },
  "authenticated": true,
  "principal": {
    "password": null,
    "username": "mrbird",
    "authorities": [
      {
        "authority": "admin"
      }
    ],
    "accountNonExpired": true,
    "accountNonLocked": true,
    "credentialsNonExpired": true,
    "enabled": true
  },
  "credentials": null,
  "name": "mrbird"
}
```



像`password`，`credentials`这些敏感信息，Spring Security已经将其屏蔽。

除此之外，我们也可以在登录成功后做页面的跳转，修改`MyAuthenticationSucessHandler`：

```
@Component
public class MyAuthenticationSucessHandler implements AuthenticationSuccessHandler {
    private RequestCache requestCache = new HttpSessionRequestCache();
    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();

    @Autowired
    private ObjectMapper mapper;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                        Authentication authentication) throws IOException {
        SavedRequest savedRequest = requestCache.getRequest(request, response);
        redirectStrategy.sendRedirect(request, response, savedRequest.getRedirectUrl());
    }
}
```



通过上面配置，登录成功后页面将跳转回引发跳转的页面。如果想指定跳转的页面，比如跳转到`/index`，可以将`savedRequest.getRedirectUrl()`修改为`/index`：

```
@Component
public class MyAuthenticationSucessHandler implements AuthenticationSuccessHandler {
    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                        Authentication authentication) throws IOException {
        redirectStrategy.sendRedirect(request, response, "/index");
    }
}
```



然后在TestController中定义一个处理该请求的方法：

```
@RestController
public class TestController {
    @GetMapping("index")
    public Object index(){
        return SecurityContextHolder.getContext().getAuthentication();
    }
}
```



登录成功后，便可以使用`SecurityContextHolder.getContext().getAuthentication()`获取到`Authentication`对象信息。除了通过这种方式获取`Authentication`对象信息外，也可以使用下面这种方式:

```
@RestController
public class TestController {
    @GetMapping("index")
    public Object index(Authentication authentication) {
        return authentication;
    }
}
```



重启项目，登录成功后，页面将跳转到http://localhost:8080/index：

![QQ截图20180714103649.png](https://mrbird.cc/img/QQ截图20180714103649.png)

###### 自定义登录失败逻辑

和自定义登录成功处理逻辑类似，自定义登录失败处理逻辑需要实现`org.springframework.security.web.authentication.AuthenticationFailureHandler`的`onAuthenticationFailure`方法：

```java
@Component
public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler {
    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
                                        AuthenticationException exception) throws IOException {
    }
}
```



`onAuthenticationFailure`方法的`AuthenticationException`参数是一个抽象类，Spring Security根据登录失败的原因封装了许多对应的实现类，查看`AuthenticationException`的Hierarchy：

![QQ截图20180714104551.png](https://mrbird.cc/img/QQ截图20180714104551.png)

不同的失败原因对应不同的异常，比如用户名或密码错误对应的是`BadCredentialsException`，用户不存在对应的是`UsernameNotFoundException`，用户被锁定对应的是`LockedException`等。

假如我们需要在登录失败的时候返回失败信息，可以这样处理：

```java
@Component
public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler {

    @Autowired
    private ObjectMapper mapper;

    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
                                        AuthenticationException exception) throws IOException {
        response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
        response.setContentType("application/json;charset=utf-8");
        response.getWriter().write(mapper.writeValueAsString(exception.getMessage()));
    }
}
```



状态码定义为500（`HttpStatus.INTERNAL_SERVER_ERROR.value()`），即系统内部异常。

同样的，我们需要在`BrowserSecurityConfig`的`configure`中配置它：

```java
@Configuration
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private MyAuthenticationSucessHandler authenticationSucessHandler;

    @Autowired
    private MyAuthenticationFailureHandler authenticationFailureHandler;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin() // 表单登录
                // http.httpBasic() // HTTP Basic
                .loginPage("/authentication/require") // 登录跳转 URL
                .loginProcessingUrl("/login") // 处理表单登录 URL
                .successHandler(authenticationSucessHandler) // 处理登录成功
                .failureHandler(authenticationFailureHandler) // 处理登录失败
                .and()
                .authorizeRequests() // 授权配置
                .antMatchers("/authentication/require", "/login.html").permitAll() // 登录跳转 URL 无需认证
                .anyRequest()  // 所有请求
                .authenticated() // 都需要认证
                .and().csrf().disable();
    }
}
```



重启项目，当输入错误的密码时，页面输出如下：

![QQ截图20180714105620.png](https://mrbird.cc/img/QQ截图20180714105620.png)

源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/35.Spring-Security-Authentication

### 六、jwt实现基于token的权限管理

https://github.com/echisan/springboot-jwt-demo

https://github.com/Snailclimb/spring-security-jwt-guide/blob/master/docs/SpringSecurity%E4%BB%8B%E7%BB%8D.md

> 更改一下`application.properites`的数据库的一些配置信息，然后就可以运行了
>
> 首先注册的url是`/auth/register` 参数很简单就`username`,`password`
>
> 然后登陆是`/auth/login`

#### JWT

再稍微提一提jwt吧，在前段时间有个小项目是前后端分离的，所以需要用到基于token的权限管理机制，所以就了解到了jwt这一个方案。不过关于这个方案，似乎没有一个如何管理已经生产的token的方法（如果有的话欢迎告知，我还不知道呢。。）一旦生成了一个token，就无法对该token进行任何操作，无法使该token失效，只有等到该token到了过期的时间点才失效，这样就会有一个很大的隐患。然后搜索了挺多相关的资料以及经过相当长一段时间的思考决定使用redis去管理已经生成的token，下面会~~详细~~说一下。

#### 整理一下思路

创建一个新工程时，我们需要思考一下我们接下来需要的一些步骤，需要做什么，怎么做。

- 搭建springboot工程
- 导入springSecurity跟jwt的依赖
- 用户的实体类
- dao层
- service层（真正开发时再写，这里就直接调用dao层操作数据库）
- 实现UserDetailsService接口
- 实现UserDetails接口
- 验证用户登录信息的拦截器
- 验证用户权限的拦截器
- springSecurity配置
- 认证的Controller以及测试的controller
- 测试

##### 创建一个springboot工程

建议使用maven去构建项目。

```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
```

##### 实体类User

创建一个演示的实体类User，包含最基本的用户名跟密码，至于role干嘛用后面会提到

```java
@Entity
@Table(name = "jd_user")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Integer id;

    @Column(name = "username")
    private String username;

    @Column(name = "password")
    private String password;

    @Column(name = "role")
    private String role;

	// getter and setter...
}
```

##### JWT工具类

这里jwt我选择的是[jjwt](https://github.com/jwtk/jjwt)，至于为什么，可能是因为我用的比较顺手吧_(:3」∠)_

```XML
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.0</version>
</dependency>
```

##### JwtTokenUtils

jwt工具类，对jjwt封装一下方便调用

```java
package com.study.dream.springsecurity.utils;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import javax.crypto.SecretKey;
import javax.xml.bind.DatatypeConverter;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

/**
 * @description:
 * @author: Chenql
 * @time: 2021/4/22 11:35
 */
public class JwtTokenUtils {

    public static final String TOKEN_HEADER = "Authorization";
    public static final String TOKEN_PREFIX = "Bearer ";

    private static final String SECRET = "cereshuzhitingnizhenbangcereshuzhitingnizhenbDFGDFGDFGDGRTDFGDFGGGGGGGGDFGJHKJHKHJDFGDFGDFGDFGang";
    private static final String ISS = "echisan";

    /**
     * JWT签名密钥硬编码到应用程序代码中，应该存放在环境变量或.properties文件中。
     */
    public static final String JWT_SECRET_KEY = "CFJaNdRgUkXn2r5u8xADGKbPeShVmYq3s6v9sdfyB&EHMcQKkdflKkdnfLSLDFKldlflslflsdffTjWnZr4u7w";

    private static final String ROLE_CLAIMS = "rol";

    // JWT token defaults
    public static final String TOKEN_TYPE = "JWT";

    // System WHITELIST
    public static final String[] SYSTEM_WHITELIST = {
            "/auth/login",
            "/users/sign-up"
    };

    // 过期时间是3600秒，既是1个小时
    private static final long EXPIRATION = 3600L;
    // 选择了记住我之后的过期时间为7天
    private static final long EXPIRATION_REMEMBER = 604800L;

    private static final byte[] apiKeySecretBytes = DatatypeConverter.parseBase64Binary(SECRET);

    private static final SecretKey secretKey = Keys.hmacShaKeyFor(apiKeySecretBytes);

    public static String createToken(String username, List<String> roles, boolean isRememberMe) {
        long expiration = isRememberMe ? EXPIRATION_REMEMBER : EXPIRATION;

        String token = Jwts.builder()
                           .setHeaderParam("typ", TOKEN_TYPE)
                           .signWith(secretKey, SignatureAlgorithm.HS256)
                           .claim(ROLE_CLAIMS, String.join(",", roles))
                           .setIssuer(ISS)
                           .setSubject(username)
                           .setIssuedAt(new Date())
                           .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
                           .compact();
        return TOKEN_PREFIX + token;
    }

    public static String getUsername(String token) {
        return getTokenBody(token).getSubject();
    }

    public static boolean isExpiration(String token) {
        return getTokenBody(token).getExpiration().before(new Date());
    }

    private static Claims getTokenBody(String token) {
        return Jwts.parser()
                   .setSigningKey(SECRET)
                   .parseClaimsJws(token)
                   .getBody();
    }

    public static List<SimpleGrantedAuthority> getUserRole(String token) {
        String role = (String) getTokenBody(token)
                .get(ROLE_CLAIMS);
        return Arrays.stream(role.split(","))
                     .map(SimpleGrantedAuthority::new)
                     .collect(Collectors.toList());

    }

}

```

##### UserRepository

写一个根据用户名获取用户的方法，后续会用到

```java
public interface UserRepository extends CrudRepository<User, Integer> {
    User findByUsername(String username);
}
```

##### UserDetailsServiceImpl

使用springSecurity需要实现`UserDetailsService`接口供权限框架调用，该方法只需要实现一个方法就可以了，那就是根据用户名去获取用户，那就是上面repository定义的方法了，这里直接调用了。

```java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(s);
        return new JwtUser(user);
    }

}
```

由于接口方法需要返回一个`UserDetails`类型的接口，所以这边就再写一个类去实现一下这个接口。

##### JwtUser

实现这个接口需要实现几个方法

```java
public class JwtUser implements UserDetails {

    private Integer id;
    private String username;
    private String password;
    private Collection<? extends GrantedAuthority> authorities;

    public JwtUser() {
    }

    // 写一个能直接使用user创建jwtUser的构造器
    public JwtUser(User user) {
        id = user.getId();
        username = user.getUsername();
        password = user.getPassword();
        authorities = Collections.singleton(new SimpleGrantedAuthority(user.getRole()));
    }

	// 获取权限信息，目前博主只会拿来存角色。。
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

	// 账号是否未过期，默认是false，记得要改一下
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

	// 账号是否未锁定，默认是false，记得也要改一下
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

	// 账号凭证是否未过期，默认是false，记得还要改一下
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

	// 这个有点抽象不会翻译，默认也是false，记得改一下
    @Override
    public boolean isEnabled() {
        return true;
    }

	// 我自己重写打印下信息看的
    @Override
    public String toString() {
        return "JwtUser{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", authorities=" + authorities +
                '}';
    }
}
```

#### 配置拦截器

可以说到目前为止这是最复杂的一个步骤，其实搞清楚了还是挺简单的，网上挺多人都更倾向于使用shiro，但是偶尔也要尝试一下新东西的嘛，但是当时我在摸索的时候遇到挺多坑，当时也已经到了思考人生的地步了 ~~框架不是为了简化开发吗！为什么！明明jwt加上权限框架是双倍的快乐！为什么会这样！~~(╯°口°)╯(┴—┴

回到正题，到底要怎么配置呢？使用过shiro的人会知道，鉴权的话需要自己实现一个realm，重写两个方法，第一是用户验证，第二是鉴权。在spring-security中也不例外，这边需要实现两个过滤器。使用`JWTAuthenticationFilter`去进行用户账号的验证，使用`JWTAuthorizationFilter`去进行用户权限的验证。

##### JWTAuthenticationFilter

###### 认证过滤器 校验用户名和密码

> 第一个过滤器主要`JWTAuthenticationFilter`用于根据用户的用户名和密码进行登录验证(用户请求中必须有用户名和密码这两个参数)，为此我们继承了 `UsernamePasswordAuthenticationFilter` 并且重写了下面三个方法：
>
> 1. `attemptAuthentication（）`: 验证用户身份。
> 2. `successfulAuthentication()` ： 用户身份验证成功后调用的方法。
> 3. `unsuccessfulAuthentication()`： 用户身份验证失败后调用的方法。



`JWTAuthenticationFilter`继承于`UsernamePasswordAuthenticationFilter` 该拦截器用于获取用户登录的信息，只需创建一个`token`并调用`authenticationManager.authenticate()`让spring-security去进行验证就可以了，不用自己查数据库再对比密码了，这一步交给spring去操作。 这个操作有点像是shiro的`subject.login(new UsernamePasswordToken())`，验证的事情交给框架。 献上这一部分的代码。

```java
/**
 * @author shuang.kou
 * 如果用户名和密码正确，那么过滤器将创建一个JWT Token 并在HTTP Response 的header中返回它，格式：token: "Bearer +具体token值"
 */
public class JWTAuthenticationFilter extends UsernamePasswordAuthenticationFilter {

    private AuthenticationManager authenticationManager;

    public JWTAuthenticationFilter(AuthenticationManager authenticationManager) {
        this.authenticationManager = authenticationManager;
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request,
                                                HttpServletResponse response) throws AuthenticationException {

        // 从输入流中获取到登录的信息
        try {
            LoginUser loginUser = new ObjectMapper().readValue(request.getInputStream(), LoginUser.class);
   
            // 这部分和attemptAuthentication方法中的源码是一样的，
            // 只不过由于这个方法源码的是把用户名和密码这些参数的名字是死的，所以我们重写了一下
            return authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(loginUser.getUsername(), loginUser.getPassword(), new ArrayList<>())
            );
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    // 成功验证后调用的方法
    // 如果验证成功，就生成token并返回
    @Override
    protected void successfulAuthentication(HttpServletRequest request,
                                            HttpServletResponse response,
                                            FilterChain chain,
                                            Authentication authResult) throws IOException, ServletException {

		// 查看源代码会发现调用getPrincipal()方法会返回一个实现了`UserDetails`接口的对象
		// 所以就是JwtUser啦
        JwtUser jwtUser = (JwtUser) authResult.getPrincipal();
        System.out.println("jwtUser:" + jwtUser.toString());
        List<String> roles = jwtUser.getAuthorities()
                                    .stream()
                                    .map(GrantedAuthority::getAuthority)
                                    .collect(Collectors.toList());
        String token = JwtTokenUtils.createToken(jwtUser.getUsername(), roles, false);
        response.setHeader(JwtTokenUtils.TOKEN_HEADER, token);
        // 返回创建成功的token
        // 但是这里创建的token只是单纯的token
        // 按照jwt的规定，最后请求的格式应该是 `Bearer token`
         response.setHeader(JwtTokenUtils.TOKEN_HEADER, token);
    }

	// 这是验证失败时候调用的方法
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
        response.getWriter().write("authentication failed, reason: " + failed.getMessage());
    }
}
```

这个过滤器中有几个比较重要的地方说明：

1. `UsernamePasswordAuthenticationToken`:从登录请求中获取{用户名，密码}，`AuthenticationManager`将使用它来认证登录帐户。
2. `authenticationManager.authenticate(authRequest)`:这段代码主要对用户进行认证，当执行这段代码的时候会跳到`UserDetailsServiceImpl`中去调用`loadUserByUsername()`方法来验证（我们在配置类中配置了`AuthenticationManager`使用自定义的`UserDetailsServiceImpl`去验证用户信息）。当验证成功后会返回一个完整填充的`Authentication`对象(包括授予的权限)，然后会去调用`successfulAuthentication`方法。

```java
package org.springframework.security.authentication;
 /**
  *尝试验证Authentication对象，如果成功，将返回一个完整填充的Authentication对象(包括授予的权限)。
  */
public interface AuthenticationManager {
	Authentication authenticate(Authentication authentication)
			throws AuthenticationException;
}
```



##### JWTAuthorizationFilter

###### **授权过滤器**

> 这个过滤器继承了 `BasicAuthenticationFilter`，主要用于处理**身份认证后才能访问的资源**，它会检查 HTTP 请求是否存在带有**正确令牌的 Authorization 标头并验证 token 的有效性**。
>
> 当用户使用 token 对需要权限才能访问的资源进行访问的时候，这个类是主要用到的，下面按照步骤来说一说每一步到底都做了什么。
>
> 1. 当用户使用系统返回的 token 信息进行登录的时候 ，会首先经过`doFilterInternal（）`方法，这个方法会从请求的Header中取出 token 信息，然后判断 token 信息是否为空以及 token 信息格式是否正确。
> 2. 如果请求头中有token 并且 token 的格式正确，则进行解析并判断 token 的有效性，然后会在 Spring Security **全局设置授权信息**`SecurityContextHolder.getContext().setAuthentication(getAuthentication(authorization));`



验证成功当然就是进行鉴权了，每一次需要权限的请求都需要检查该用户是否有该权限去操作该资源，当然这也是框架帮我们做的，那么我们需要做什么呢？很简单，只要告诉spring-security该用户是否已登录，是什么角色，拥有什么权限就可以了。 `JWTAuthenticationFilter`继承于`BasicAuthenticationFilter`，至于为什么要继承这个我也不太清楚了，这个我也是网上看到的其中一种实现，实在springSecurity苦手，不过我觉得不继承这个也没事呢（实现以下filter接口或者继承其他filter实现子类也可以吧）只要确保过滤器的顺序，`JWTAuthorizationFilter`在`JWTAuthenticationFilter`后面就没问题了。

```java
/**
 * 过滤器处理所有HTTP请求，并检查是否存在带有正确令牌的Authorization标头。例如，如果令牌未过期或签名密钥正确。
 *
 * @author shuang.kou
 */
public class JWTAuthorizationFilter extends BasicAuthenticationFilter {

    public JWTAuthorizationFilter(AuthenticationManager authenticationManager) {
        super(authenticationManager);
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws IOException, ServletException {

        String tokenHeader = request.getHeader(JwtTokenUtils.TOKEN_HEADER);
        // 如果请求头中没有Authorization信息则直接放行了
        if (tokenHeader == null || !tokenHeader.startsWith(JwtTokenUtils.TOKEN_PREFIX)) {
            chain.doFilter(request, response);
            return;
        }
        // 如果请求头中有token，则进行解析，并且设置认证信息
        SecurityContextHolder.getContext().setAuthentication(getAuthentication(tokenHeader));
        super.doFilterInternal(request, response, chain);
    }

    // 这里从token中获取用户信息并新建一个token
  private UsernamePasswordAuthenticationToken getAuthentication(String tokenHeader) {
        String token = tokenHeader.replace(JwtTokenUtils.TOKEN_PREFIX, "");
        String username = JwtTokenUtils.getUsername(token);
        List<SimpleGrantedAuthority> userRoles = JwtTokenUtils.getUserRole(token);
        if (StringUtils.isNotBlank(username)) {
            return new UsernamePasswordAuthenticationToken(username, null, userRoles);
        }
        return null;
    }
}
```

#### 获取当前用户

我们在讲过滤器的时候说过，当认证成功的用户访问系统的时候，它的认证信息会被设置在 Spring Security 全局中。那么，既然这样，我们在其他地方获取到当前登录用户的授权信息也就很简单了，通过`SecurityContextHolder.getContext().getAuthentication();`方法即可。

`SecurityContextHolder` 保存 `SecurityContext` 的信息，`SecurityContext `保存已通过认证的 `Authentication` 认证信息。

为此，我们实现了一个专门用来获取当前用户的类：

```java
/**
 * @author shuang.kou
 * 获取当前请求的用户
 */
@Component
public class CurrentUser {

    private final UserDetailsServiceImpl userDetailsService;

    public CurrentUser(UserDetailsServiceImpl userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    public JwtUser getCurrentUser() {
        return (JwtUser) userDetailsService.loadUserByUsername(getCurrentUserName());
    }

    /**
     * TODO:由于在JWTAuthorizationFilter这个类注入UserDetailsServiceImpl一致失败，
     * 导致无法正确查找到用户，所以存入Authentication的Principal为从 token 中取出的当前用户的姓名
     */
    private static String getCurrentUserName() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() != null) {
            return (String) authentication.getPrincipal();
        }
        return null;
    }
}
```



#### 配置SpringSecurity

到这里基本操作都写好啦，现在就需要我们将这些辛苦写好的“组件”组合到一起发挥作用了，那就需要配置了。需要开启一下注解`@EnableWebSecurity`然后再继承一下`WebSecurityConfigurerAdapter`就可以啦，springboot就是可以为所欲为~

> 1. 密码编码器 `BCryptPasswordEncoder`（存入数据库的密码需要被加密）。
> 2. 为` AuthenticationManager` 设置自定义的 `UserDetailsService`以及密码编码器；
> 3. 在 Spring Security 配置指定了哪些路径下的资源需要验证了的用户才能访问、哪些不需要以及哪些资源只能被特定角色访问；
> 4. 将我们自定义的两个过滤器添加到 Spring Security 配置中；
> 5. 将两个自定义处理权限认证方面的异常类添加到 Spring Security 配置中；

```java
@EnableWebSecurity
// 至于为什么要配置这个，嘿嘿，卖个关子
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    // 因为UserDetailsService的实现类实在太多啦，这里设置一下我们要注入的实现类
    @Qualifier("userDetailsServiceImpl")
    private UserDetailsService userDetailsService;

	// 加密密码的，安全第一嘛~
    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        // 设置自定义的userDetailsService以及密码编码器
        auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.cors().and()
            // 禁用 CSRF
            .csrf().disable()
                .authorizeRequests()
                // 测试用资源，需要验证了的用户才能访问
                .antMatchers("/tasks/**").authenticated()
                // 其他都放行了
                .anyRequest().permitAll()
                .and()
            	//添加自定义Filter
                .addFilter(new JWTAuthenticationFilter(authenticationManager()))
                .addFilter(new JWTAuthorizationFilter(authenticationManager()))
                // // 不需要session（不创建会话）
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
    }

    @Bean
    CorsConfigurationSource corsConfigurationSource() {
        final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", new CorsConfiguration().applyPermitDefaultValues());
        return source;
    }
}
```

#### AuthController

连配置都搞定了，那么问题来了，没有账号密码呢。所以写一个注册的控制器，这个就不是难事啦

```java
@RestController
@RequestMapping("/auth")
public class AuthController {

	// 为了减少篇幅就不写service接口了
    @Autowired
    private UserRepository userRepository;

    @Autowired
    private BCryptPasswordEncoder bCryptPasswordEncoder;

    @PostMapping("/register")
    public String registerUser(@RequestBody Map<String,String> registerUser){
        User user = new User();
        user.setUsername(registerUser.get("username"));
        // 记得注册的时候把密码加密一下
        user.setPassword(bCryptPasswordEncoder.encode(registerUser.get("password")));
        user.setRole("ROLE_USER");
        User save = userRepository.save(user);
        return save.toString();
    }
}
```

等等！注册是有了，那登录在哪呢？我们看一下`UsernamePasswordAuthenticationFilter`的源代码

```java
	public UsernamePasswordAuthenticationFilter() {
		super(new AntPathRequestMatcher("/login", "POST"));
	}
```

可以看出来默认是`/login`，所以登录直接使用这个路径就可以啦~当然也可以自定义 只需要在`JWTAuthenticationFilter`的构造方法中加入下面那一句话就可以啦

```java
 public JWTAuthenticationFilter(AuthenticationManager authenticationManager) {
        this.authenticationManager = authenticationManager;
        super.setFilterProcessesUrl("/auth/login");
    }
```

所以现在认证的路径统一了一下也是挺好的~看起来相当舒服了 注册：`/auth/register` 登录：`/auth/login`

#### TaskController

当然注册登录都完成了，那就是写一个测试控制器，一个需要权限的控制器去测试了，为了控制一下文章篇幅，写了一个比较简单的控制器作为演示

```
@RestController
@RequestMapping("/tasks")
public class TaskController {

    @GetMapping
    public String listTasks(){
        return "任务列表";
    }
    
    @PostMapping
    public String newTasks(){
        return "创建了一个新的任务";
    }
    
    @PutMapping("/{taskId}")
    public String updateTasks(@PathVariable("taskId")Integer id){
        return "更新了一下id为:"+id+"的任务";
    }
    
    @DeleteMapping("/{taskId}")
    public String deleteTasks(@PathVariable("taskId")Integer id){
        return "删除了id为:"+id+"的任务";
    }
}
```

#### 测试

到这里基本操作都做好了，可以去测试一下了，这里使用的是postman比较直观明了了。下面先注册一下账号，这里返回了插入了数据库之后的用户实体，所以注册是成功了

[![注册](https://camo.githubusercontent.com/060b2693ac29a6745c45fd73f7a1161b52050c31025bdfd84157d2b2fcb41723/68747470733a2f2f7778332e73696e61696d672e636e2f6c617267652f37666131353136326779316673717a65676e7a77786a323068343036346161362e6a7067)](https://camo.githubusercontent.com/060b2693ac29a6745c45fd73f7a1161b52050c31025bdfd84157d2b2fcb41723/68747470733a2f2f7778332e73696e61696d672e636e2f6c617267652f37666131353136326779316673717a65676e7a77786a323068343036346161362e6a7067) [![注册成功](https://user-images.githubusercontent.com/40262229/89514078-f4b38d80-d807-11ea-95b2-756124c94dca.png)](https://user-images.githubusercontent.com/40262229/89514078-f4b38d80-d807-11ea-95b2-756124c94dca.png)

接下来先测试一下先不登录访问一下我们的tasks，这里理所当然403无权限访问了 [![未登录403](https://user-images.githubusercontent.com/40262229/89514299-43f9be00-d808-11ea-9616-5ea90251c5a0.png)](https://user-images.githubusercontent.com/40262229/89514299-43f9be00-d808-11ea-9616-5ea90251c5a0.png)

然后终于能登录了，接下来尝试一下登录之后再次访问tasks看看是什么结果 [![登录](https://user-images.githubusercontent.com/40262229/89514440-6ee41200-d808-11ea-8720-117c31a9d1bf.png)](https://user-images.githubusercontent.com/40262229/89514440-6ee41200-d808-11ea-8720-117c31a9d1bf.png) 发送了登录请求之后查看响应头，能看到我们生成后的token，那就是登录成功了 [![登录成功](https://camo.githubusercontent.com/44685fb900e7737c3330d4ebff3cc4d5a3d9db5abd24a5960ee7a4af3f3ac2e7/68747470733a2f2f7778342e73696e61696d672e636e2f6c617267652f37666131353136326779316673717a6664706a63756a32313479306173337a302e6a7067)](https://camo.githubusercontent.com/44685fb900e7737c3330d4ebff3cc4d5a3d9db5abd24a5960ee7a4af3f3ac2e7/68747470733a2f2f7778342e73696e61696d672e636e2f6c617267652f37666131353136326779316673717a6664706a63756a32313479306173337a302e6a7067) 接下来只需要把该响应头添加到我们的请求头上去，这里需要把`Bearer[空格]`去掉，注意Bearer后的空格也要去掉，因为postman再选了BearerToken之后会自动在token前面再加一个Bearer [![设置请求头](https://user-images.githubusercontent.com/40262229/89514612-a94daf00-d808-11ea-8ea1-5ccfbec6b0c3.png)](https://user-images.githubusercontent.com/40262229/89514612-a94daf00-d808-11ea-8ea1-5ccfbec6b0c3.png) 再次访问一下tasks，结果理想当然的是成功啦~ [![成功请求](https://camo.githubusercontent.com/9009d9a528e7750db00b06072c73ee3ddacf993bf507723a517c17f0691e0027/68747470733a2f2f7778332e73696e61696d672e636e2f6c617267652f37666131353136326779316673717a6734393162346a3230757730386d7765732e6a7067)](https://camo.githubusercontent.com/9009d9a528e7750db00b06072c73ee3ddacf993bf507723a517c17f0691e0027/68747470733a2f2f7778332e73696e61696d672e636e2f6c617267652f37666131353136326779316673717a6734393162346a3230757730386d7765732e6a7067)

#### 初期总结

到这里我们一个基础的Springboot+SpringSecurity+Jwt已经搭建好了。 到这里一个基本的jwt已经实现了，但是总觉得哪里不对呢，写了这么多才只是登录成功了？权限管理呢？token管理呢？ 确实，看一下上面的代码。在实现`UserDetails`接口的时候写了一些奇怪的东西，就是这个`getAuthorities`方法啦。 这是springSecurity用来获取用户权限的方法。 在User类中写得`role`在这里就能排上用场了，这里将要实现的权限管理是基于角色的权限管理，再细颗粒的博主就不会啦哈哈哈，但还是可以看一看的。

```java
    // 写一个能直接使用user创建jwtUser的构造器
    public JwtUser(User user) {
        id = user.getId();
        username = user.getUsername();
        password = user.getPassword();
        // 这里只存储了一个角色的名字
        authorities = Collections.singleton(new SimpleGrantedAuthority(user.getRole()));
    }

    // 获取权限信息
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }
```

在springSecurity里建议角色名称改成`ROLE_`统一前缀的角色，例如`ROLE_USER,ROLE_ADMIN,ROLE_XXX`，至于为什么，后面会提到的，先不急，这里先这样干着。

#### 基于角色的权限管理

到底怎么基于角色的权限管理呢，这个只需要告诉权限框架该用户拥有什么角色就可以了。但是吧要怎么告诉框架我什么角色呢。我们理一下如何实现基于角色的权限管理的思路

1. 用户验证成功，根据用户名以及过期时间生成token
2. 权限验证，假如能从token中获取用户名就该token验证成功
3. 创建一个`UsernamePasswordAuthenticationToken`该token包含用户的角色信息，而不是一个空的`ArrayList`，查看一下源代码是有以下一个构造方法的。

```
	public UsernamePasswordAuthenticationToken(Object principal, Object credentials,
			Collection<? extends GrantedAuthority> authorities) {
		super(authorities);
		this.principal = principal;
		this.credentials = credentials;
		super.setAuthenticated(true); // must use super, as we override
	}
```

好了，接下来要怎么办呢，可以往上滚动一下，再看一眼`JWTAuthorizationFilter`中鉴权的逻辑

1. 检查请求头中是否存在`Authorization`，如果没有直接放，如果有就对token进行解析
2. 解析token，检查是否能从token中取出username，如果有就算成功了
3. 再根据该username创建一个`UsernamePasswordAuthenticationToken`对象就算成功了

可这发现根本就不关`role`什么事啊 [![沉思](https://user-images.githubusercontent.com/40262229/89514767-dac67a80-d808-11ea-9e5f-6e8e321bc77a.png)](https://user-images.githubusercontent.com/40262229/89514767-dac67a80-d808-11ea-9e5f-6e8e321bc77a.png)

```
	User user = userRepository.findByUsername("username");
	String role = user.getRole();
```

[![这里写图片描述](https://user-images.githubusercontent.com/40262229/89514900-09dcec00-d809-11ea-9886-368cae12bc3f.png)](https://user-images.githubusercontent.com/40262229/89514900-09dcec00-d809-11ea-9886-368cae12bc3f.png) 这还不简单！这不就完事了嘛！

可这不现实啊，每一次请求都要查询一下数据库这种开销这么大的操作当然是不行的。 思考一下，为什么是使用jwt而不是一个简简单单的`UUID`作为token呢。 jwt是由三部分组成的：

1. 第一部分我们称它为头部（header)
2. 第二部分我们称其为载荷（payload)
3. 第三部分是签证（signature)

我们这里准备使用它的第二部分，使用payload去存储我们的用户角色信息，由于第一第二部分都是公开的，任何人都能知道里面的信息，不建议存储一些比较敏感的数据，但是存放角色信息还是没有问题的。

##### 改造一下JwtTokenUtils

```
    // 添加角色的key
    private static final String ROLE_CLAIMS = "rol";

	// 修改一下创建token的方法
    public static String createToken(String username, String role, boolean isRememberMe) {
        long expiration = isRememberMe ? EXPIRATION_REMEMBER : EXPIRATION;
        HashMap<String, Object> map = new HashMap<>();
        map.put(ROLE_CLAIMS, role);
        return Jwts.builder()
                .signWith(SignatureAlgorithm.HS512, SECRET)
                // 这里要早set一点，放到后面会覆盖别的字段
                .setClaims(map)
                .setIssuer(ISS)
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
                .compact();
    }
	
```

##### 修改JWTAuthenticationFilter

```
    JwtUser jwtUser = (JwtUser) authResult.getPrincipal();
    boolean isRemember = rememberMe.get() == 1;

    String role = "";
    // 因为在JwtUser中存了权限信息，可以直接获取，由于只有一个角色就这么干了
    Collection<? extends GrantedAuthority> authorities = jwtUser.getAuthorities();
    for (GrantedAuthority authority : authorities){
        role = authority.getAuthority();
    }
    // 根据用户名，角色创建token
    String token = JwtTokenUtils.createToken(jwtUser.getUsername(), role, isRemember);
```

##### 修改JWTAuthorizationFilter

```java
    // 这里从token中获取用户信息并新建一个token
    private UsernamePasswordAuthenticationToken getAuthentication(String tokenHeader) {
        String token = tokenHeader.replace(JwtTokenUtils.TOKEN_PREFIX, "");
        String username = JwtTokenUtils.getUsername(token);
        String role = JwtTokenUtils.getUserRole(token);
        if (username != null){
            return new UsernamePasswordAuthenticationToken(username, null, 
                    Collections.singleton(new SimpleGrantedAuthority(role))
            );
        }
        return null;
    }
```

到这里基本上修改已经完成了，接下来就可以测试一下了，再配置一下springSecurity

```java
    protected void configure(HttpSecurity http) throws Exception {
        http.cors().and().csrf().disable()
                .authorizeRequests()
                // 测试用资源，需要验证了的用户才能访问
                .antMatchers("/tasks/**").authenticated()
                // 需要角色为ADMIN才能删除该资源
                .antMatchers(HttpMethod.DELETE, "/tasks/**").hasAuthority("ROLE_ADMIN")
                // 其他都放行了
                .anyRequest().permitAll()
                .and()
                .addFilter(new JWTAuthenticationFilter(authenticationManager()))
                .addFilter(new JWTAuthorizationFilter(authenticationManager()))
                // 不需要session
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
    }
```

##### 验证权限配置的 Controller

这个是 `UserControler` 主要用来检测权限配置是否生效。

`getAllUser（）`方法被注解` @PreAuthorize("hasAnyRole('ROLE_DEV','ROLE_PM')")`修饰代表这个方法可以被DEV，PM 这两个角色访问，而`deleteUserById()` 被注解` @PreAuthorize("hasAnyRole('ROLE_ADMIN')")`修饰代表只能被 ADMIN 访问。

```java
/**
 * @author shuang.kou
 */
@RestController
@RequestMapping("/api")
public class UserController {

    private final UserService userService;

    private final CurrentUser currentUser;

    public UserController(UserService userService, CurrentUser currentUser) {
        this.userService = userService;
        this.currentUser = currentUser;
    }

    @GetMapping("/users")
    @PreAuthorize("hasAnyRole('ROLE_DEV','ROLE_PM')")
    public ResponseEntity<Page<User>> getAllUser(@RequestParam(value = "pageNum", defaultValue = "0") int pageNum, @RequestParam(value = "pageSize", defaultValue = "10") int pageSize) {
        System.out.println("当前访问该接口的用户为：" + currentUser.getCurrentUser().toString());
        Page<User> allUser = userService.getAllUser(pageNum, pageSize);
        return ResponseEntity.ok().body(allUser);
    }


    @DeleteMapping("/user")
    @PreAuthorize("hasAnyRole('ROLE_ADMIN')")
    public ResponseEntity<User> deleteUserById(@RequestParam("username") String username) {
        userService.deleteUserByUserName(username);
        return ResponseEntity.ok().build();
    }
}
```

由于更新了token的生成方式，所以需要重新登录一下获取新的token

接下来可以测试了，继续使用postman对tasks资源进行删除，显然不行。 [![测试删除tasks](https://user-images.githubusercontent.com/40262229/89515118-46a8e300-d809-11ea-9736-0e17757eba80.png)](https://user-images.githubusercontent.com/40262229/89515118-46a8e300-d809-11ea-9736-0e17757eba80.png) 试试看获取该资源会怎么样，获取tasks资源是没有问题的。 [![测试获取tasks](https://camo.githubusercontent.com/9009d9a528e7750db00b06072c73ee3ddacf993bf507723a517c17f0691e0027/68747470733a2f2f7778332e73696e61696d672e636e2f6c617267652f37666131353136326779316673717a6734393162346a3230757730386d7765732e6a7067)](https://camo.githubusercontent.com/9009d9a528e7750db00b06072c73ee3ddacf993bf507723a517c17f0691e0027/68747470733a2f2f7778332e73696e61696d672e636e2f6c617267652f37666131353136326779316673717a6734393162346a3230757730386d7765732e6a7067)

**接下来重头戏来了** 先在数据库里手动将admin的角色改成`ROLE_ADMIN` 修改完之后再登录一下获取新的token，再去尝试一下删除tasks资源 啪啪啪 成功啦~ [![删除成功](https://user-images.githubusercontent.com/38010908/89498932-bc08b980-d7f1-11ea-92f6-273f356674ba.png)](https://user-images.githubusercontent.com/38010908/89498932-bc08b980-d7f1-11ea-92f6-273f356674ba.png)

到这里位置，基于角色的权限管理基本操作都做了一遍了，现在来解答一下上面挖的一些坑

1. 为什么要以`ROLE_`作为前缀
2. springSecurity中配置的注解`@EnableGlobalMethodSecurity(prePostEnabled = true)`是干嘛用的

第一个问题： 我们在springSecurity中配置了这样一句，意思是只有角色为`ROLE_ADMIN`才有权限删除该资源 `.antMatchers(HttpMethod.DELETE, "/tasks/**").hasAuthority("ROLE_ADMIN")` 假如我们使用了`ROLE_`作为前缀就能这样写了~是不是很方便呢哈哈 `.antMatchers(HttpMethod.DELETE, "/tasks/**").hasRole("ADMIN")`

第二个问题： 除了在springSecurity中配置访问权限，还有这种方式啦，也是十分的方便呢。但是如果要使用这用的方式就需要配置上那个注解啦，不然虽然写了下面的注解但是是不会生效的。

```
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public String newTasks(){
        return "创建了一个新的任务";
    }
```

#### 异常相关

##### AccessDeniedHandler

`JWTAccessDeniedHandler`实现了`AccessDeniedHandler`主要用来解决认证过的用户访问需要权限才能访问的资源时的异常。

```java
/**
 * @author shuang.kou
 * AccessDeineHandler 用来解决认证过的用户访问需要权限才能访问的资源时的异常
 */
public class JWTAccessDeniedHandler implements AccessDeniedHandler {
    /**
     * 当用户尝试访问需要权限才能的REST资源而权限不足的时候，
     * 将调用此方法发送401响应以及错误信息
     */
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException {
        accessDeniedException = new AccessDeniedException("Sorry you don not enough permissions to access it!");
        response.sendError(HttpServletResponse.SC_FORBIDDEN, accessDeniedException.getMessage());
    }
}
```

##### AuthenticationEntryPoint

`JWTAuthenticationEntryPoint` 实现了 `AuthenticationEntryPoint` 用来解决匿名用户访问需要权限才能访问的资源时的异常

当然会有一些需求是要统一处理被403响应的事件，很简单，只要新建一个类`JWTAuthenticationEntryPoint`实现一下接口`AuthenticationEntryPoint`就可以了

```java
public class JWTAuthenticationEntryPoint implements AuthenticationEntryPoint {
    
      /**
     * 当用户尝试访问需要权限才能的REST资源而不提供Token或者Token过期时，
     * 将调用此方法发送401响应以及错误信息
     */
    @Override
    public void commence(HttpServletRequest request,
                         HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {

        response.setCharacterEncoding("UTF-8");
        response.setContentType("application/json; charset=utf-8");
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        String reason = "统一处理，原因："+authException.getMessage();
        response.getWriter().write(new ObjectMapper().writeValueAsString(reason));
    }
}
```

再配置一下springSecurity

```java
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.cors().and().csrf().disable()
                .authorizeRequests()
                // 测试用资源，需要验证了的用户才能访问
                .antMatchers("/tasks/**").authenticated()
                .antMatchers(HttpMethod.DELETE, "/tasks/**").hasRole("ADMIN")
                // 其他都放行了
                .anyRequest().permitAll()
                .and()
                .addFilter(new JWTAuthenticationFilter(authenticationManager()))
                .addFilter(new JWTAuthorizationFilter(authenticationManager()))
                // 不需要session
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                // 加一句这个
                .exceptionHandling().authenticationEntryPoint(new JWTAuthenticationEntryPoint());
    }
```

这是统一处理后的结果 [![这里写图片描述](https://camo.githubusercontent.com/606ac24b6d93eb5e1bd33fdae0e6678f8014176001ae81fc1a3546f10ea56e5a/68747470733a2f2f7778342e73696e61696d672e636e2f6c617267652f37666131353136326779316673717a686272616b786a32313676303461676c6f2e6a7067)](https://camo.githubusercontent.com/606ac24b6d93eb5e1bd33fdae0e6678f8014176001ae81fc1a3546f10ea56e5a/68747470733a2f2f7778342e73696e61696d672e636e2f6c617267652f37666131353136326779316673717a686272616b786a32313676303461676c6f2e6a7067)





## java8新特性

参考文档：https://blog.csdn.net/Dug_Zhang/article/details/108238082

### 一、时间

> java.time包中的是类是不可变且线程安全的。新的时间及日期API位于java.time中，下面是一些关键类

#### **1、常用类的概述与功能介绍**

> - **Instant类**
>
>  Instant类对时间轴上的单一瞬时点建模,可以用于记录应用程序中的事件时间戳,在之后学习的类型转换中,均可以使用Instant类作为中间类完成转换.
>
> - **Duration类**
>
> Duration类表示秒或纳秒时间间隔,适合处理较短的时间,需要更高的精确性.
>
> - **Period类**
>
> Period类表示一段时间的年、月、日.
>
> - **LocalDate类**
>
> LocalDate是一个不可变的日期时间对象,表示日期,通常被视为年月日.
>
> - **LocalTime类**
>
> LocalTime是一个不可变的日期时间对象,代表一个时间,通常被看作是小时-秒,时间表示为纳秒精度.
>
> - **LocalDateTime类**
>
> LocalDateTime是一个不可变的日期时间对象,代表日期时间,通常被视为年-月-日-时-分-秒.
>
> - **ZonedDateTime类**
>
> ZonedDateTime是具有时区的日期时间的不可变表示,此类存储所有日期和时间字段,精度为纳秒,时区为区域偏移量,用于处理模糊的本地日期时间。

##### **（1）now方法**

  Date-Time API中的所有类均**生成不可变实例**,它们是线程安全的,并且这些类**不提供公共构造函数**,也就是说没办法通过new的方式直接创建,需要采用**工厂方法**加以实例化.

 now方法可以根据**当前日期或时间**创建实例.

![image-20201022174708156](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201022174708.png)

###### （i）**各个类封装时间所表示的特点**

> - Instant封装的时间为祖鲁时间并非当前时间. 祖鲁时间也是格林尼治时间,也就是国际标准时间.
> - LocalDate封装的只有年月日,没有时分秒,格式为yyyy-MM-dd.
> - LocalTime封装的只有时分秒,没有年月日,格式为hh:mm:ss.sss,最后的sss是纳秒.
> - LocalDateTime将LocalDate和LocalTime合二为一,在年月日与时分秒中间使用T作为分隔.
> - ZonedDateTime中封装了年月日时分秒,以及UTC(祖鲁时间)偏移量,并且还有一个地区名.+8:00代表中国是东八区,时间比国际标准时间快八小时.

##### （2）**年月日 的枚举信息.**

1. Year类(表示年)
2. YearMonth类(表示年月)
3. MonthDay类(表示月日)

```java
package com.itheima.time;
 
import java.time.*;
public class Java8TimeClassMethodDemo2 {
  public static void main(String[] args) {
    //初始化Year的实例化对象.
    Year year = Year.now();
    //初始化YearMonth的实例化对象
    YearMonth month = YearMonth.now();
    //初始化MonthDay的实例化对象.
    MonthDay day = MonthDay.now();
 }
}
```

![image-20201022175446304](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201022175446.png)

##### （3）**of方法**

  of方法可以根据**给定的参数生成对应的日期/时间**对象,基本上每个基本类都有of方法用于生成的对应的对象,而且重载形式多变,可以根据不同的参数生成对应的数据.

```java
package com.itheima.time;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
public class Java8TimeClassMethodDemo3 {
  public static void main(String[] args) {
    //初始化2018年8月8日的LocalDate对象.
    LocalDate date = LocalDate.of(2018, 8, 8);
    System.out.println("LocalDate:" + date);
    /*
    初始化晚上7点0分0秒的LocalTime对象.
    LocalTime.of方法的重载形式有以下几种,可以根据实际情况自行使用.
    LocalTime of(int hour, int minute) -> 根据小时/分钟生成对象.
    LocalTime of(int hour, int minute, int second) -> 根据小时/分钟/秒生成对象.
    LocalTime of(int hour, int minute, int second, int nanoOfSecond) ->    根据小时/分钟/毫秒/纳秒生成对象.
    注意:如果秒和纳秒为0的话,那么默认不会封装这些数据,只显示小时和分钟.
    */
    LocalTime time = LocalTime.of(19, 0, 0, 0);
    System.out.println("LocalTime:" + time);
    /*
    初始化2018年8月8日下午7点0分的LocalDateTime对象.
    LocalDateTime.of方法的重载形式有以下几种,可以根据事情自行使用.
    LocalDateTime of(int year, int month, int dayOfMonth, int hour, int
minute, int second, int nanoOfSecond) -> 根据年/月/日/时/分/秒生成对象.
    LocalDateTime of(int year, int month, int dayOfMonth, int hour, int
minute) -> 根据年/月/日/时/分生成对象.
    注意:LocalDateTime of(LocalDate date, LocalTime time)方法可以将一个
LocalDate对象和一个LocalTime对象合并封装为一个LocalDateTime对象.
    */
    LocalDateTime.of(2018, 8, 8, 19, 0, 0, 0);
    LocalDateTime localDateTime = LocalDateTime.of(date, time);
    System.out.println("LocalDateTime:" + localDateTime);
 }
}
```

##### （4）**LocalDateTime添加时区信息**

在学习ZonedDateTime的时候,发现了这个对象里面封装的不仅有时间日期,并且还有偏移量+时区,那么时区如何在Java中获取呢,通过提供的一个**类ZoneId的getAvailableZoneIds**方法可以获取到一个Set集合,集合中封装了600个时区.

```java
//获取所有的时区信息
    Set<String> availableZoneIds = ZoneId.getAvailableZoneIds();
    for (String zoneId : availableZoneIds) {
      System.out.println(zoneId);
   }
```

![image-20201022200403430](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201022200403.png)

我们可以通过给LocalDateTime添加时区信息来查看到不同时区的时间,比如说LocalDateTime中当前封装的是上海时间,那么想知道在此时此刻,纽约的时间是什么,就可以将纽约的时区Id添加进去,就可以查看到了,方式如下.

同样也提供了获取当前系统默认的时区的方式**systemDefault()**方法.

```java
//获取当前系统默认的时区信息
    ZoneId zoneId = ZoneId.systemDefault();
    System.out.println(zoneId);
```

1. 封装时间LocalDateTime并添加时区信息.
2. 更改时区信息查看对应时间.

```java
package com.itheima.time;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
/**
* 为LocalDateTime添加时区信息.
*/
public class Java8TimeClassMethodDemo5 {
  public static void main(String[] args) {
    //1.封装LocalDateTime对象,参数自定义 -> 2018年11月11日 8点54分38秒
    LocalDateTime time = LocalDateTime.of(2018, 11, 11, 8, 54, 38);
    //2.封装完成后的time对象只是封装的是一个时间,并没有时区相关的数据,所以添加时区到对象中,使用atZone方法.
    ZonedDateTime zonedDateTime =time.atZone(ZoneId.of("Asia/Shanghai"));
    System.out.println("Asia/Shanghai的时间是:" + zonedDateTime);
    //3.更改时区查看其它时区的当前时间,通过withZoneSameInstant方法即可更改.
    ZonedDateTime otherZonedTime =
    zonedDateTime.withZoneSameInstant(ZoneId.of("Asia/Tokyo"));
    System.out.println("在同一时刻,Asia/Tokyo的时间是:" + otherZonedTime);
 }
}
```

![image-20201022200942667](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201022200943.png)



##### （5）**Month枚举类的使用**

 java.time包中引入了Month的枚举,Month中包含标准日历中的12个月份的常量(从JANURAY到DECEMEBER)也提供了一些方便的方法供我们使用.推荐在**初始化LocalDate**和LocalDateTime对象的时候,月份的参数**使用枚举的方式传入**,这样更简单易懂而且不易出错,因为如果是老的思维,Calendar传入0的话,那么会出现异常.

```java
/**
* Month枚举类的使用.
*/
public class Java8TimeClassMethodDemo6 {
  public static void main(String[] args) {
    //在初始化LocalDate和LocalDateTime的时候,月份的参数传入枚举类(2011年5月15日11时11分11秒)
    LocalDateTime.of(2011, Month.JUNE,15,11,11,11);
    //of方法可以根据传入的数字返回对应的月份.
    Month month = Month.of(12);
    System.out.println(month);
   
 }
}
```

![image-20201022201333222](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201022201333.png)

##### （6）**plusXX方法**

>  想要修改某个日期/时间对象的现有实例时,我们可以使用plus和minus方法来完成操作.Java8中日期时间相关的API中的所有实例都是不可改变的,一旦创建LocalDate,LocalTime,LocalDateTime就无法修改他们(类似于String),这对于线程安全非常有利.

LocalDate中定义了多种对日期进行增减操作的方法

- LocalDate plusDays(long days) 增加天数
- LocalDate plusWeeks(long weeks) 增加周数
- LocalDate plusMonths(long months) 增加月数
- LocalDate plusYears(long years) 增加年数

LocalTime中定义了多种对时间进行增减操作的方法

- LocalTime plusNanos(long nanos) 增加纳秒
- LocalTime plusSeconds(long seconds) 增加秒
- LocalTime plusMinutes(long minutes) 增加分钟
- LocalTime plusHours(long hours) 增加小时

```java
package com.itheima.time.plus;
import org.junit.Test;
import java.time.LocalDate;
import java.time.Month;
public class Java8TimeMethodPlusDemo1 {
  public static void main(String[] args) {
    //封装LocalDate对象参数为2016年2月13日.
    LocalDate date = LocalDate.of(2016, Month.FEBRUARY, 13);
    //计算当前时间的4天后的时间.
    LocalDate plusDaysTime = date.plusDays(4);
    //计算当前时间的周后的时间.
    LocalDate plusWeeksTime = date.plusWeeks(3);
    //计算当前时间的5个月后的时间.
    LocalDate plusMonthsTime = date.plusMonths(5);
    //计算当前时间的2年后的时间.
    LocalDate plusYearsTime = date.plusYears(2);
    System.out.println("当前的时间是:"+date);
    System.out.println("4天后的时间是:"+plusDaysTime);
    System.out.println("3周后的时间是:"+plusWeeksTime);
    System.out.println("5个月后的时间是:"+plusMonthsTime);
    System.out.println("2年后的时间是:"+plusYearsTime);
 }
}
```

![image-20201022202018707](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201022202019.png)

```java
package com.itheima.time.plus;
import java.time.LocalTime;
public class Java8TimeMethodPlusDemo2 {
  public static void main(String[] args) {
    //封装LocalTime对象参数为8时14分39秒218纳秒.
    LocalTime time = LocalTime.of(8, 14, 39, 218);
    //计算当前时间500纳秒后的时间.
    LocalTime plusNanosTime = time.plusNanos(500);
    //计算当前时间45秒后的时间.
    LocalTime plusSecondsTime = time.plusSeconds(45);
    //计算当前时间19分钟后的时间.
    LocalTime plusMinutesTime = time.plusMinutes(19);
    //计算当前时间3小时后的时间.
    LocalTime plusHoursTime = time.plusHours(3);
    System.out.println("当前的时间是:" + time);
    System.out.println("45秒后的时间是:" + plusSecondsTime);
    System.out.println("19分钟后的时间是:" + plusMinutesTime);
    System.out.println("500纳秒后的时间是:" + plusNanosTime);
    System.out.println("3小时后的时间是:" + plusHoursTime);
 }
}
```

![img](https://img-blog.csdnimg.cn/20200826161058126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0R1Z19aaGFuZw==,size_16,color_FFFFFF,t_70)

>    *本文中都是使用plusXXX的方法进行演示,实际上也有对应的减少方法,**以minus开头**的方法对应的即为减少,实际上**minus**方法调用的也是plus方法,只不过传入的参数是负数.*

##### （7）**plus和minus方法的应用**

###### （i）**plus(TemporaAmount amountToAdd)**









#### 获取本（天周月季度年）的开始、结束时间

##### Java获取本周的开始时间与结束时间

```java
/**
 * @Author: umizhang
 * @Title: getFirstDayOfWeek
 * @Description TODO 获取本周的第一天或最后一天
 * @Date: 2019/7/23 10:59
 * @Param: [today, isFirst: true 表示开始时间，false表示结束时间]
 * @return: java.lang.String
 * @Exception:
 */
public static String getStartOrEndDayOfWeek(LocalDate today, Boolean isFirst){
    LocalDate resDate = LocalDate.now();
    if (today == null) {
        today = resDate;
    }
    DayOfWeek week = today.getDayOfWeek();
    int value = week.getValue();
    if (isFirst) {
        resDate = today.minusDays(value - 1);
    } else {
        resDate = today.plusDays(7 - value);
    }
    return resDate.toString();
}

```

##### Java获取本月的开始时间与结束时间

```java
/**
 * @Author: umizhang
 * @Title: getStartOrEndDayOfMonth
 * @Description TODO 获取本月的第一天或最后一天
 * @Date: 2019/7/23 11:50
 * @Param: [today, isFirst: true 表示开始时间，false表示结束时间]
 * @return: java.lang.String
 * @Exception:
 */
public static String getStartOrEndDayOfMonth(LocalDate today, Boolean isFirst){
    LocalDate resDate = LocalDate.now();
    if (today == null) {
        today = resDate;
    }
    Month month = today.getMonth();
    int length = month.length(today.isLeapYear());
    if (isFirst) {
        resDate = LocalDate.of(today.getYear(), month, 1);
    } else {
        resDate = LocalDate.of(today.getYear(), month, length);
    }
    return resDate.toString();
}

```

##### Java获取本季度的开始时间与结束时间

```java
/**
 * @Author: umizhang
 * @Title: getStartOrEndDayOfQuarter
 * @Description TODO 获取本季度的第一天或最后一天
 * @Date: 2019/7/23 13:46
 * @Param: [today, isFirst: true 表示开始时间，false表示结束时间]
 * @return: java.lang.String
 * @Exception:
 */
public static String getStartOrEndDayOfQuarter(LocalDate today, Boolean isFirst){
    LocalDate resDate = LocalDate.now();
    if (today == null) {
        today = resDate;
    }
    Month month = today.getMonth();
    Month firstMonthOfQuarter = month.firstMonthOfQuarter();
    Month endMonthOfQuarter = Month.of(firstMonthOfQuarter.getValue() + 2);
    if (isFirst) {
        resDate = LocalDate.of(today.getYear(), firstMonthOfQuarter, 1);
    } else {
        resDate = LocalDate.of(today.getYear(), endMonthOfQuarter, endMonthOfQuarter.length(today.isLeapYear()));
    }
    return resDate.toString();
}

```

##### Java获取本年的开始时间与结束时间

```java
/**
 * @Author: umizhang
 * @Title: getStartOrEndOfYear
 * @Description TODO 获取本年的第一天或最后一天
 * @Date: 2019/7/23 13:48
 * @Param: [today, isFirst: true 表示开始时间，false表示结束时间]
 * @return: java.lang.String
 * @Exception:
 */
public static String getStartOrEndDayOfYear(LocalDate today, Boolean isFirst){
    LocalDate resDate = LocalDate.now();
    if (today == null) {
        today = resDate;
    }
    if (isFirst) {
        resDate = LocalDate.of(today.getYear(), Month.JANUARY, 1);
    } else {
        resDate = LocalDate.of(today.getYear(), Month.DECEMBER, Month.DECEMBER.length(today.isLeapYear()));
    }
    return resDate.toString();
}

```

### 二、stream流

#### 1、根据stream优雅的统计、排序处理list数据

##### （1）计算总量

```java
(int)list.stream().mapToInt(n -> n.getClickNum()).summaryStatistics().getSum()
(int)list.stream().mapToInt(n -> n.getReplyNum()).summaryStatistics().getSum()
```

##### （2）获取最近时间

```java
long date = list.stream().filter(x -> x!=null).filter(y -> y.getNewReplyTime()!=null).mapToLong(n -> n.getNewReplyTime().getTime()).summaryStatistics().getMax();
if(date>0) forumPlateVo.setNewReplyTime(new Date(date));
```

##### （3）根据点击量排序

```java
list = list.stream().sorted(Comparator.comparing(ForumPlateVo::clickNum).reversed()).collect(Collectors.toList());
```

##### （4）group by 获取size

```java
int count = list.stream().collect(groupingBy(ActivityLottery::getOpenId)).size();
```

#### 2、基于Java的的Stream分页实现

```java
List<AccessAreaVo> areaVo = vos.stream()
				.skip(pageable.getPageSize() * (pageable.getPageNumber() - 1))
				.limit(pageable.getPageSize()).collect(Collectors.toList());
```



#### 3、java8根据某字段顺序和倒序排列

![image-20200928003453357](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200928003503.png)

#### 4、Stream.distinct() 列表去重示例

>  在这篇文章里，我们将提供Java8 Stream distinct（）示例。 distinct（）返回由该流的不同元素组成的流。distinct（）是Stream接口的方法。distinct（）使用hashCode（）和equals（）方法来获取不同的元素。因此，我们的类必须实现hashCode（）和equals（）方法。如果distinct（）正在处理有序流，那么对于重复元素，将保留以遭遇顺序首先出现的元素，并且以这种方式选择不同元素是稳定的。在无序流的情况下，不同元素的选择不一定是稳定的，是可以改变的。distinct（）执行有状态的中间操作。在有序流的并行流的情况下，保持distinct（）的稳定性是需要很高的代价的，因为它需要大量的缓冲开销。如果我们不需要保持遭遇顺序的一致性，那么我们应该可以使用通过BaseStream.unordered（）方法实现的无序流。

##### 方法的声明如下：

```java
Stream<T> distinct()
```

它是Stream接口的方法。在此示例中，我们有一个包含重复元素的字符串数据类型列表

DistinctSimpleDemo.java

![image-20200804152847596](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804152849.png)

![image-20200804152911838](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804152911.png)

##### Stream.distinct() with List of Objects

在此示例中，我们有一个Book对象列表。 为了对列表进行去重，该类将重写hashCode（）和equals（）。

Book.java

![image-20200804153100208](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804153100.png)

![image-20200804153132296](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804153132.png)

##### Distinct by Property

distinct（）不提供按照属性对对象列表进行去重的直接实现。它是基于hashCode（）和equals（）工作的。如果我们想要按照对象的属性，对对象列表进行去重，我们可以通过其它方法来实现。如下代码段所示：

```java
static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {
	Map<Object,Boolean> seen = new ConcurrentHashMap<>();
	return t -> seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;

}
```

上面的方法可以被Stream接口的 filter()接收为参数，如下所示：

```java
list.stream().filter(distinctByKey(b -> b.getName()));
```

![image-20200804153603354](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804153603.png)

distinctByKey()方法返回一个使用*ConcurrentHashMap* 来维护先前所见状态的 *Predicate* 实例，如下是一个完整的使用对象属性来进行去重的示例。

![image-20200804153634579](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804153634.png)

##### 根据set中元素不允许重复的特性去重

```java
List<User> users = list.stream().collect(
    Collectors.collectingAndThen(Collectors.toCollection(
        () -> new TreeSet<>(Comparator.comparing(User::getId))), ArrayList::new));

```

这种去重方式通过set中元素不重复的特性，重写Comparator方法以规定的成员变量为条件。这种方法不改变实体，正好符合需求。

#### 5、List与String进行互转

```java
public class ListChangeString {
 
    public static void main(String[] args) {
 
        List<String> list1 = Arrays.asList("文学","小说","历史","言情","科幻","悬疑");
 
        List<String> list2 = Arrays.asList("文学","小说","历史","言情","科幻","悬疑");
 
        //方案一：使用String.join()函数，给函数传递一个分隔符合一个迭代器，一个StringJoiner对象会帮助我们完成所有的事情
        String string1 = String.join("-",list1);
 
        System.out.println(string1);
 
        //方案二：采用流的方式来写
        String string2 = list2.stream().collect(Collectors.joining("-"));
 
        System.out.println(string2);
    }
}
```

```java
public class StringChangeList {
    public static void main(String[] args) {
 
        String string= "文学-小说-历史-言情-科幻-悬疑";
 
        List<String> list = Arrays.asList(string.split("-")).stream().map(s -> String.format(s.trim())).collect(Collectors.toList());
 
        System.out.println(list);
    }
}
```

#### 6、Java 8 flatMap示例

在Java 8中，Stream可以容纳不同的数据类型，例如：

> Stream<String[]>
> Stream<Set<String>>
> Stream<List<String>>
> Stream<List<Object>>

但是，Stream操作（filter，sum，distinct ...）和collectors不支持它，所以我们需要使用[flatMap（）](http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#flatMap-java.util.function.Function-)进行以下转换：

Stream<String[]>		-> flatMap ->	Stream<String>
Stream<Set<String>>	-> flatMap ->	Stream<String>
Stream<List<String>>	-> flatMap ->	Stream<String>
Stream<List<Object>>	-> flatMap ->	Stream<Object>

如何`flatMap()`工作：

```java
{{1,2}，{3,4}，{5,6}}  - > flatMap  - > {1,2,3,4,5,6}

{'a'，'b'}，{'c'，'d'}，{'e'，'f'}}  - > flatMap  - > {'a'，'b'，'c' D”， 'E'， 'F'}
```

###### Stream + String [] + flatMap

![image-20200915152340433](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915152340.png)

1.2在上面的例子中，我们应该使用`flatMap()`转换`Stream<String[]>`来`Stream<String>`。

![image-20200915152411179](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915152411.png)

###### Stream + Set + flatMap

![image-20200915152442513](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915152442.png)

2.2 `flatMap()`和`Set`例子。

![image-20200915152515600](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915152515.png)

![image-20200915152524401](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915152524.png)

###### Stream + Primitive + flatMapToInt

![image-20200915152603049](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915152603.png)

#### 7、Java8合并List（Map），为一个大Map

![](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915153956.png)

#### 8、大数据量List分批处理切割

https://blog.csdn.net/fzy629442466/article/details/84765070?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control

##### （1） Stream 大数据量List分批处理

```java
//按每3个一组分割
private static final Integer MAX_NUMBER = 3;

/**
* 计算切分次数
*/
private static Integer countStep(Integer size) {
	return (size + MAX_NUMBER - 1) / MAX_NUMBER;
}

public static void main(String[] args) {
      List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
      int limit = countStep(list.size());
      //方法一：使用流遍历操作
      List<List<Integer>> mglist = new ArrayList<>();
      Stream.iterate(0, n -> n + 1).limit(limit).forEach(i -> {
          mglist.add(list.stream().skip(i * MAX_NUMBER).limit(MAX_NUMBER).collect(Collectors.toList()));
      });

      System.out.println(mglist);

      //方法二：获取分割后的集合
      List<List<Integer>> splitList = Stream.iterate(0, n -> n + 1).limit(limit).parallel().map(a -> list.stream().skip(a * MAX_NUMBER).limit(MAX_NUMBER).parallel().collect(Collectors.toList())).collect(Collectors.toList());
      
      System.out.println(splitList);
}

```

##### （2）google guava对List进行分割

```java
//使用guava对list进行分割
List<User> users = userService.findAll();
//按每50个一组分割
List<List<User>> parts = Lists.partition(users, 50);
parts.stream().forEach(list -> {
    process(list);
});
```

##### （3）用apache common collection

```java
List<Integer> intList = Lists.newArrayList(1, 2, 3, 4, 5, 6, 7, 8);
List<List<Integer>> subs = ListUtils.partition(intList, 3);
```

##### （4）手写将一个List等分成n个list

```java
public static <T> List<List<T>> averageAssign(List<T> source, int n) {
    List<List<T>> result = new ArrayList<>();
	//(先计算出余数)
    int remainder = source.size() % n;  
    //然后是商
    int number = source.size() / n;  
	//偏移量
    int offset = 0;
    for (int i = 0; i < n; i++) {
        List<T> value;
        if (remainder > 0) {
            value = source.subList(i * number + offset, (i + 1) * number + offset + 1);
            remainder--;
            offset++;
        } else {
            value = source.subList(i * number + offset, (i + 1) * number + offset);
        }
        result.add(value);
    }
    return result;
}

```

#### 9、排序分组后取第一条

https://blog.csdn.net/qq_34557770/article/details/96487576?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control

```java
collectingAndThen() 收集之后继续做一些处理。
list多个字段去重排
List nNullImei = newSearch.stream().filter(x -> collect.contains(x.getDataImsi()))
.filter(x -> StringUtils.isNotEmpty(x.getDataImei()))
.collect(Collectors.collectingAndThen(Collectors.toCollection(
() -> new TreeSet<>(Comparator.comparing(x -> x.getDataImei() + “#” + x.getDataImsi() ))),
ArrayList::new));



import com.google.common.collect.Lists;
 
import java.util.ArrayList;
import java.util.Map;
import java.util.stream.Collectors;
 
import static java.util.stream.Collectors.groupingBy;
 
public class Test {
    public static void main(String[] args) {
        Employee employee1 = new Employee("松皇","总经理","100000000000");
        Employee employee2 = new Employee("小赵","助理","100000");
        Employee employee3 = new Employee("小智","打杂","20000");
        Employee employee4 = new Employee("小李","打杂","20000");
        ArrayList<Employee> employees = Lists.newArrayList(employee1, employee2, employee3, employee4);
        Map<String, Employee> collect =
                employees.stream().collect(groupingBy(Employee::getRank, Collectors.collectingAndThen(Collectors.toList(), value -> value.get(0))));
        System.out.println(collect);
    }
}
```



### 三、CompletableFuture

#### 1.并发与并行

![img](https://img-blog.csdnimg.cn/20190126111021173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTcyNTI1,size_16,color_FFFFFF,t_70)

#### 2.同步API与异步API

> **同步API**：你调用了某个方法，调用方在被调用方运行的过程中会等待，被调用方运行结束返回，调用方取得被调用方的返回值并继续运行。即使调用方和被调用方在不同的线程中运行，调用方还是需要等待被调用方结束运行，这就是阻塞式调用。
> **异步API**：你调用了某个方法，被调用方直接返回，或者至少在被调用方计算完成之前，将它剩余的计算任务交给另一个线程去做，该线程和调用方是异步的，这就是非阻塞式调用。



#### 3、Future

> Future接口的方法介绍如下：
>
> - boolean **cancel** (boolean mayInterruptIfRunning) 取消任务的执行。参数指定是否立即中断任务执行，或者等等任务结束
> - boolean **isCancelled** () 任务是否已经取消，任务正常完成前将其取消，则返回 true
> - boolean **isDone** () 任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true
> - V **get** () throws InterruptedException, ExecutionException 等待任务执行结束，然后获得V类型的结果。InterruptedException 线程被中断异常， ExecutionException任务执行异常，如果任务被取消，还会抛出CancellationException
> - V **get** (long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException 同上面的get功能一样，多了设置超时时间。参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计 算超时，将抛出TimeoutException
>
> 一般情况下，我们会结合Callable和Future一起使用，通过ExecutorService的submit方法执行Callable，并返回Future。

```java
public interface Future<V> {
 
    boolean cancel(boolean mayInterruptIfRunning);
 
    boolean isCancelled();
 
    boolean isDone();
 
    V get() throws InterruptedException, ExecutionException;
 
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

![image-20210209163111686](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210209163112.png)

比起future.get()，其实更推荐使用get (long timeout, TimeUnit unit) 方法，设置了超时时间可以防止程序无限制的等待future的结果。

###### 3.1、Future模式的缺点

- Future虽然可以实现获取异步执行结果的需求，但是它没有提供通知的机制，我们无法得知Future什么时候完成。
- 要么使用阻塞，在future.get()的地方等待future返回的结果，这时又变成同步操作。要么使用isDone()轮询地判断Future是否完成，这样会耗费CPU的资源。

#### 4、CompletableFuture来实现异步调用

Java 8新增的CompletableFuture类正是吸收了所有Google Guava中ListenableFuture和SettableFuture的特征，还提供了其它强大的功能，让Java拥有了完整的非阻塞编程模型：Future、Promise 和 Callback(在Java8之前，只有无Callback 的Future)。

CompletableFuture能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。

CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过**thenAccept、thenApply、thenCompose**等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。

CompletableFuture 提供了四个静态方法来创建一个异步操作。

```java
public static CompletableFuture<Void> runAsync(Runnable runnable)
public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)
```

没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。

- runAsync方法**不支持返回值**。
- supplyAsync**可以支持返回值**。



![image-20210224212124239](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210224212125.png)





```java
 private double calculatePrice(String product) {
        delay();
        return new Random().nextDouble() * product.charAt(0) + product.charAt(1);
    }

    public Future<Double> getPriceAsync(String product) {
        //创建 CompletableFuture对象，它会包含计算的结果
        CompletableFuture<Double> futurePrice = new CompletableFuture<>();
        //在另一个线程中以异步方式执行计算
        new Thread( () -> {
            System.out.println("异步做别的计算");
            try {
                //如果价格计算正常结束，完成 Future 操作并设置商品价格
                double price = calculatePrice(product);
                //需长时间计算的任务结束并得出结果时，设置Future 的返回值
                futurePrice.complete(price);

            } catch (Exception ex) {
                //否则就抛出导致失败的异常，完成这次 Future 操作
                futurePrice.completeExceptionally(ex);
            }
        }).start();
        //无需等待还没结束的计算，直接返回 Future 对象
        return futurePrice;
    }
        public double getPriceDirect(Long start,String product) {
        double price = calculatePrice(product);
        System.out.println("当前线程去查询羽毛球拍的价格,耗时："+ (System.nanoTime() - start) / 1_000_000 + " msecs");
        return price;
    }
    @Test
    public void test2() {
        long start = System.nanoTime();
        Future<Double> futurePrice = getPriceAsync("羽毛球");
        long invocationTime = ((System.nanoTime() - start) / 1_000_000);
        System.out.println("异步去查询羽毛球的价格，耗时： " + invocationTime + " msecs");
        // 执行更多任务，比如查询其他商店
        double priceDirect = getPriceDirect(start, "羽毛球拍");
        // 在计算商品价格的同时
        try {
            double priceAsync = futurePrice.get();
            System.out.printf("羽毛球跟羽毛球拍的总价格是： %.2f%n", priceAsync+priceDirect);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        long retrievalTime = ((System.nanoTime() - start) / 1_000_000);
        System.out.println("Price returned after " + retrievalTime + " msecs");
    }

```

#### 5、CompletableFuture的组合

###### thenApply

当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。

当计算结算完成之后,后面可以接继续一系列的thenApply,来完成值的转化.

```java
1 public <U> CompletableFuture<U>     thenApply(Function<? super T,? extends U> fn)
2 public <U> CompletableFuture<U>     thenApplyAsync(Function<? super T,? extends U> fn)
3 public <U> CompletableFuture<U>     thenApplyAsync(Function<? super T,? extends U> fn, Executor executor)
```

Function<? super T,? extends U>
T：上一个任务返回结果的类型
U：当前任务的返回值类型

![image-20210224212416449](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210224212416.png)

#### 6、 计算结果完成时的回调方法

当CompletableFuture的计算结果完成，或者抛出异常的时候，可以执行特定的Action。主要是下面的方法：

```java
1 public CompletableFuture<T>     whenComplete(BiConsumer<? super T,? super Throwable> action)
2 public CompletableFuture<T>     whenCompleteAsync(BiConsumer<? super T,? super Throwable> action)
3 public CompletableFuture<T>     whenCompleteAsync(BiConsumer<? super T,? super Throwable> action, Executor executor)
4 public CompletableFuture<T>     exceptionally(Function<Throwable,? extends T> fn)
```

上面4个方法是当计算阶段结束的时候触发,`BiConsumer`有两个入参,分别代表计算返回值,另外一个是异常.无返回值.方法不以Async结尾，意味着Action使用相同的线程执行，而Async可能会使用其它的线程去执行(如果使用相同的线程池，也可能会被同一个线程选中执行)。

可以看到Action的类型是BiConsumer<? super T,? super Throwable>它可以处理正常的计算结果，或者异常情况。

**whenComplete** 和 **whenCompleteAsync** 的区别：
 whenComplete：是执行当前任务的线程执行继续执行 whenComplete 的任务。
 whenCompleteAsync：是执行把 whenCompleteAsync 这个任务继续提交给线程池来进行执行。

![image-20210224212312253](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210224212312.png)

#### 7、handle 方法

handle 是执行任务完成时对结果的处理。
 handle 方法和 thenApply 方法处理方式基本一样。不同的是 **handle 是在任务完成后再执行**，还可以**处理异常的任务**。thenApply 只可以执行正常的任务，任**务出现异常则不执行 thenApply 方法**。

```java
public <U> CompletionStage<U> handle(BiFunction<? super T, Throwable, ? extends U> fn);
public <U> CompletionStage<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn);
public <U> CompletionStage<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn,Executor executor);
```

![image-20210224212720352](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210224212720.png)

#### 8、thenAccept 消费处理结果

接收任务的处理结果，并消费处理，无返回结果。

```java
public CompletionStage<Void> thenAccept(Consumer<? super T> action);
public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action);
public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action,Executor executor);
```

![image-20210224212943039](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210224212943.png)

#### 10、thenRun 方法

跟 thenAccept 方法不一样的是，不关心任务的处理结果。只要上面的任务执行完成，就开始执行 thenRun。

```java
public CompletionStage<Void> thenRun(Runnable action);
public CompletionStage<Void> thenRunAsync(Runnable action);
public CompletionStage<Void> thenRunAsync(Runnable action,Executor executor);
```

![image-20210224213132759](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210224213132.png)

#### 11、thenCombine 合并任务

thenCombine 会把 两个 CompletionStage 的任务都执行完成后，把两个任务的结果一块交给 thenCombine 来处理。

```java
public <U,V> CompletionStage<V> thenCombine(CompletionStage<? extends U> other,BiFunction<? super T,? super U,? extends V> fn);
public <U,V> CompletionStage<V> thenCombineAsync(CompletionStage<? extends U> other,BiFunction<? super T,? super U,? extends V> fn);
public <U,V> CompletionStage<V> thenCombineAsync(CompletionStage<? extends U> other,BiFunction<? super T,? super U,? extends V> fn,Executor executor);
```

```java
private static void thenCombine() throws Exception {
    CompletableFuture<String> future1 = CompletableFuture.supplyAsync(new Supplier<String>() {
        @Override
        public String get() {
            return "hello";
        }
    });
    CompletableFuture<String> future2 = CompletableFuture.supplyAsync(new Supplier<String>() {
        @Override
        public String get() {
            return "hello";
        }
    });
    CompletableFuture<String> result = future1.thenCombine(future2, new BiFunction<String, String, String>() {
        @Override
        public String apply(String t, String u) {
            return t+" "+u;
        }
    });
    System.out.println(result.get());
}
```



### 四、函数式接口



![image-20210325184246062](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210325184246.png)



### 五、Comparator.comparing比较排序





## Java基础

### 一、判断对象的类型

#### 1、instanceof

关键字`instanceof`

- 不仅可以判断对象是否是某个**类的实例**
- 甚至连该类**继承的基类**和**实现的接口**也都能够被识别为true

![image-20200930113910042](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200930113914.png)

![image-20200930113952443](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200930113952.png)

根据结果可知：虽然instanceof在逻辑上没有任何问题，是可以把Integer当做一个Number来看来用，也当做一个Serializable来看来用，但是这样**返回的结果**就**没有针对性**了，太过于模糊，**如果仅仅需要i instanceof Integer为true该怎么做呢？**

#### 2、Class.equals

Java有一个叫做`Class`的类，这是一个`用来描述类信息的类`，我们如果要精确`判断一个对象是否是具体的一个类的实例`，可以这么做：

![image-20201010170626247](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201010170628.png)

> 这样就能达到我们的目的了，从`equals函数`上就可以看出，上述代码是比较两个类的类信息是否一致，全相等，这其中不考虑继承父类、实现接口的关系，`当且仅当该对象是要比较的那个类的实例才返回true`。
> 查看源代码发现，`equals函数`用的就是`Object`中的方法，没有重写：

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

> 由此可知：
> 无论我们用Integer实例化多少个对象，当我们调用getClass()方法时返回的总是同一个类对象，即Integer.class。所以上面的`i.getClass().equals(Number.class)` 和 `i.getClass == Number.class` 是等价的。事实上`每个类都会有且只有一个对应Class的对象`，我们正是用这个Class对象来实例化该类的所有对象的，也就是Class中的newInstance()方法。
> 如果想获取更多有关于对象i的类型信息呢？比如获取它的基类呢？Class的对象中还有些方法用于获取父类、实现接口、类型名称的方法：
>
> - 获取父类的类型信息：`getSuperclass()`
> - 获取实现的接口的类型信息：`getInterfaces()`
> - 获取类型名称：`getName()`、getSimpleName()、getCanonicalName()

### 二、Arraylist没有在递归中正确更新

下面是我的函数,它给出给定数组中的元素求和到特定目标的所有可能性.我可以打印列表,但是结果列表没有更新.

![image-20210120164352902](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210120164353.png)

![image-20210120164423242](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210120164423.png)

![image-20210120164441103](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210120164441.png)

### 三、多态和强制类型转换

子类可以**赋值给超类**，称之为**向上转型**，这个是**自动**的。

**超类**不可以**赋值给子类**，这个是向下转型，需要我们**手动实现**。

赋值给超类的子类引用在**运行期间将表现出不同的特性**，这就是多态。

![image-20210226184452264](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210226184453.png)



![image-20210226184651823](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210226184652.png)

### 四、[java属性没多态，而是方法多态](https://www.cnblogs.com/donghang/p/9233725.html)

![image-20210318105940317](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210318105951.png)



### 五、基本类型的转换

#### 5.1 long（Long）与int（Integer）

```java
public static void main(String[] args) {
		// 1、将long型转化为int型，其中int、long是基础类型
		long a = 10;
		int b = (int) a;
		System.out.println("1、将long型转化为int型:" + b);
 
		// 2、将int型转化为long型，其中int、long都是基础类型
		int a1 = 10;
		long b1 = a1;
		System.out.println("2、将int型转化为long型:" + b1);
 
		// 3、将Long型转换为int型的，其中Long型是包装类型
		Long a2 = 10l;
		int b2 = a2.intValue();
		System.out.println("3、将Long型转换为int型:" + b2);
		
		//4、将Integer型转化为long型，其中Integer型是包装类型,long型是基础类型
		Integer a3=10;
		long b3=a3.longValue();
		System.out.println("4、将Integer型转化为long型:"+b3);
		
		//5、将Integer型转化为Long型，其中Integer、Long型都是包装类型
		Integer a4=10;
		Long b4=a4.longValue();
		System.out.println("5、将Integer型转化为Long型:"+b4);
	}
```

### 六、Comparable和Comparator的区别

#### 6.1 Comparable 简介

![image-20210331151406385](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210331151406.png)

> Comparable是java.lang包下面的接口，lang包下面可以看做是java的基础语言接口。
>
> 实际上Comparable接口只定义了一个方法：
>
> ```java
>  public int compareTo(T o);
> ```
>
> 实现这个接口的类都需要实现compareTo方法，表示两个类之间的比较。
>
> 这个比较排序之后的order，按照java的说法叫做natural ordering。这个order用在一些**可排序的集合**比如：SortedSet，SortedMap等等。
>
> 当使用这些可排序的集合添加相应的对象时，就会调用compareTo方法来**进行natural ordering的排序**。
>
> 几乎所有的数字类型对象：Integer, Long，Double等都实现了这个Comparable接口。

#### 6.2 Comparator 简介

![image-20210331151521210](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210331151521.png)

> Comparator是一个FunctionalInterface，需要实现compare方法：
>
> ```java
> int compare(T o1, T o2);
> ```
>
> Comparator在java.util包中，代表其是一个工具类，用来辅助排序的。
>
> 在讲Comparable的时候，我们提到Comparable指定了对象的natural ordering，如果我们在添加到可排序集合类的时候想按照我们自定义的方式进行排序，这个时候就需要使用到Comparator了。
>
> Collections.sort(List,Comparator),Arrays.sort(Object[],Comparator) 等这些辅助的方法类都可以通过传入一个Comparator来自定义排序规则。
>
> 在排序过程中，首先会去检查Comparator是否存在，如果不存在则会使用默认的natural ordering。
>
> 还有一个区别就是Comparator**允许对null参数**的比较，而**Comparable是不允许**的，否则会爬出NullPointerException。

#### 6.3 两者的联系

> Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。
>
> - **Comparable为可排序的，实现该接口的类的对象自动拥有可排序功能。**
> - **Comparator为比较器，实现该接口可以定义一个针对某个类的排序方式。**
>
> - **Comparator与Comparable同时存在的情况下，前者优先级高。**



#### 6.4 代码实现

```java
package com.github.compare;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/**
 * @                           _ooOoo_
 *                            o8888888o
 *                            88" . "88
 *                            (| -_- |)
 *                            O\  =  /O
 *                         ____/`---'\____
 *                       .'  \\|     |//  `.
 *                      /  \\|||  :  |||//  \
 *                     /  _||||| -:- |||||-  \
 *                     |   | \\\  -  /// |   |
 *                     | \_|  ''\---/''  |   |
 *                     \  .-\__  `-`  ___/-. /
 *                   ___`. .'  /--.--\  `. . __
 *                ."" '<  `.___\_<|>_/___.'  >'"".
 *               | | :  `- \`.;`\ _ /`;.`/ - ` : | |
 *               \  \ `-.   \_ __\ /__ _/   .-` /  /
 *          ======`-.____`-.___\_____/___.-`____.-'======
 *                             `=---='
 *          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 *                     佛祖保佑        永无BUG
 *@DESCRIPTION Comparable是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。
 *             Comparable相当于“内部比较器”
 *@AUTHOR SongHongWei
 *@TIME 2018/12/14-16:11
 *@PACKAGE_NAME com.github.compare
 **/
public class ComparableAndCompartor
{
    public static void main(String[] args)
    {
        List<House> houses = new ArrayList();
        House h1 = new House(95.0, 12000);
        House h2 = new House(110.0, 12160);
        House h3 = new House(80.0, 16300);
        House h4 = new House(150.3, 10690);
        houses.add(h1);
        houses.add(h2);
        houses.add(h3);
        houses.add(h4);
        comparable(houses);
        comparator(houses);
    }

    /**
     *@DESCRIPTION House类实现类Comparable接口, 并重写了compareTo方法, 所以执行Collections.sort方法时会去调用我们重写的compareTo方法
     *@AUTHOR SongHongWei
     *@TIME 2018/12/14-16:46
     *@CLASS_NAME ComparableAndCompartor
     **/
    private static void comparable(List houses)
    {

        System.out.printf("未排序前的顺序,%s\n", houses);
        Collections.sort(houses);
        System.out.printf("按面积大小排序后的顺序,%s\n", houses);
    }

    private static void comparator(List houses)
    {

        System.out.printf("未排序前的顺序,%s\n", houses);
        Collections.sort(houses, new ComparatorDetail());
        System.out.printf("按单价大小排序后的顺序,%s\n", houses);
    }

    /**
     *@DESCRIPTION 实现Compatator接口, 并重写compare方法, 根据单价倒序排序
     *@AUTHOR SongHongWei
     *@TIME 2018/12/14-16:49
     *@CLASS_NAME ComparableAndCompartor
     **/
    static class ComparatorDetail implements Comparator<House>
    {

        @Override
        public int compare(House o1, House o2)
        {
            if (o1.price < o2.price)
                return 1;
            else if (o1.price > o2.price)
                return -1;
            return 0;
        }
    }
}


```

```java
package com.github.compare;

/**
 * @                           _ooOoo_
 *                            o8888888o
 *                            88" . "88
 *                            (| -_- |)
 *                            O\  =  /O
 *                         ____/`---'\____
 *                       .'  \\|     |//  `.
 *                      /  \\|||  :  |||//  \
 *                     /  _||||| -:- |||||-  \
 *                     |   | \\\  -  /// |   |
 *                     | \_|  ''\---/''  |   |
 *                     \  .-\__  `-`  ___/-. /
 *                   ___`. .'  /--.--\  `. . __
 *                ."" '<  `.___\_<|>_/___.'  >'"".
 *               | | :  `- \`.;`\ _ /`;.`/ - ` : | |
 *               \  \ `-.   \_ __\ /__ _/   .-` /  /
 *          ======`-.____`-.___\_____/___.-`____.-'======
 *                             `=---='
 *          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 *                     佛祖保佑        永无BUG
 *@DESCRIPTION 一个房子对象, 有面积和单价两个属性
 *@AUTHOR SongHongWei
 *@TIME 2018/12/14-16:14
 *@PACKAGE_NAME com.github.compare
 **/
public class House implements Comparable<House>
{
    /*房子的面积*/
    protected double proportion;

    /*房子每平米的售价*/
    protected double price;

    public House(double proportion, double price)
    {
        this.proportion = proportion;
        this.price = price;
    }

    /**
     *@DESCRIPTION 重写compareTo方法, 利用房子的面积来进行大小比较
     *@AUTHOR SongHongWei
     *@TIME 2018/12/14-16:18
     *@CLASS_NAME House
     **/
    @Override
    public int compareTo(House o)
    {
        /*当前对象的面积大,返回正数*/
        if (this.proportion > o.proportion)
            return 1;
            /*当前面积小,返回负数*/
        else if (this.proportion < o.proportion)
            return -1;
        /*相等返回0*/
        return 0;
    }

    @Override
    public String toString()
    {
        return "面积为" + proportion + "\t价格为" + price;
    }
}


```

#### 6.5  顺序

```java
        ArrayList<Integer> mItems = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            mItems.add((int) (Math.random() * 10));
        }
        Logger.d("源数据:" + mItems);
 
        ArrayList<Integer> mItems2 = new ArrayList<>();
        mItems2.addAll(mItems);
 
        Collections.sort(mItems, new Comparator<Integer>() {
            // 返回值为int类型。
            // 大于0表示顺序（递增）【o1 > o2】，小于0表示逆序（递减）【o1 < o2】。
            @Override
            public int compare(Integer o1, Integer o2) {
                if (o1 > o2) {
                    return 1;
                } else {
                    return -1;
                }
            }
        });
        Logger.d("排序后（顺序）:" + mItems);
 
        Collections.sort(mItems2, new Comparator<Integer>() {
            // 返回值为int类型。
            // 大于0表示顺序（递增），小于0表示逆序（递减）。
            // 0，相等。
            @Override
            public int compare(Integer o1, Integer o2) {
                if (o1 > o2) {
                    return -1;
                } else {
                    return 1;
                }
            }
        });
        Logger.d("排序后（逆序）:" + mItems2);
```

![image-20210331164459823](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210331164500.png)

### 七、内部类

#### 7.1 内部类的基本概念

![image-20210406173750734](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406173750.png)

![image-20210406173908547](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406173908.png)

#### 7.2 优缺点

![image-20210406193157662](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406193157.png)



> 我们为什么需要内部类？或者说内部类为啥要存在？其主要原因有如下几点：
>
> - 内部类方法可以访问该类定义所在作用域中的数据，包括被 private 修饰的私有数据
> - 内部类可以对同一包中的其他类隐藏起来
> - 内部类可以实现 java 单继承的缺陷
> - 当我们想要定义一个回调函数却不想写大量代码的时候我们可以选择使用匿名内部类来实现

##### 7.2.1 使用内部类实现多继承



![image-20210406193306102](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406193306.png)

![image-20210406193313587](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406193313.png)

##### 7.2.2 对同一包中的其他类隐藏起来

![image-20210406220416641](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406220416.png)

##### 7.2.3 访问该类定义所在作用域数据

![image-20210406220539595](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406220539.png)



**为什么成员内部类可以无条件访问外部类的成员？**

![image-20210406215538583](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406215538.png)

![image-20210406215509362](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406215509.png)

**为什么局部内部类和匿名内部类只能访问局部final变量？**

（会复制局部变量来解决生命周期不一致的问题，但是有了一致性的问题，所以这个变量必须不能变化，解决一致性的问题）

![image-20210406220144557](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406220144.png)

![image-20210406215843091](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406215843.png)

![image-20210406215946186](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406215946.png)

![image-20210406220005842](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406220006.png)



#### 7.3 创建内部类

7.3.1  在外部类外部 创建非静态内部类
语法： 外部类.内部类 内部类对象 = new 外部类().new 内部类();
举例： Outer.Inner in = new Outer().new Inner();

7. 3.2 在外部类外部 创建静态内部类
   语法： 外部类.内部类 内部类对象 = new 外部类.内部类();
   举例： Outer.Inner in = new Outer.Inner();

7. 3.3 在外部类内部创建内部类语法
   在外部类内部创建内部类，就像普通对象一样直接创建：Inner in = new Inner();


#### 7.4 内部类的分类

在Java中内部类主要分为**成员内部类、静态内部类、方法内部类、匿名内部类**

##### 7.4.1 成员内部类

类比**成员方法**

成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。

不过要注意的是，当成员内部类拥有和外部类**同名**的成员变量或者方法时，会发生**隐藏现象**，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：



![image-20210406193713439](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406193713.png)

![image-20210406214225711](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406214225.png)

![image-20210406214422641](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406214422.png)



##### 7.4.2 静态内部类

![image-20210406194339774](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406194340.png)

##### 7.4.3 方法内部类（局部内部类）

![image-20210406195450358](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406195450.png)

![image-20210406195729585](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406195729.png)

![image-20210406220817413](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406220817.png)

##### 7.4.4 匿名内部类

![image-20210406195845441](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406195845.png)

#### 7.5 内部类与外部类的关系

![image-20210406220959716](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406220959.png)



![image-20210406200223110](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406200223.png)

![image-20210406213657610](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406213658.png)

### 八、LinkedList

> **LinkedList及常用API**
>
> ①  LinkedList----链表
>
> ②  LinkedList类扩展AbstractSequentialList并实现List接口
>
> ③  LinkedList提供了一个链表数据结构
>
> ④  LinkedList有两个构造方法
>
> a)  LinkedList()
>
> b)  LinkedList(Collection c)
>
> ⑤  除了继承的方法之外，LinkedList类还定义了一些有用的方法用于操作和访问容器中的数据;
>
> a)  void addFirst(E e)
>
> b)  void addLast(E e)
>
> c)   E removeFirst()
>
> d)   E removeLast()

> 总结：
>
> 内部封装的是双向链表数据结构
>
> 每个节点是一个Node对象，Node对象中封装的是你要添加的元素
>
> 还有一个指向上一个Node对象的引用和指向下一个Node对象的引用
>
> ​      
>
> 不同的容器有不同的数据结构，不同的数据结构操作起来性能是不同的
>
> 链表数据结构，做插入，删除的效率比较高，但查询效率比较低
>
> ​      
>
> 数组结构，它做查询的效率高，因为可以通过下标直接找到元素
>
> 但插入删除效率比较低，因为要做移位操作

#### 8.1 作为栈

![image-20210412143954038](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210412143954.png)

#### 8.2 作为队列

![](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210412143820.png)

#### 8.3 双端队列Deque

![image-20210412143932248](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210412143932.png)

#### 总结

![image-20210412144029609](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210412144030.png)







```java
package collectionApi;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.ListIterator;

public class LinkedListApi {

	public static void main(String[] args) {
		LinkedList<String> linkedList = new LinkedList<>();
		linkedList.add("D");
		linkedList.add("E");
		linkedList.add("G");
		linkedList.add("A");
		linkedList.add("H");
		System.out.println(linkedList); //[D, E, G, A, H]
		LinkedList<String> linkedList2 = new LinkedList<>(linkedList); //
		
		String key;
		key = linkedList.getFirst(); // 取表头
		key = linkedList.getLast();  // 取表尾
		key = linkedList.get(2); // 取index = 2
		key = linkedList.peek(); // 取表头
		key = linkedList.peekFirst(); // 取表头
		key = linkedList.peekLast(); // 取表尾
		boolean b = linkedList.remove("G"); // 删除第一个给定元素 删除返回true
		key = linkedList.remove(3); // 删除index = 3 返回删除元素
		key = linkedList.remove();  // 删除表头 返回删除元素
		key = linkedList.removeFirst();  // 删除表头 返回表头
		key = linkedList.removeLast();  // 删除表尾返回表尾
		key = linkedList.poll(); // 删除表头返回 表头
		key = linkedList.pollFirst(); // 删除表头返回 表头
		key = linkedList.pollLast(); // 删除表尾 返回表尾
		linkedList.push("44"); // addFirst
		linkedList.addFirst("3"); // 表头增加元素
		linkedList.addLast("7"); // 表尾增加元素
		b = linkedList.contains("E"); // 包含返回true
		int n = linkedList.size(); // 元素count
		b = linkedList.addAll(linkedList2); // 返回true
		System.out.println(linkedList); // [3, 44, 7, D, E, G, A, H]
		b = linkedList.addAll(3, linkedList2); // 从index = 3 增加
		System.out.println(linkedList);
		//linkedList.clear(); 清空
		key = linkedList.set(4, "EE"); // 设定指定index 的值
		System.out.println(key);
		b = linkedList.offer("3");  // add
		b = linkedList.offerFirst("77"); //addFirst 
		b = linkedList.offerLast("22");   // addLast
		b = linkedList.removeFirstOccurrence("E"); // remove("E")
		b = linkedList.removeLastOccurrence("3"); // 删除最后一个
		
		n = linkedList.indexOf("E"); // 第一次出现的位置index
		n = linkedList.lastIndexOf("G"); // 第后一次出现的位置index
		
		System.out.println(linkedList); // [77, 3, 44, 7, D, EE, G, A, H, D, G, A, H, 22]
		ListIterator<String> listIterator = linkedList.listIterator(4); // 正向迭代器
		while (listIterator.hasNext()) {
			String string = listIterator.next();
			//System.out.println(string); //D, EE, G, A, H, D, G, A, H, 22]
		}
		
		Iterator<String> iterator = linkedList.descendingIterator(); // 反向迭代器
		while (iterator.hasNext()) {
			String string = iterator.next();
			//System.out.println(string); //22, H, A, G,D,H,A... 
		}
		
		Object[] objects = linkedList.toArray(); // 转为对象数组
		String[] strings = new String[1];
		strings = linkedList.toArray(strings); // 转为数组
		Object object = linkedList.clone(); // 浅表克隆
		
		linkedList.add(3, "EE");
		System.out.println(linkedList);
	}
}

```











## 设计模式

### 一、模板模式和回调

#### 1、回调

##### 1.1 概念

> **回调**:简单来说，就是我调用你的函数，你的函数中再来调用我的函数。正规一点的说法就是类A的a()函数调用类B的b()函数，当类B的b()函数的执行时又去调用类A里的函数。是一种双向的调用方式。一般情况下，回调分两种，分别是**同步回调**和**异步回调**
>
> 
>
> 回调是一种**双向的调用**模式，也就是说，被调用的接口被调用时也会调用对方的接口，简单点说明就是：A类中调用B类中的C方法，然后B类中的C方法中反过来调用A类中的D方法，那么D这个方法就叫回调方法。
> 通过回调在接口中定义的方法，调用到具体的实现类中的方法，其本质是利用Java的动态绑定技术，在这种实现中，可以不把实现类写成单独的类，而使用内部类或匿名内部类来实现回调方法。



![在这里插入图片描述](https://img-blog.csdnimg.cn/20200425181314291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNDE2NzM=,size_16,color_FFFFFF,t_70#pic_center)

```json
  回调的具体过程如下：
  1. Class A实现接口CallBack —— 背景1
  2. class A中包含class B的引用 ——背景2
  3. class B有一个参数为CallBack的方法C ——背景3
  4. 前三条是我们的准备条件，接下来A的对象调用B的方法C
  5. 然后class B就可以在C方法中调用A的方法D

```

##### 1.2 示例

> 该示例的生活背景为：有一天小刘遇到一个很难的问题“我漂亮吗”，于是就打电话问小高，小高一时也不太了解行情，就跟小刘说，我现在还有事，等忙完了给你咨询咨询，小刘也不会傻傻的拿着电话去等小高的答案，于是小刘对小高说，先挂电话吧，你知道答案后再打我电话告诉我吧，于是挂了电话。小高先去办自己的事情去了，过了几个小时，小高打电话给小刘，告诉他答案是“CC最漂亮了”。

```java
/** 
 * 回调接口  
 */
interface CallBack {  
    /** 
     * 小高知道答案后告诉小刘时需要调用的方法，即回调方法
     * @param result 是问题的答案 
     */  
    public void answer(String result);  
}
/** 
 * 小刘类：实现了回调接口CallBack（背景一） 
 */  
class Liu implements CallBack {  
    /** 
     * 包含小高对象的引用 （背景二） 
     */  
    private Gao gao;   
  
    public Liu(Gao gao){  
        this.gao = gao;  
    }  
       
    /** 
     * 小刘通过这个方法去问小高 
     * @param question  小刘问的问题“我漂亮吗？” 
     */  
    public void askQuestion(String question){  
        //小刘问小高问题
        gao.execute(Liu.this, question);          
    }  
    /** 
     * 小高知道答案后调用此方法告诉小刘
     */  
    @Override
    public void answer(String result) {
        System.out.println("小高告诉小刘的答案是：" + result);        
    }  
} 
/** 
 * 小高类 
 */  
class Gao {
     /** 
     * 相当于class B有一个参数为CallBack的方法C（背景三） 
     */  
    public void execute(CallBack callBack, String question){  
        System.out.println("小刘问的问题是：" + question);  
        //模拟小高挂点后先办自己的事情花了很长时间  
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //小高办完自己的事情后想到了答案 
        String result = "CC最漂亮了";  
        //小高打电话把答案告诉小刘，相当于class B 反过来调用class A 的D方法 
        callBack.answer(result);         
    }  
}
 
public class Test {
    public static void main(String[] args) {
        Gao  gao= new Gao();  
        Liu liu = new Liu(gao);  
        //小刘问问题
        liu.askQuestion("我漂亮吗？"); 
    } 
}

```

![image-20210402195021481](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210402195022.png)



#### 2、模板模式

![image-20210406151742985](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210406151742985.png)

![image-20210406152148358](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406152148.png)

```java
public class HookTemplateMethod {
    public static void main(String[] args) {
        HookAbstractClass tm = new HookConcreteClass();
        tm.TemplateMethod();
    }
}

//含钩子方法的抽象类
abstract class HookAbstractClass {
    //模板方法
    public void TemplateMethod() {
        abstractMethod1();
        HookMethod1();
        if (HookMethod2()) {
            SpecificMethod();
        }
        abstractMethod2();
    }

    //具体方法
    public void SpecificMethod() {
        System.out.println("抽象类中的具体方法被调用...");
    }

    //钩子方法1
    public void HookMethod1() {
    }

    //钩子方法2
    public boolean HookMethod2() {
        return true;
    }

    //抽象方法1
    public abstract void abstractMethod1();

    //抽象方法2
    public abstract void abstractMethod2();
}

//含钩子方法的具体子类
class HookConcreteClass extends HookAbstractClass {
    public void abstractMethod1() {
        System.out.println("抽象方法1的实现被调用...");
    }

    public void abstractMethod2() {
        System.out.println("抽象方法2的实现被调用...");
    }

    public void HookMethod1() {
        System.out.println("钩子方法1被重写...");
    }

    public boolean HookMethod2() {
        return false;
    }
}
```

![image-20210406152301892](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406152302.png)





#### 3、spring使用模板模式的例子

![image-20210406151912867](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406151913.png)

![image-20210406153603036](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406153603.png)

假设我们是设计者，那些重复的步骤封装。我们可以使用模板方法模式：
我们定义一个AbstractJdbcTemplate类

![image-20210406153706177](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406153706.png)

![image-20210406153743380](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406153743.png)



##### 3.1 引入回调原因：

![image-20210406153812567](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406153812.png)

![image-20210406153843934](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406153844.png)

![image-20210406154018018](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406154018.png)





![image-20210406151949745](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406151949.png)

![image-20210406151956567](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210406151956.png)





## 时间

#### timestamp格式转化

```java
private static String formatTime(String dateTime) {
        Date date = DateUtil.parseDate(dateTime, "yyyy-MM-dd'T'HH:mm:ss");
        String dateFormat = DateUtil.formatDate(date, FULL_CHINESE_PATTERN);
        return dateFormat;
    }
```

```java
  private String covnDate(String dateTime) {
        DateFormat df2 = null;
        Date date1 = null;
        try {
            DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
            Date date = df.parse(dateTime);
            SimpleDateFormat df1 = new SimpleDateFormat("EEE MMM dd HH:mm:ss Z yyyy", Locale.UK);
            date1 = df1.parse(date.toString());
            df2 = new SimpleDateFormat("yyyy/MM/dd");
 
        } catch (ParseException e) {
            e.printStackTrace();
        }
        return df2.format(date1);
    }
```

#### Mon Aug 15 11:24:39 CST 2016

```java
String datestr= "Mon Aug 15 11:24:39 CST 2016";//Date的默认格式显示
Date date=new SimpleDateFormat("EEE MMM dd HH:mm:ss Z yyyy", Locale.UK)).parse(datestr);
//格式化SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd");
String sDate=sdf.format(date);
System.out.println(sDate);
```



## 数据库

### left join on  where原理

![Image](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804154033.png)

![Image](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804154044.png)

![Image](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804154100.png)

![Image](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804154105.png)

![Image](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804154110.png)

### 查询重复数据sql

#### 造数据

```mysql
INSERT INTO hk_test(username, passwd) VALUES('qmf1', 'qmf1'),('qmf2', 'qmf11') delete from hk_test where username='qmf1' and passwd='qmf1'
```

![491580-20151012150716616-828543178](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804161151.png)

MySQL里查询表里的重复数据记录：先查看重复的原始数据：

![491580-20151012150716960-1906043903](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804161207.png)

#### 场景一：列出username字段有重读的数据

```mysql
select username,count(*) as count from hk_test group by username having count>1; 
SELECT username,count(username) as count FROM hk_test GROUP BY username HAVING count(username) >1 ORDER BY count DESC;
```

![491580-20151012150717210-484086287](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200804161506.png)

这种方法只是统计了该字段重复对应的具体的个数

#### 场景二：列出username字段重复记录的具体指：

```mysql
select * from hk_test where username in (select username from hk_test group by username having count(username) > 1) 
SELECT username,passwd FROM hk_test WHERE username in ( SELECT username FROM hk_test GROUP BY username HAVING count(username)>1) 
但是这条语句在mysql中效率太差，感觉mysql并没有为子查询生成临时表。在数据量大的时候，耗时很长时间
```

## maven

### install和compile区别

> maven **install** 是**先进行打包**，在target目录下**生成新jar**，同时将打包结果**放到本地仓库**的相应目录中，供其他项目或模块引用。
>
> maven **package** 只是打包，并在target目录下生成新jar，**maven仓库中还是老的jar**。
>
> 我们在**重新打包**的时候，**直接install**即可，**不需要clean**。install会替换本地和仓库的jar，而且他会比较新旧jar是否有差异，来判断是否更新。
>
> 如果我们不需要jar，而且所更改代码不需要被引用，那么只需要compile即可。
>
> maven有clean、default、site三种生命周期，每种生命周期都包含一些阶段。三套生命周期是互相独立的，每种生命周期的阶段是前后依赖的。执行某个阶段，则会先依次执行该生命周期的前面阶段 （比如你执行install，其实是执行了validate、compile、test、package、verify、install这么多操作）
> clean包含了 pre-clean、clean、post-clean阶段；
> default生命周期包含了validate、compile、test、package、verify、install、deploy阶段；

## 重试

```java
package com.retry;
/**
 * @author liuxd
 * @version 1.0
 * @date 2019-11-06 17:36
 */
import java.util.Random;
import java.util.concurrent.TimeUnit;
 
public class TestRetry {
    //最大重试次数
    private static final Integer tryTimes = 6;
    //重试间隔时间单位秒
    private static final Integer intervalTime = 2;
 
    public static void main(String[] args) throws InterruptedException {
        boolean flag = TestRetry.retryBuss();
        System.out.println("最终执行结果:" + (flag ? "成功" : "失败"));
    }
 
    public static boolean retryBuss() throws InterruptedException {
        Integer retryNum = 1;
        boolean flag = false;
        while (retryNum <= tryTimes) {
            try {
                flag = execute(retryNum);
                if (flag) {
                    System.out.println("第" + retryNum + "次执行成功!!!");
                    break;
                }
                System.err.println("第" + retryNum + "次执行失败...");
                retryNum++;
            } catch (Exception e) {
                retryNum++;
                TimeUnit.SECONDS.sleep(intervalTime);
                continue;
            }
        }
 
        return flag;
    }
 
    /**
     * 具体业务
     * @param retryNum
     * @return
     */
    private static boolean execute(int retryNum) {
        Random random = new Random();
        int a = random.nextInt(10);
        boolean flag = true;
        try {
            if (a != 6) {
                flag = false;
                throw new RuntimeException();
            }
        } catch (Exception e) {
        }
        return flag;
    }
}
```

## idea相关问题

### idea git将多余的代码提交到本地，如何退回







## rabbitmq





## 正则表达式

#### 一、字符处理

##### 1、特殊字符处理

对于特殊字符：`$`、`^`、`(`、`)`、`[`、`]`、 `{`、`}`、 `*`、 `+`、 `?`、 `.`、`\` 、`|`前面都要加上`\`进行转义。

##### 2、预定义字符

预定义字符即为正则表达式中的“通配符”，就是可以匹配多个字符的特殊字符。

![](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201208201146.png)

#### 二、三种模式的数量表示符

1. **贪婪**模式：Greedy，数量表示符默认为贪婪模式，会**一直匹配**下去，直到无法匹配为止。
2. **勉强**模式：Reluctant，用问号`?`后缀表示，只会匹配最少的字符，也被称为**最小匹配模式**。
3. **占有**模式： Possessive， **用加号`+`后缀**表示。

![image-20201208201500090](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201208201500.png)

#### 三、方括号表达式

![image-20201208201524801](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201208201524.png)

![image-20201208201937106](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201208201937.png)



![image-20200826174441182](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200826174445.png)

![image-20201102110155007](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201102110155.png)

> 普通字符串 ------也算一个正则表达式，例如**Hello World** 正则表达式匹配 "Hello World" 字符串。
>
> . -----匹配除"\r\n"之外的**任何单个字符**。若要匹配包括"\r\n"在内的任意字符，请使用诸如"[\s\S]"之类的模式。
>
> *----**零次或多次**匹配前面的字符或子表达式
>
> \+ -----**一次或多次**匹配前面的字符或子表达式
>
>  **\s+** 可以匹配**多个空格**
>
> **^** 定义了以什么开始，若**出现在[]中**，则不匹配[]内的所有字符
>
> $ 匹配输入字符串结尾的位置
>
> \d+ 匹配一个或多个数字
>
> ? 零次或一次匹配前面的字符或子表达式..当此字符紧随任何其他限定符（*、+、?、{*n*}、{*n*,}、{*n*,*m*}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"**贪心的**"模式**匹配搜索到**的、**尽可能长**的字符串
>
> \. 匹配 "."
>
> {n} 匹配前面的字符 *n* 次
>
> {n,}至少匹配 *n* 次
>
> {n,m}匹配至少 *n* 次，至多 *m* 次
>
> *x*|*y*匹配 *x* 或 *y*
>
> [*xyz*]*字符集。匹配包含的任一字符*
>
> [*a-z*]*字符范围。匹配指定范围内的任何字符*



#### 四、正则表达式 - 元字符

下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：

| 字符         | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| \            | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。 |
| ^            | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。 |
| $            | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。 |
| *            | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| +            | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?            | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。 |
| {n}          | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}         | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m}        | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |
| ?            | 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。 |
| .            | 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"**(.\|\n)**"的模式。 |
| (pattern)    | 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。 |
| (?:pattern)  | 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (\|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y\|ies) 就是一个比 'industry\|industries' 更简略的表达式。 |
| (?=pattern)  | 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95\|98\|NT\|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?!pattern)  | 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95\|98\|NT\|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?<=pattern) | 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"`(?<=95|98|NT|2000)Windows`"能匹配"`2000Windows`"中的"`Windows`"，但不能匹配"`3.1Windows`"中的"`Windows`"。 |
| (?<!pattern) | 反向否定预查，与正向否定预查类似，只是方向相反。例如"`(?<!95|98|NT|2000)Windows`"能匹配"`3.1Windows`"中的"`Windows`"，但不能匹配"`2000Windows`"中的"`Windows`"。 |
| x\|y         | 匹配 x 或 y。例如，'z\|food' 能匹配 "z" 或 "food"。'(z\|f)ood' 则匹配 "zood" 或 "food"。 |
| [xyz]        | 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。 |
| [^xyz]       | 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。 |
| [a-z]        | 字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。 |
| [^a-z]       | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。 |
| \b           | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |
| \B           | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |
| \cx          | 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \d           | 匹配一个数字字符。等价于 [0-9]。                             |
| \D           | 匹配一个非数字字符。等价于 [^0-9]。                          |
| \f           | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| \n           | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| \r           | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
| \s           | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |
| \S           | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                  |
| \t           | 匹配一个制表符。等价于 \x09 和 \cI。                         |
| \v           | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     |
| \w           | 匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。               |
| \W           | 匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。           |
| \xn          | 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。 |
| \num         | 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。 |
| \n           | 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 |
| \nm          | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 |
| \nml         | 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 |
| \un          | 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 |

#### 五、 group方法详解

> **捕获组**是把**多个字符当一个单独单元**进行处理的方法，它通过对括号内的字符分组来创建。

捕获组是通过从左至右计算其开括号来编号。例如，在表达式((A)(B(C)))，有四个这样的组：

((A)(B(C)))
(A)
(B(C))
(C)

可以通过调用 matcher 对象的 **groupCount** 方法来查看表达式**有多少个分组**。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。

在Java正则表达式的**相关类Matcher**中,有如下几个方法: 

\- int groupCount() 
\- String group(int group) 
\- int start(int group) 
\- int end(int group) 
\- String group(String name) 
\- int start(String name) 
\- int end(String name)

![image-20201208200821027](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201208200822.png)

 从输出结果可以看出,当正则表达式包含多个group时,也就是**含有多个’(pattern)’格式**的子表达式时,它的分组索引(group number)是从1开始的,而group(0)代表了**整个匹配的字符串.** 

http://blog.itpub.net/69955379/viewspace-2716903/

Java 正则表达式的捕获组分为：
普通捕获组(Expression)
命名捕获组(?Expression)

##### **5.1  普通捕获组**

从正则表达式左侧开始，每出现一个左括号"("记做一个分组，分组编号从 1 开始。0 代表整个表达式。

![image-20201211153750667](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201211153752.png)

##### **5.2  命名捕获组**



#### 六、 整理常用正则表达式

##### 6.1  校验数字的表达式

```json
 数字：^[0-9]*$
 n位的数字：^\d{n}$
 至少n位的数字：^\d{n,}$
 m-n位的数字：^\d{m,n}$
 零和非零开头的数字：^(0|[1-9][0-9]*)$
 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$
 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$
 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$
 非负整数：^\d+$ 或 ^[1-9]\d*|0$
 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$

```

##### 6.2  校验字符的表达式

```json
 汉字：^[\u4e00-\u9fa5]{0,}$
 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
 长度为3-20的所有字符：^.{3,20}$
 由26个英文字母组成的字符串：^[A-Za-z]+$
 由26个大写英文字母组成的字符串：^[A-Z]+$
 由26个小写英文字母组成的字符串：^[a-z]+$
 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+
 禁止输入含有~的字符：[^~\x22]+

```

##### 6.3  特殊需求表达式

```json
 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$
 手机号码：^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\d{8}$ (由于工信部放号段不定时，所以建议使用泛解析 ^([1][3,4,5,6,7,8,9])\d{9}$)
 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 
 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 
 18位身份证号码(数字、字母x结尾)：^((\d{18})|([0-9x]{18})|([0-9X]{18}))$
 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$  
 日期格式：^\d{4}-\d{1,2}-\d{1,2}
 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 
 钱的输入格式：
    1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 
    2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 
    3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 
    4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 
    5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$ 
    6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 
    7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 
    8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 
    备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
 中文字符的正则表达式：[\u4e00-\u9fa5]
 双字节字符：[^\x00-\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
 空白行的正则表达式：\n\s*\r    (可以用来删除空白行)
 HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? />    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
 腾讯QQ号：[1-9][0-9]{4,}    (腾讯QQ号从10000开始)
 中国邮政编码：[1-9]\d{5}(?!\d)    (中国邮政编码为6位数字)
 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))  
 三段式APP版本号：^([1-9]\d|[1-9])(\.([1-9]\d|\d)){2}$

```





## 生成指定范围的随机数

要生成在[min,max]之间的随机整数，代码如下：

```java
package edu.sjtu.erplab.io;

import java.util.Random;

public class RandomTest {
  public static void main(String[] args) {
    int max=20;
    int min=10;
    Random random = new Random();

​    int s = random.nextInt(max)%(max-min+1) + min;
​    System.out.println(s);
  }
}
```

random.nextInt(max)表示生成[0,max]之间的随机数，然后对(max-min+1)取模。

因为余数总是小于除数的，所以对min和max的差值取余后，余数总是小于他们的差值，用min加上余数是不会大于max的

## 反射

#### JavaBean

> 主要用于传递数据信息，其方法用于访问私有变量，且方法名符合某种规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为**“值对象”(Value Object)**，或“VO”。方法比较少。这些**信息储存在类的私有变量**中，通过set()、get()获得。

> **内省**主要是对JavaBean进行操作。JavaBean内部的方法要按照某种规则命名，例如void setAge(int age)、int getAge()。JavaBean可以作为普通类进行操作；**普通类如果内部有**set()、get()方法，**也可以当做**JavaBean使用。
>
> JavaBean的属性是通过get()和set()方法推断出来的，即去掉get、set后的字母，例如，属性为age，而不是成员变量，因为成员变量看不见。
>
> 获得属性名的规则：如果属性名的第二个字母是小写，则把第一个字母小写。例如，getTime—>time，setTime—>time，getCPU—>CPU。
>
> JavaBean处理的好处：
>
> 1、JavaEE中许多地方需要使用JavaBean。
>
> 2、JDK给JavaBean提供的API称为内省。
>
> 

#### PropertyDescriptor

> PropertyDescriptor类表示**JavaBean****类通过存储器导出一个属性**。主要方法：

> 1、[getPropertyType](mk:@MSITStore:F:/计算机科学/java配套软件/API/JDK_API_1_5_中文版.CHM::/java/beans/PropertyDescriptor.html#getPropertyType())()，获得属性的Class对象。
>
> 2、[getReadMethod](mk:@MSITStore:F:/计算机科学/java配套软件/API/JDK_API_1_5_中文版.CHM::/java/beans/PropertyDescriptor.html#getReadMethod())()，获得用于**读取属性值**的方法；[getWriteMethod](mk:@MSITStore:F:/计算机科学/java配套软件/API/JDK_API_1_5_中文版.CHM::/java/beans/PropertyDescriptor.html#getReadMethod())()，获得用于写入属性值的方法。
>
> 3、[hashCode](mk:@MSITStore:F:/计算机科学/java配套软件/API/JDK_API_1_5_中文版.CHM::/java/beans/PropertyDescriptor.html#hashCode())()，获取对象的哈希值。
>
> 4、[setReadMethod](mk:@MSITStore:F:/计算机科学/java配套软件/API/JDK_API_1_5_中文版.CHM::/java/beans/PropertyDescriptor.html#setReadMethod(java.lang.reflect.Method))([Method](mk:@MSITStore:F:/计算机科学/java配套软件/API/JDK_API_1_5_中文版.CHM::/java/lang/reflect/Method.html) readMethod)，**设置用于读取属性值**的方法；[setWriteMethod](mk:@MSITStore:F:/计算机科学/java配套软件/API/JDK_API_1_5_中文版.CHM::/java/beans/PropertyDescriptor.html#setReadMethod(java.lang.reflect.Method))([Method](mk:@MSITStore:F:/计算机科学/java配套软件/API/JDK_API_1_5_中文版.CHM::/java/lang/reflect/Method.html)writeMethod)，**设置用于写入属性值的**方法；
>
> 

![image-20200914183031779](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200914183033.png)

![image-20200914183135982](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200914183136.png)

#### Introspector类

将JavaBean中的**属性封装**起来进行操作。在程序把一个类当做JavaBean来看，就是调用Introspector.getBeanInfo()方法，得到的BeanInfo对象封装了把这个类当做JavaBean看的结果信息，即属性的信息。需要导包java.beans.。

getPropertyDescriptors()，获得属性的描述，**可以采用遍历BeanInfo的方法，来查找、设置类的属性。**

![image-20200914183946278](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200914183946.png)

通过这两个类的比较可以看出，都是需要获得PropertyDescriptor，只是方式不一样：前者通过创建对象直接获得，后者需要遍历，所以**使用PropertyDescriptor类**更加方便。

## 自定义注解

#### **元注解：**

**元注解的作用就是负责注解其他注解**。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：

```java
1.@Target,
2.@Retention,
3.@Documented,
4.@Inherited
```

这些类型和它们所支持的类在java.lang.annotation包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。

##### @Target

@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。

**作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）**

**取值(ElementType)有：**

> 1.CONSTRUCTOR:用于描述构造器
> 2.FIELD:用于描述域
> 3.LOCAL_VARIABLE:用于描述局部变量
> 4.METHOD:用于描述方法
> 5.PACKAGE:用于描述包
> 6.PARAMETER:用于描述参数
> 7.TYPE:用于描述类、接口(包括注解类型) 或enum声明

　使用实例：

![image-20200915143513197](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915143513.png)

注解Table 可以用于注解类、接口(包括注解类型) 或enum声明,而注解NoDBColumn仅可用于注解类的成员变量

##### @Retention

**@Retention**定义了该Annotation**被保留的时间长短**：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。

**作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）**

　　**取值（RetentionPoicy）有：**

　　　　1.SOURCE:在源文件中有效（即源文件保留）
　　　　2.CLASS:在class文件中有效（即class保留）
　　　　3.RUNTIME:在运行时有效（即运行时保留）

Retention meta-annotation类型有唯一的value作为成员，它的取值来自java.lang.annotation.RetentionPolicy的枚举类型值。具体实例如下：

![image-20200915143649338](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915143649.png)

##### @Documented

　@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。

##### @Inherited

　@Inherited 元注解是一个标记注解，@Inherited阐述了**某个被标注的类型是被继承的**。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation**将被用于该class的子类。**

　注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。

　　当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去**查询一个@Inherited annotation类型的annotation**时，反射代码检查将展开工作：**检查class和其父类**，直到**发现指定的annotation类型**被发现，或者到达类继承结构的顶层。

![image-20200915143901979](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915143902.png)

#### 接口入参验证

**@RequestParam\@Valid\@Validated\@RequestBody**

@RequestParam  适用于Get请求且content-type为application/x-www-form-urlencoded

@RequestBody   适用于post请求且content-type为非application/x-www-form-urlencoded类型，一般为application/json

#### 检验基础类型不生效的问题

![image-20200915103541351](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915103541.png)

#### 集合类型参数中的元素不生效的问题

![image-20200915103638109](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915103638.png)



**入参为@NotNull**时要在方法上加@valid或**@validated**，或者在**类上加@Validated**（@valid不能作用于类上），这样@NotNull才能起作用。

![image-20200914185206308](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200914185206.png)

#### 自定义校验器(字母大小写)

##### 定义大小写的枚举

![image-20200915102012655](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915102013.png)

![image-20200915102041163](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915102041.png)

##### 定义校验器

![image-20200915102251237](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915102251.png)

![image-20200915102302736](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915102302.png)

#### 分组校验

##### 使用场景

> 例:用户的登录和注册使用的是同一个用户对象，用户对象里面包含了所有用户相关的数据；
> 当用户**注册**的时候，我们就需要校验前端上传的号码、昵称、性别、密码、邮箱等等相关信息
> 当**登录**的时候，就只需要校验用户名和密码，其他的参数都不用校验

##### 定义校验的分组接口

![image-20200915102612270](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915102612.png)

##### 修改用户模型对象

![image-20200915102636780](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915102636.png)

##### 需要分组校验的DTO

![image-20200915103146866](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915103147.png)

##### 校验的接口

![image-20200915103228265](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915103228.png)

 使用分组能极大的复用需要验证的类信息。而不是按业务重复编写冗余的类。其中@GroupSequence提供组序列的形式进行顺序式校验，即先校验@Save分组的，如果校验不通过就不进行后续的校验多了。我认为顺序化的校验，场景更多的是在业务处理类，例如联动的属性验证，值的有效性很大程度上不能从代码的枚举或常量类中来校验。

#### 注解工具类

![image-20200916112053313](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916112053.png)

![](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916111957.png)

![image-20200916112223510](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916112223.png)







## 切面

![image-20200915105059555](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200915105059.png)

#### 一、用AOP实现注解功能

```java
import com.hm.common.util.cast.CastValueTypeUtil;
import com.hm.common.util.exception.ParamIsNullException;
import com.hm.spss.annotation.ParamCheck;
import org.apache.commons.lang3.StringUtils;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;

/**
 * 参数效验AOP
 */
@Component
@Aspect
public class ParamCheckAOP {

    /**
     * 定义有一个切入点，范围为web包下的类
     */
    @Pointcut("execution(public * com.hm.spss.controller..*.*(..))")
    public void checkParam() {
    }

    /**
     * 方法执行前执行
     * @param joinPoint
     */
    @Before("checkParam()")
    public void doBefore(JoinPoint joinPoint) {
    }

    @Around("checkParam()")
    public Object doAround(ProceedingJoinPoint pjp) throws Throwable {

        MethodSignature signature = ((MethodSignature) pjp.getSignature());
        //得到拦截的方法
        Method method = signature.getMethod();
        //获取方法参数注解，返回二维数组是因为某些参数可能存在多个注解
        Annotation[][] parameterAnnotations = method.getParameterAnnotations();
        if (parameterAnnotations == null || parameterAnnotations.length == 0) {
            return pjp.proceed();
        }
        //获取方法参数名
        String[] paramNames = signature.getParameterNames();
        //获取参数值
        Object[] paranValues = pjp.getArgs();
        //获取方法参数类型
        Class<?>[] parameterTypes = method.getParameterTypes();
        for (int i = 0; i < parameterAnnotations.length; i++) {
            for (int j = 0; j < parameterAnnotations[i].length; j++) {
                //如果该参数前面的注解不为空并且是ParamCheck的实例，并且notNull()=true,并且默认值为空，则进行非空校验
                if (parameterAnnotations[i][j] != null && parameterAnnotations[i][j] instanceof ParamCheck && ((ParamCheck) parameterAnnotations[i][j]).notNull() && StringUtils.isEmpty(((ParamCheck)parameterAnnotations[i][j]).defaultValue())) {
                    paramIsNull(paramNames[i], paranValues[i], parameterTypes[i] == null ? null : parameterTypes[i].getName());
                    break;
                }
                //如果该参数前面的注解不为空并且是ParamCheck的实例，并且默认值不为空，并且参数值为空，则进行赋默认值
                if(parameterAnnotations[i][j] != null && parameterAnnotations[i][j] instanceof ParamCheck && !StringUtils.isEmpty(((ParamCheck)parameterAnnotations[i][j]).defaultValue()) && (paranValues[i] == null || StringUtils.isEmpty(paranValues[i].toString()))){
                    paranValues[i] = putParam(((ParamCheck)parameterAnnotations[i][j]).defaultValue(), parameterTypes[i]);
                }
            }
        }
        return pjp.proceed(paranValues);
    }

    /**
     * 在切入点return内容之后切入内容（可以用来对处理返回值做一些加工处理）
     * TODO 留着做以后处理返回值用
     * @param joinPoint
     */
    @AfterReturning(value = "checkParam()", returning = "result")
    public void doAfterReturning(JoinPoint joinPoint, Object result) {
      
    }

    /**
     * 参数非空校验，如果参数为空，则抛出ParamIsNullException异常
     * @param paramName
     * @param value
     * @param parameterType
     */
    private void paramIsNull(String paramName, Object value, String parameterType) {
        if (value == null || "".equals(value.toString().trim())) {
            throw new ParamIsNullException(paramName, parameterType, "，不能为空！");
        }
        if ("undefined".equals(value.toString().trim())){
            throw new ParamIsNullException(paramName, parameterType, "，不能为undefined！");
        }
    }

    private Object putParam(Object value, Class<?> parameterType){
        return CastValueTypeUtil.parseValue(parameterType, value.toString());
    }

}

```

其中有两个Java类，一个是Value转换，一个是自定义异常，转换类的意义在于，默认值在赋予的时候是String字符串，但是实际赋值的时候，给参数赋值，是不确定元素，可以确实的是，这个参数肯定是八大类型中的其中一个

```java
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * 转换Object类型
 *
 */
public class CastValueTypeUtil {

    public static Object parseValue(Class<?> parameterTypes, String value) {

        if(value==null || value.trim().length()==0){
            return null;
        }
        value = value.trim();

		if (Byte.class.equals(parameterTypes) || Byte.TYPE.equals(parameterTypes)) {
			return parseByte(value);
		} else if (Boolean.class.equals(parameterTypes) || Boolean.TYPE.equals(parameterTypes)) {
            return parseBoolean(value);
        }/* else if (Character.class.equals(fieldType) || Character.TYPE.equals(fieldType)) {
			 return value.toCharArray()[0];
		}*/ else if (String.class.equals(parameterTypes)) {
            return value;
        } else if (Short.class.equals(parameterTypes) || Short.TYPE.equals(parameterTypes)) {
            return parseShort(value);
        } else if (Integer.class.equals(parameterTypes) || Integer.TYPE.equals(parameterTypes)) {
            return parseInt(value);
        } else if (Long.class.equals(parameterTypes) || Long.TYPE.equals(parameterTypes)) {
            return parseLong(value);
        } else if (Float.class.equals(parameterTypes) || Float.TYPE.equals(parameterTypes)) {
            return parseFloat(value);
        } else if (Double.class.equals(parameterTypes) || Double.TYPE.equals(parameterTypes)) {
            return parseDouble(value);
        } else if (Date.class.equals(parameterTypes)) {
            return parseDate(value);
        } else {
            throw new RuntimeException("request illeagal type, type must be Integer not int Long not long etc, type=" + parameterTypes);
        }
    }

    public static Byte parseByte(String value) {
        try {
            value = value.replaceAll("　", "");
            return Byte.valueOf(value);
        } catch(NumberFormatException e) {
            throw new RuntimeException("parseByte but input illegal input=" + value, e);
        }
    }

    public static Boolean parseBoolean(String value) {
        value = value.replaceAll("　", "");
        if (Boolean.TRUE.toString().equalsIgnoreCase(value)) {
            return Boolean.TRUE;
        } else if (Boolean.FALSE.toString().equalsIgnoreCase(value)) {
            return Boolean.FALSE;
        } else {
            throw new RuntimeException("parseBoolean but input illegal input=" + value);
        }
    }

    public static Integer parseInt(String value) {
        try {
            value = value.replaceAll("　", "");
            return Integer.valueOf(value);
        } catch(NumberFormatException e) {
            throw new RuntimeException("parseInt but input illegal input=" + value, e);
        }
    }

    public static Short parseShort(String value) {
        try {
            value = value.replaceAll("　", "");
            return Short.valueOf(value);
        } catch(NumberFormatException e) {
            throw new RuntimeException("parseShort but input illegal input=" + value, e);
        }
    }

    public static Long parseLong(String value) {
        try {
            value = value.replaceAll("　", "");
            return Long.valueOf(value);
        } catch(NumberFormatException e) {
            throw new RuntimeException("parseLong but input illegal input=" + value, e);
        }
    }

    public static Float parseFloat(String value) {
        try {
            value = value.replaceAll("　", "");
            return Float.valueOf(value);
        } catch(NumberFormatException e) {
            throw new RuntimeException("parseFloat but input illegal input=" + value, e);
        }
    }

    public static Double parseDouble(String value) {
        try {
            value = value.replaceAll("　", "");
            return Double.valueOf(value);
        } catch(NumberFormatException e) {
            throw new RuntimeException("parseDouble but input illegal input=" + value, e);
        }
    }

    public static Date parseDate(String value) {
        try {
            String datePattern = "yyyy-MM-dd HH:mm:ss";
            SimpleDateFormat dateFormat = new SimpleDateFormat(datePattern);
            return dateFormat.parse(value);
        } catch(ParseException e) {
            throw new RuntimeException("parseDate but input illegal input=" + value, e);
        }
    }

}

```

#### 二、切面的常用术语

**Join point**: 拦截点，如某个业务方法。
 **Pointcut**: Joinpoint 的表达式，表示拦截哪些方法。一个 Pointcut 对应多个 Joinpoint。
 **Advice**: 要切入的逻辑。
  BeforeAdvice 在方法前切入。
  After Advice 在方法后切入，抛出异常时也会切入。
  AfterReturningAdvice 在方法返回后切入，抛出异常则不会切入。
  AfterThrowingAdvice 在方法抛出异常时切入。
  Around Advice 在方法执行前后切入，可以中断或忽略原有流程的执行。

#### 三、切入点表达式示意图

Spring AOP支持的AspectJ切入点指示符

![image-20200916104804831](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200916104804831.png)





![img](https://upload-images.jianshu.io/upload_images/10401770-5e01843fd0faf511.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

![img](https://upload-images.jianshu.io/upload_images/10401770-c903eff1498b2cf7.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

例如定义切入点表达式 **execution (\* com.sample.service.impl..\*.\*(..))**

execution()是最常用的切点函数，其语法如下所示：

 整个表达式可以分为五个部分：

1、execution(): 表达式主体。

 2、第一个\*号：表示返回类型，*号表示所有的类型。

 3、包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.sample.service.impl包、子孙包下所有类的方法。

 4、第二个\*号：表示类名，*号表示所有的类。

 5、*(..):**最后这个星号**表示方法名，\*号表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数。

 *：匹配任何数量字符；

​     ..：匹配任何数量字符的重复，如在类型模式中**匹配任何数量子包**；而在方法参数模式中匹配**任何数量参数**。

​     +：匹配指定类型的子类型；仅能作为后缀放在类型模式后边。

![image-20200916104616615](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916104616.png)

#### 四、组合切入点表达式

>  AspectJ使用 且（&&）、或（||）、非（！）来组合切入点表达式。
>
> ​    在Schema风格下，由于在XML中使用“&&”需要使用转义字符“&amp;&amp;”来代替之，所以很不方便，因此Spring ASP 提供了and、or、not来代替&&、||、！。

####  五、切入点使用示例

一、execution：使用“execution(方法表达式)”匹配方法执行；

![image-20200916105221348](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916105221.png)

![image-20200916105244104](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916105244.png)

**二**、***within***：使用“within(类型表达式)匹配指定类型内的方法执行；

![image-20200916105424763](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916105424.png)

三、this：**使用“**this(**类型全限定名**)**”匹配当前**AOP**代理对象类型的执行方法；注意是**AOP**代理对象的类型匹配，这样就可能包括引入接口方法也可以匹配；注意**this**中使用的表达式必须是类型全限定名，不支持通配符；

![image-20200916105535051](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916105535.png)

四、target：使用**target(**类型全限定名**)**”匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；注意**target**中使用的表达式必须是类型全限定名，不支持通配符；

![image-20200916110829921](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916110830.png)

五、args：使用“**args(**参数类型列表**)**”匹配当前执行的方法传入的参数为指定类型的执行方法；注意是匹配传入的参数类型，不是匹配方法签名的参数类型；参数类型列表中的参数必须是类型全限定名，通配符不支持；**args**属于动态切入点，这种切入点开销非常大，**非特殊情况最好不要使用**；

![image-20200916110845576](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916110845.png)

***六、******@within***：使用@within(注解类型)匹配所以持有指定注解类型内的方法；注解类型也必须是全限定类型名；

![image-20200916110926032](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916110926.png)

***七、******@target******：****使用“**@target(**注解类型**)**”匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；注解类型也必须是全限定类型名；* 

![image-20200916111025389](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916111025.png)

***八、******@args******：****使用“**@args(**注解列表**)**”匹配当前执行的方法传入的参数持有指定注解的执行；注解类型也必须是全限定类型名；*

![image-20200916111057570](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916111057.png)

***九、******@annotation******：****使用“**@annotation(**注解类型**)**”匹配当前执行方法持有指定注解的方法；注解类型也必须是全限定类型名；*

![image-20200916111130962](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916111131.png)

**十、**bean**：**使用“bean(Bean id或名字通配符)”匹配特定名称的Bean对象的执行方法；Spring ASP扩展的，在AspectJ中无相应概念

![image-20200916111212635](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916111212.png)

#### 六、通知参数

获取被被通知方法参数并传递给通知方法，该如何实现呢？接下来我们将介绍两种获取通知参数的方式。

- **使用JoinPoint**获取：Spring AOP提供使用org.aspectj.lang.JoinPoint类型获取连接点数据，任何通知方法的第一个参数都可以是JoinPoint(环绕通知是ProceedingJoinPoint，JoinPoint子类)，当然第一个参数位置也可以是JoinPoint.StaticPart类型，这个只返回连接点的静态部分。

**1) JoinPoint**：提供访问当前被通知方法的目标对象、代理对象、方法参数等数据：

![image-20200916111708207](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200916111708.png)

**2**）ProceedingJoinPoint：用于环绕通知，使用proceed()方法来执行目标方法：

![image-20210318210931693](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210318210933.png)







#### 七、AOP各种实现优缺点：

![img](https://upload-images.jianshu.io/upload_images/10401770-bbb2e322045a5da4.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)



#### 八、Aop自定义注解

```java
package com.nd.elearning.spaceconfig.gateway.core.cache;

import com.google.common.collect.Sets;
import com.nd.gaea.core.utils.StringUtils;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import redis.clients.jedis.JedisCommands;
import redis.clients.jedis.MultiKeyCommands;
import redis.clients.jedis.ScanParams;
import redis.clients.jedis.ScanResult;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * @description: 注解（com.nd.elearning.spaceconfig.gateway.core.cache.CacheRemove）缓存清理切面, 支持通配符key scan清理
 * @author: Chenql
 * @time: 2020/10/13 17:43
 */

@Component
@Aspect
@Slf4j
public class CacheRemoveAspect {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    @Pointcut(value = "execution(* *.*(..)) && @annotation(com.nd.elearning.spaceconfig.gateway.core.cache.CacheRemove)")
    private void pointCut() {

    }

    @AfterReturning(value = "pointCut()")
    private void process(JoinPoint joinPoint) {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        String[] parameterNames = signature.getParameterNames();
        Map<String, Object> paramValueMap = new HashMap<>(8);
        if (parameterNames.length > 0) {
            Object[] args = joinPoint.getArgs();
            for (int i = 0; i < parameterNames.length; i++) {
                paramValueMap.put(parameterNames[i], args[i]);
            }
        }
        CacheRemove cacheRemove = method.getAnnotation(CacheRemove.class);
        if (cacheRemove != null) {
            String value = cacheRemove.value();
            if (StringUtils.isNotBlank(value)) {
                this.cleanCache(cacheRemove.cacheName(), value);
            }
            String[] keys = cacheRemove.key();
            if (keys.length > 0) {
                for (String key : keys) {
                    Object keyParam = paramValueMap.get(key);
                    if (keyParam != null) {
                        key = keyParam.toString();
                    }
                    this.cleanCache(cacheRemove.cacheName(), key);
                }
            }
        }
    }

    private void cleanCache(String keyPrefix, String key) {
        if (StringUtils.isNotBlank(key)) {
            Set<String> keys = this.keys(keyPrefix, key);
            this.redisTemplate.delete(keys);
        }
    }

    public Set<String> keys(String keyPrefix, String key) {
        String keyPattern = keyPrefix + "*" + key + "*";
        return this.redisTemplate.execute((RedisCallback<Set<String>>) connection -> {
            Set<String> binaryKeys = Sets.newHashSet();
            JedisCommands commands = (JedisCommands) connection.getNativeConnection();
            MultiKeyCommands multiKeyCommands = (MultiKeyCommands) commands;
            ScanParams scanParams = new ScanParams();
            scanParams.match(keyPattern);
            scanParams.count(1000);
            ScanResult<String> scanResult = multiKeyCommands.scan("0", scanParams);
            while (null != scanResult.getStringCursor()) {
                binaryKeys.addAll(scanResult.getResult());
                if (!StringUtils.equals("0", scanResult.getStringCursor())) {
                    scanResult = multiKeyCommands.scan(scanResult.getStringCursor(), scanParams);
                    continue;
                } else {
                    break;
                }
            }
            return binaryKeys;
        });
    }
}

```



## Elastcsearch



## java日志

> log4j定义了8个级别的log（除去OFF和ALL，可以说分为6个级别），**优先级从高到低**依次为：OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE、 ALL。
>
> **ALL：**最低等级的，用于打开所有日志记录。
>
> **TRACE：** designates finer-grained informational events than the DEBUG.Since:1.2.12，很低的日志级别，一般不会使用。
>
> **DEBUG：** 指出细粒度信息事件对调试应用程序是非常有帮助的，主要用于开发过程中打印一些运行信息。
>
> **INFO：** 消息在粗粒度级别上突出强调应用程序的运行过程。打印一些你感兴趣的或者重要的信息，这个可以用于生产环境中输出程序运行的一些**重要信息**，但是**不能滥用**，避免打印 　　　　过多的日志。
>
> **WARN：** 表明会出现潜在错误的情形，有些信息不是错误信息，但是也要给程序员的一些提示。
>
> **ERROR：** 指出虽然发生错误事件，但仍然不影响系统的继续运行。打印错误和异常信息，如果不想输出太多的日志，可以使用这个级别。
>
> **FATAL：** 指出每个严重的错误事件将会导致应用程序的退出。这个级别比较高了。重大错误，这种级别你可以直接停止程序了。
>
> **OFF：** 最高等级的，用于关闭所有日志记录。
>
> 如果将log level**设置在某一个级别上**，那么比此级别优先级高的log都能打印出来。例如，如果设置优先级为WARN，那么OFF、FATAL、ERROR、WARN 4个级别的log能正常       输出，而INFO、DEBUG、TRACE、 ALL级别的log则会被忽略。Log4j建议只使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。
>
> 从我们实验的结果可以看出，**log4j默认的优先级为ERROR或者WARN**（实际上是ERROR）。





## SpringBoot + Log4j2使用配置

参考文档：https://www.cnblogs.com/guanbin-529/p/12771075.html

#### 一、pom.xml文件添加依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
```

#### 二、配置log4j2.xml文件

##### 实际配置实例（1）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，
 你会看到log4j2内部各种详细输出。可以设置成OFF(关闭)或Error(只输出错误信息)
-->
<Configuration status="WARN" monitorInterval="30">
    <Properties>
        <Property name="App">demo</Property>
        <Property name="logDir">logs</Property>
        <Property name="splitSize">30 MB</Property>
    </Properties>
 
    <Appenders>
        <!-- 输出控制台日志的配置 -->
        <Console name="console" target="SYSTEM_OUT">
            <!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）-->
            <ThresholdFilter level="info" onMatch="ACCEPT" onMismatch="DENY"/>
            <!-- 输出日志的格式 -->
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </Console>
 
        <!-- 打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 -->
        <RollingRandomAccessFile name="infoLog" fileName="${logDir}/${App}-info.log" immediateFlush="false"
                                 filePattern="${logDir}/$${date:yyyy-MM}/${App}-info-%d{MM-dd-yyyy}-%i.log.gz"
                                 append="true">
            <PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss z} [%t] %-5level %logger{36} %L %M - %msg%xEx%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy interval="6" modulate="true"/>
                <SizeBasedTriggeringPolicy size="${splitSize}"/>
            </Policies>
            <Filters>
                <!-- 只记录info和warn级别信息 -->
                <ThresholdFilter level="error" onMatch="DENY" onMismatch="NEUTRAL"/>
                <ThresholdFilter level="info" onMatch="ACCEPT" onMismatch="DENY"/>
            </Filters>
            <!-- 指定每天的最大压缩包个数，默认7个，超过了会覆盖之前的 -->
            <DefaultRolloverStrategy max="50"/>
        </RollingRandomAccessFile>
 
        <!-- 存储所有error信息 -->
        <RollingRandomAccessFile name="errorLog" fileName="${logDir}/${App}-error.log" immediateFlush="false"
                                 filePattern="${logDir}/$${date:yyyy-MM}/${App}-error-%d{MM-dd-yyyy}-%i.log.gz"
                                 append="false">
            <PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss z} [%t] %-5level %logger{36} %L %M - %msg%xEx%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy interval="6" modulate="true"/>
                <SizeBasedTriggeringPolicy size="${splitSize}"/>
            </Policies>
            <Filters>
                <!-- 只记录error级别信息 -->
                <ThresholdFilter level="error" onMatch="ACCEPT" onMismatch="DENY"/>
            </Filters>
            <!-- 指定每天的最大压缩包个数，默认7个，超过了会覆盖之前的 -->
            <DefaultRolloverStrategy max="50"/>
        </RollingRandomAccessFile>
    </Appenders>
 
    <Loggers>
        <!-- root logger 配置,全局配置，默认所有的Logger都继承此配置 -->
        <!-- AsyncRoot - 异步记录日志 - 需要LMAX Disruptor的支持 -->
        <Root includeLocation="true" additivity="true">
            <AppenderRef ref="infoLog"/>
            <AppenderRef ref="errorLog"/>
            <AppenderRef ref="console"/>
        </Root>
 
        <!--第三方的软件日志级别 -->
        <logger name="org.springframework" level="info" additivity="true">
        </logger>
 
    </Loggers>
</Configuration>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="warn" monitorInterval="300">
    <!--文件输出地址-->
    <properties>
        <property name="LOG_HOME">E:/testlog</property>
   </properties>
    <Appenders>
    <!--控制台输出-->
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n" />
        </Console>

        
       <!--  ACCEPT（放行）、DENY（拒绝）、NEUTRAL（不做任何操作)        -->                                                               
       <!--  onMatch  >= level  onMatch指的是日志级别大于等于level时的操作      -->                
       <!--  onMismatch < levle onMismatch表示日志级别小于level时的操作,         -->                    
       <!--  log 级别  off>fatal>error>warn>info>debug>trace>all,                            -->                   
       <!--   通过添加两组 ThresholdFilter  可以达到一个级别的log一个文件的目的,-->             
       
        <!--info及以上级别输出-->
        <RollingRandomAccessFile name="InfoFile"
                                 fileName="${LOG_HOME}/info.log"
                                 filePattern="${LOG_HOME}/$${date:yyyy-MM}/info-%d{yyyy-MM-dd HH-mm}-%i.log">
            <Filters>
                <!--<ThresholdFilter level="warn" onMatch="DENY" onMismatch="NEUTRAL"/>-->
                <ThresholdFilter level="info" onMatch="ACCEPT" onMismatch="DENY"/>
            </Filters>
            <PatternLayout
                    pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n" />
            <Policies>
                <TimeBasedTriggeringPolicy interval="1" />
                <SizeBasedTriggeringPolicy size="10 MB" />
            </Policies>
            <DefaultRolloverStrategy max="20" />
        </RollingRandomAccessFile>
        <!--warn及以上级别输出-->
        <RollingRandomAccessFile name="warnFile"
                                 fileName="${LOG_HOME}/warn.log"
                                 filePattern="${LOG_HOME}/$${date:yyyy-MM}/warn-%d{yyyy-MM-dd HH-mm}-%i.log">
            <Filters>
                <!--<ThresholdFilter level="warn" onMatch="DENY" onMismatch="NEUTRAL"/>-->
                <ThresholdFilter level="warn" onMatch="ACCEPT" onMismatch="DENY"/>
            </Filters>
            <PatternLayout
                    pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n" />
            <Policies>
                <TimeBasedTriggeringPolicy interval="1" />
                <SizeBasedTriggeringPolicy size="10 MB" />
            </Policies>
            <DefaultRolloverStrategy max="20" />
        </RollingRandomAccessFile>
        <!--debug及以上级别输出-->
        <RollingRandomAccessFile name="debugFile"
                                 fileName="${LOG_HOME}/debug.log"
                                 filePattern="${LOG_HOME}/$${date:yyyy-MM}/debug-%d{yyyy-MM-dd HH-mm}-%i.log">
            <Filters>
                <!--<ThresholdFilter level="warn" onMatch="DENY" onMismatch="NEUTRAL"/>-->
                <ThresholdFilter level="debug" onMatch="ACCEPT" onMismatch="DENY"/>
            </Filters>
            <PatternLayout
                    pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n" />
            <Policies>
                <TimeBasedTriggeringPolicy interval="1" />
                <SizeBasedTriggeringPolicy size="10 MB" />
            </Policies>
            <DefaultRolloverStrategy max="20" />
        </RollingRandomAccessFile>
        <!--error及以上级别输出-->
        <RollingRandomAccessFile name="ErrorFile"
                                 fileName="${LOG_HOME}/error.log"
                                 filePattern="${LOG_HOME}/$${date:yyyy-MM}/error-%d{yyyy-MM-dd HH-mm}-%i.log">
            <Filters>
                <!--<ThresholdFilter level="fatal" onMatch="DENY" onMismatch="NEUTRAL" />-->
                <ThresholdFilter level="error" onMatch="ACCEPT" onMismatch="DENY" />
            </Filters>
            <PatternLayout
                    pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n" />
            <Policies>
                <TimeBasedTriggeringPolicy interval="1" />
                <SizeBasedTriggeringPolicy size="10 MB" />
            </Policies>
            <DefaultRolloverStrategy max="20" />
        </RollingRandomAccessFile>
        <!--fatal及以上级别输出-->
        <RollingRandomAccessFile name="FatalFile"
                                 fileName="${LOG_HOME}/fatal.log"
                                 filePattern="${LOG_HOME}/$${date:yyyy-MM}/fatal-%d{yyyy-MM-dd HH-mm}-%i.log">
            <Filters>
                <ThresholdFilter level="fatal" onMatch="ACCEPT" onMismatch="DENY" />
            </Filters>
            <PatternLayout
                    pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n" />
            <Policies>
                <TimeBasedTriggeringPolicy interval="1" />
                <SizeBasedTriggeringPolicy size="10 MB" />
            </Policies>
            <DefaultRolloverStrategy max="20" />
        </RollingRandomAccessFile>

    </Appenders>
    <!--将所有输出记录到下面-->
    <Loggers>
    <!--控制第三方log级别-->
        <Logger name="RocketmqClient" level="warn"/>
        <Logger name="RocketmqRemoting" level="warn"/>
        <Logger name="org.apache.kafka" level="warn"/>
        <Logger name=" com.alibaba.dubbo" level="warn"/>
        <Logger name="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor" level="warn"/>
        <Logger name="org.springframework.jmx.export.annotation.AnnotationMBeanExporter" level="warn"/>
        <Logger name="org.springframework.context.annotation.AnnotationConfigApplicationContext" level="warn"/>
        <Logger name="com.alibaba.druid.pool.DruidDataSource" level="warn"/>
        <Logger name="org.springframework.data.repository.config.RepositoryConfigurationDelegate" level="warn"/>
  <!--可以指定具体的类的log,输出到某个文件-->
  <Logger name="com.seif.flumesink.FlumesinkApplication" level="trace" additivity="false">
            <AppenderRef ref="InfoFile"/>
     </Logger>
        <Root level="trace">
            <AppenderRef ref="Console" />
            <AppenderRef ref="InfoFile" />
            <AppenderRef ref="ErrorFile" />
            <AppenderRef ref="FatalFile" />
            <AppenderRef ref="warnFile" />
            <AppenderRef ref="debugFile" />
        </Root>
    </Loggers>
</Configuration>
```

##### 实际配置实例（2）

```xml
<?xml version="1.0" encoding="UTF-8"?>
 
<configuration status="WARN">
    <properties>
        <property name="LOG_HOME">logs</property>
        <property name="FILE_NAME">API</property>
    </properties>
 
    <!-- ${sys:catalina.home}指当前tomcat根目录 -->
 
    <appenders>
        <!-- 日志输出到控制台 -->
        <Console name="Console" target="SYSTEM_OUT">
            <!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）-->
            <!--level：TRACE < DEBUG < INFO < WARN < ERROR < FATAL-->
            <ThresholdFilter level="DEBUG" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss.SSS z} [%t] %-5level %logger{36} - %msg%n"/>
        </Console>
 
        <!--
            循环日志文件：日志文件大于阀值的时候，就开始写一个新的日志文件
            这个会打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档
            fileName    : 指定当前日志文件的位置和文件名称
            filePattern : 指定当发生Rolling时，文件的转移和重命名规则
            SizeBasedTriggeringPolicy : 指定当文件体积大于size指定的值时，触发Rolling
            DefaultRolloverStrategy : 指定每天最多保存的文件个数，默认为7
            TimeBasedTriggeringPolicy : 这个配置需要和filePattern结合使用
                注意filePattern中配置的文件重命名规则是${FILE_NAME}_%d{yyyy-MM-dd}_%i，最小的时间粒度是dd，即天，
                TimeBasedTriggeringPolicy指定的size是1，结合起来就是每1天生成一个新文件
            onMatch/onMismatch：
                ACCEPT：接受匹配，DENY：禁止匹配，NEUTRAL：不做处理，让后续代码做处理。
        -->
 
        <!-- 输入INFO级别的日志到文件 -->
        <RollingRandomAccessFile name="INFO" fileName="${sys:catalina.home}/logs/${FILE_NAME}-info.log" filePattern="${sys:catalina.home}/log/${FILE_NAME}-info_%d{yyyy-MM-dd}_%i.log.gz">
            <Filters>
                <ThresholdFilter level="WARN" onMatch="DENY" onMismatch="NEUTRAL"/>
                <ThresholdFilter level="TRACE" onMatch="ACCEPT" onMismatch="DENY"/>
            </Filters>
            <PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss.SSS z} %-5level %class{36} %L %M - %msg%xEx%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy interval="1"/>
                <SizeBasedTriggeringPolicy size="100MB"/>
            </Policies>
            <!-- 每天最大允许存在压缩的文件数，超过了这个数量，前面的文件会自己清除，如果不写，默认数为7 -->
            <DefaultRolloverStrategy max="100"/>
        </RollingRandomAccessFile>
 
        <!--输入ERROR级别的日志到文件-->
        <RollingRandomAccessFile name="ERROR" fileName="${sys:catalina.home}/logs/${FILE_NAME}-error.log" filePattern="${sys:catalina.home}/log/${FILE_NAME}-error_%d{yyyy-MM-dd}_%i.log.gz">
            <Filters>
                <ThresholdFilter level="FATAL" onMatch="DENY" onMismatch="NEUTRAL"/>
                <ThresholdFilter level="WARN" onMatch="ACCEPT" onMismatch="DENY"/>
            </Filters>
            <PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss.SSS z} %-5level %class{36} %L %M - %msg%xEx%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy interval="1"/>
                <SizeBasedTriggeringPolicy size="100MB"/>
            </Policies>
            <DefaultRolloverStrategy max="100"/>
        </RollingRandomAccessFile>
 
        <!--输入FATAL级别的日志到文件-->
        <RollingRandomAccessFile name="FATAL" fileName="${sys:catalina.home}/logs/${FILE_NAME}-fatal.log" filePattern="${sys:catalina.home}/log/${FILE_NAME}-fatal_%d{yyyy-MM-dd}_%i.log.gz">
            <Filters>
                <ThresholdFilter level="FATAL" onMatch="ACCEPT" onMismatch="DENY"/>
            </Filters>
            <PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss.SSS z} %-5level %class{36} %L %M - %msg%xEx%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy interval="1"/>
                <SizeBasedTriggeringPolicy size="100MB"/>
            </Policies>
            <DefaultRolloverStrategy max="100"/>
        </RollingRandomAccessFile>
 
        <RollingRandomAccessFile name="REQS" fileName="${sys:catalina.home}/logs/${FILE_NAME}-reqs.log" filePattern="${sys:catalina.home}/log/${FILE_NAME}-reqs_%d{yyyy-MM-dd}_%i.log.gz">
            <Filters>
                <ThresholdFilter level="INFO" onMatch="ACCEPT" onMismatch="DENY"/>
            </Filters>
            <PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss.SSS z} %-5level %class{36} %L %M - %msg%xEx%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy interval="1"/>
                <SizeBasedTriggeringPolicy size="100MB"/>
            </Policies>
            <!-- 每天最大允许存在压缩的文件数，超过了这个数量，前面的文件会自己清除，如果不写，默认数为7 -->
            <DefaultRolloverStrategy max="100"/>
        </RollingRandomAccessFile>
 
    </appenders>
    <loggers>
        <logger name="com.iotlead.hardware.api.business.impls.ApiLogService" additivity="false">
            <priority value ="info"/>
            <appender-ref ref="Console" />
            <appender-ref ref="REQS" />
        </logger>
 
        <!--日志等级，部署时一定要改成ERROR  等级：TRACE < DEBUG < INFO < WARN < ERROR < FATAL-->
        <root level="DEBUG">
            <!-- 输入日志到控制台 -->
            <appender-ref ref="Console"/>
 
            <!-- 输入日志到文件 -->
            <!--<appender-ref ref="INFO"/>-->
 
            <!-- 输入错误日志到文件 -->
            <!--<appender-ref ref="ERROR"/>-->
 
            <!-- 输入系统错误日志到文件 -->
            <!--<appender-ref ref="FATAL"/>-->
        </root>
    </loggers>
</configuration>
```

三个appender：console、infoLog、errorLog

- console 通过ThresholdFilter过滤规则只输出info级别的错误(onMatch="ACCEPT" onMismatch="DENY" 匹配到的接受，没有匹配的走人)
- infoLog 也通过ThresholdFilter的方式输出到日志，当然了append="true" 会在服务每次启动的时候追加日志

##### 日志级别

> 机制：如果一条日志信息的级别大于等于配置文件的级别，就记录。

- trace：追踪，就是程序推进一下，可以写个trace输出
- debug：调试，一般作为最低级别，trace基本不用。
- info：输出重要的信息，使用较多
- warn：警告，有些信息不是错误信息，但也要给程序员一些提示。
- error：错误信息。用的也很多。
- fatal：致命错误。

##### 输出源

- CONSOLE（输出到控制台）
- FILE（输出到文件）

##### 格式

- SimpleLayout：以简单的形式显示

- HTMLLayout：以HTML表格显示

- PatternLayout：自定义形式显示

  PatternLayout自定义日志布局：

  > %d{yyyy-MM-dd HH:mm:ss, SSS} : 日志生产时间,输出到毫秒的时间 
  >
  > %-5level : 输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0 
  >
  > %c : logger的名称(%logger) %t : 输出当前线程名称 
  >
  > %p : 日志输出格式 
  >
  > %m : 日志内容，即 logger.info("message") 
  >
  > %n : 换行符 %C : Java类名(%F) 
  >
  > %L : 行号 
  >
  > %M : 方法名 
  >
  > %l : 输出语句所在的行数, 包括类名、方法名、文件名、行数 
  >
  > hostName : 本地机器名 
  >
  > hostAddress : 本地ip地址

##### status和monitorInterval含义

> 我们看到，Configuration有2个属性status和monitorInterval，它们分别是log4j2自身组件的日志级别以及重新刷新配置文件的时间，通过配置status可以看到log4j2相关的日志，配置monitorInterval可以通过修改配置文件来改变日志配置。

##### log4j2的层次结构

log4j2.xml文件的配置大致如下：

![img](https://img-blog.csdn.net/20170419181417841)

- **Configuration**
  - properties
  - Appenders
    - Console
      - PatternLayout
    - File
    - RollingRandomAccessFile
    - Async
  - Loggers
    - Logger
    - Root
      - AppenderRef



- **Configuration**：为**根节点**，有**status**和**monitorInterval**等多个属性
  - status的值有 “trace”, “debug”, “info”, “warn”, “error” and “fatal”，用于控制log4j2日志框架本身的日志级别，如果将stratus设置为较低的级别就会看到很多关于log4j2本身的日志，如**加载log4j2配置文件的路径**等信息
  - **monitorInterval**，含义是**每隔多少秒重新读取配置文件**，可以**不重启应用**的情况下修改配置
- **Appenders**：**输出源**，用于定义日志输出的地方
  log4j2支持的输出源有很多，有控制台Console、文件File、RollingRandomAccessFile、MongoDB、Flume 等
  - Console：控制台输出源是将日志打印到控制台上，开发的时候一般都会配置，以便调试
  - File：文件输出源，用于将日志写入到指定的文件，需要配置输入到哪个位置（例如：D:/logs/mylog.log）
  - RollingRandomAccessFile: 该输出源也是写入到文件，不同的是比File更加强大，可以指定当文件达到一定大小（如20MB）时，另起一个文件继续写入日志，另起一个文件就涉及到新文件的名字命名规则，因此需要配置文件命名规则
    这种方式更加实用，因为你不可能一直往一个文件中写，如果一直写，文件过大，打开就会卡死，也不便于查找日志。
    - fileName 指定当前日志文件的位置和文件名称
    - filePattern 指定当发生Rolling时，文件的转移和重命名规则
    - SizeBasedTriggeringPolicy 指定当文件体积大于size指定的值时，触发Rolling
    - DefaultRolloverStrategy 指定最多保存的文件个数
    - TimeBasedTriggeringPolicy 这个配置需要和filePattern结合使用，注意filePattern中配置的文件重命名规则是${FILE_NAME}-%d{yyyy-MM-dd HH-mm}-%i，最小的时间粒度是mm，即分钟
    - TimeBasedTriggeringPolicy指定的size是1，结合起来就是每1分钟生成一个新文件。如果改成%d{yyyy-MM-dd HH}，最小粒度为小时，则每一个小时生成一个文件
  - NoSql：MongoDb, 输出到MongDb数据库中
  - Flume：输出到Apache Flume（Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。）
  - Async：异步，需要通过AppenderRef来指定要对哪种输出源进行异步（一般用于配置RollingRandomAccessFile）

> 从上面的log4j2.xml配置文件中，我们可以看到log4j2的配置文件中主要分为2块，一块为**appender**，描述了如何记录日志，另外一部分是**log config**，记录了哪种日志对应哪种级别。 而不同的LogConfig之间其实是有继承关系的，子LogConfig会继承parent的属性，而所有LogConfig都继承自Root LogConfig。所以即使只配置了root logger，你一样可以在任何地方通过LoggerFactory.getLogger获取一个logger对象，记录日志。
>
> 那么日志之间的继承关系是由什么决定的呢？看看上面的配置文件中root以外的2个logConfig，只有3个配置：日志级别，name以及appender，从直觉上看应当是name最可能决定了LogConfig的继承关系，其实也正是如此：com.foo是com.foo.Bar的父级；java是java.util的父级，是java.util.vector的祖先（注意name区分大小写）。
>
> 理解了这一点，我们就能理清log4j2配置的思路：**先配置一个root**，让所有需要使用**日志的logger继承**，然后对有特别**需要的logger进行特殊的配置**，比如我们希望org.springframework包只记录error以及warn级别的log，再比如，我们希望能显示mybatis执行的sql的日志，都可以进行个性化的配置。





##### appender的配置

> appender是LogConfig的重要组成部分，一个LogConfig可以使用多个appender，一个appender也可以被多个LogConfig使用，appender多种多样，不同的appender也有不同的属性和配置，难以一一阐述，需要使用时可以直接查看文档来进行个性化配置。不过就filters可以单独拿出来讨论一下。
>
> filter有两个重要属性onMatch和onMismatch。可以有DENY、ACCEPT或NEUTRAL配置:
>
> - DENY说明不由当前appender处理
> - ACCEPT说明由当前filter处理
> - NEUTRAL说明如果按顺序还有其他filter则由其他filter处理，如果当前filter已经是最后一个filter，则由当前appender处理。

##### Loggers：日志器

日志器分根日志器Root和自定义日志器，当根据日志名字获取不到指定的日志器时就使用Root作为默认的日志器，自定义时需要指定每个Logger的名称name（对于命名可以以包名作为日志的名字，不同的包配置不同的级别等），日志级别level，相加性additivity（是否继承下面配置的日志器）， 对于一般的日志器（如Console、File、RollingRandomAccessFile）一般需要配置一个或多个输出源AppenderRef；

每个logger可以指定一个level（TRACE, DEBUG, INFO, WARN, ERROR, ALL or OFF），不指定时level默认为ERROR

additivity指定是否同时输出log到父类的appender，缺省为true。

Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。

使用`Logger`元素必须有一个**name属性**，**root logger不用name元属性**
每个`Logger`可以使用TRACE，DEBUG，INFO，WARN，ERROR，ALL或OFF之一配置级别。如果未指定级别，则默认为ERROR。可以为additivity属性分配值true或false。如果省略该属性，则将使用默认值true。

`Logger`还可以配置**一个或多个AppenderRef属性**。引用的每个appender将与指定的`Logger`关联。如果在`Logger`上配置了多个appender，则在处理日志记录事件时会调用每个appender。

- **name：**用来指定该Logger所适用的类或者类所在的包全路径，继承自Root节点。一般是项目包名或者框架的包名，比如：com.jourwon，org.springframework
- **level**：日志输出级别，共有8个级别，按照从低到高为：All < Trace < Debug < Info < Warn < Error < Fatal < OFF
- **AppenderRef：**Logger的子节点，用来指定该日志输出到哪个Appender，如果没有指定，就会默认继承自Root。如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出，此时我们可以设置Logger的additivity="false"只在自定义的Appender中进行输出。

###### **Loggers 注册日志输出对象**

Logger 日志输出对象

![](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201023150145.png)





代码说明

![image-20201023150359884](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201023150400.png)



```xml
<Logger name="rollingRandomAccessFileLogger" level="trace" additivity="true">  
	<AppenderRef ref="RollingRandomAccessFile" />  
</Logger>
```

```xml
   <Loggers>
        <!--过滤掉spring和mybatis的一些无用的DEBUG信息-->
        <logger name="org.springframework" level="INFO"/>
        <logger name="org.mybatis" level="INFO"/>
        <Logger name="mylog" level="debug" additivity="false">
            <AppenderRef ref="MyFile"/>
            <AppenderRef ref="Console"/>
        </Logger>
        <Root level="debug">
            <AppenderRef ref="MyFile"/>
            <AppenderRef ref="Console"/>
        </Root>
    </Loggers>
```

##### properties: 属性

> 使用来定义常量，以便在其他配置的时候引用，该配置是可选的，例如定义日志的存放位置
> D:/logs

##### 实例

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN"> 
	<properties>
		<property name="LOG_HOME">D:/logs</property>
		<property name="FILE_NAME">mylog</property>
		<property name="log.sql.level">info</property>
	</properties>
	
	 
    <Appenders>  
        <Console name="Console" target="SYSTEM_OUT">  
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %l - %msg%n" />  
        </Console>
        
        <RollingRandomAccessFile name="RollingRandomAccessFile" fileName="${LOG_HOME}/${FILE_NAME}.log" filePattern="${LOG_HOME}/$${date:yyyy-MM}/${FILE_NAME}-%d{yyyy-MM-dd HH-mm}-%i.log">
        	<PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %l - %msg%n"/>
        	<Policies>
        		<TimeBasedTriggeringPolicy interval="1"/>
        		<SizeBasedTriggeringPolicy size="10 MB"/>
        	</Policies>
        	<DefaultRolloverStrategy max="20"/>
        </RollingRandomAccessFile>
    </Appenders>  
    
    <Loggers>  
    	<Root level="info">  
    		<AppenderRef ref="Console" />  
	        <AppenderRef ref="RollingRandomAccessFile" />  
	    </Root>
	    
	    <Logger name="com.mengdee.dao" level="${log.sql.level}" additivity="false">
             <AppenderRef ref="Console" />
        </Logger>
    </Loggers>  
</Configuration>

```

![image-20201023111349377](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201023111349.png)

##### 异步日志

###### 配置方式

log4j2的官方文档建议记录程序行为日志异步日志，效率更高。因为异步日志使用的是无锁技术，所以需要引入[Disruptor](https://link.jianshu.com/?t=http://logging.apache.org/log4j/2.x/manual/async.html#UnderTheHood)。然后可以通过配置异步的appender或Logger来实现异步日志

![image-20201022210808115](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201022210808.png)

###### 异步日志工作原理

AsyncAppender采用的是生产者消费者的模型进行异步地将Logging Event送到对应的Appender中。

- a、 生产者
  外部应用了Log4j的系统的实时线程，实时将Logging Event传送进AsyncAppender里
- b、 中转：Buffer和DiscardSummary
- c、 消费者：Dispatcher线程和appenders

###### 工作原理：

> 1） Logging Event进入AsyncAppender，AsyncAppender会调用append方法，在append方法中会去把logging Event填入Buffer中，当消费能力不如生产能力时，AsyncAppender会把超出Buffer容量的Logging Event放到DiscardSummary中，作为消费速度一旦跟不上生成速度，中转buffer的溢出处理的一种方案。
>
> 2） AsyncAppender有个线程类Dispatcher，它是一个简单的线程类，实现了Runnable接口。它是AsyncAppender的后台线程。
>
> Dispatcher所要做的工作是：
>
> ① 锁定Buffer，让其他要对Buffer进行操作的线程阻塞。
>
> ② 看Buffer的容量是否满了，如果满了就将Buffer中的Logging Event全部取出，并清空Buffer和DiscardSummary；如果没满则等待Buffer填满Logging Event，然后notify Disaptcher线程。
>
> ③ 将取出的所有Logging Event交给对应appender进行后面的日志信息推送。
>
> 以上是AsyncAppender类的两个关键点：append方法和Dispatcher类，通过这两个关键点实现了异步推送日志信息的功能，这样如果大量的Logging Event进入AsyncAppender，就可以游刃有余地处理这些日志信息了。

#### 三、性能影响

log4j对系统性能的影响程度主要体现在以下几方面：

- a、输出的目的地
  输出到控制台的速度比输出到文件系统的速度要慢。
- b、输出格式
  输出格式不一样对性能也会有影响，如简单输出布局(SimpleLayout)比格式化输出布局(PatternLayout)输出速度要快。可以根据需要尽量采用简单输出布局格式输出日志信息。
- c、日志级别
  输出级别越低输出的日志内容就越多，对系统系能影响很大。
- d、输出方式
  输出方式的不同，对系统系能也是有一定影响的，采用异步输出方式比同步输出方式性能要高。
- e、输出事件
  每次接收到日志输出事件**就打印**一条日志内容比当**日志内容达到一定大小时打印**系能要低。

#### 四、缓存设置

###### 设置日志输出为异步方式

```xml
<appender name="DRFOUT" class="org.apache.log4j.DailyRollingFileAppender">   
     <param name="File" value="logs/brws.log" />   
     <param name="Append" value="true" />   
     <param name="DatePattern" value="yyyy_MM_dd'.'" />   
     <layout class="org.apache.log4j.PatternLayout">   
         <param name="ConversionPattern" value="%d [%t] %-5p %l %x - %m%n" />   
     </layout>   
 </appender>
 
 <appender name="ASYNCOUT" class="org.apache.log4j.AsyncAppender">   
     <param name="BufferSize" value="512" />   
     <appender-ref ref="DRFOUT" />   
 </appender>
```

- 同步情况
  各线程直接获得输出流进行输出(线程间不需要同步)。
- 异步情况：
  1.各线程将日志**写到缓存**，继续执行下面的任务(这里是**异步**的)
  2.日志线程发现**需要记日志**时独占缓存(与此同时各线程等待，此时各线程是被阻塞住的)，从缓存中取出日志信息，获得输出流进行输出，将缓存解锁(各线程收到提醒，可以接着写日志了)
  - a、将日志记录到本地文件
    同样都是写本地文件Log4j本身有一个buffer处理入库，采用异步方式并不一定能提高性能(主要是如何配置好缓存大小)；而线程间的同步开销则是非常大的！因此在使用本地文件记录日志时不建议使用异步方式。
  - b、将日志记录到JMS
    JMS本身是支持异步消息的，如果不考虑JMS消息创建的开销，也不建议使用异步方式。
  - c、将日子记录到SOCKET
    将日志通过Socket发送，纯网络IO操作不需要反馈，因此也不会耗时
  - d、将日志记录到数据库
    众所周知JDBC是几种方式中最耗时的：网络、磁盘、数据库事务，都使JDBC操作异常的耗时，在这里采用异步方式入库倒是一个不错的选择。
  - e、将日志记录到SMTP 同JDBC

## java8前时间

### 一、 java.util.Date类

#### 1、**获取Date对象包含的日期时间信息**

![image-20201026110505131](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201026110505.png)

### 二、java.util.Calendar类

#### **1、创建当前时间的Calendar对象**

```java
Calendar c = Calendar.getInstance();//默认是当前日期
```

#### **2、创建指定日期、时间的Calendar对象**

```java
//创建一个代表2020年4月21日的Calendar对象
Calendar c1 = Calendar.getInstance();
c1.set(2020, 3, 21)；//调用：public final void set(int year,int month,int date)
```

#### **3、手动设置日期、时间信息**

##### 使用set方法设置对应的日期时间信息。

![image-20201026110704669](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201026110704.png)

##### Calendar常用常量

```json
Calendar.YEAR——年份
Calendar.MONTH——月份，从0开始，0-11
Calendar.DATE——日期
Calendar.DAY_OF_MONTH——本月的日期，和DATE相同
Calendar.HOUR——12小时制的小时
Calendar.HOUR_OF_DAY——24小时制的小时
Calendar.MINUTE——分钟
Calendar.SECOND——秒
Calendar.DAY_OF_WEEK——星期几，从星期日开始，1-7，1代表星期日，2代表星期一，和Date有点差别
```

##### 使用add方法进行日期时间计算

（其它所有的数值会被重新计算）

```java
 Calendar c1 = Calendar.getInstance();
 //把c1对象的日期加上10，其它所有的数值会被重新计算，例如4月21号加上10就会变成5月1号，
 //add方法在执行时会重新计算其他值
  c1.add(Calendar.DATE, 10);
 //把c1对象的日期加上-10，其它所有的数值会被重新计算
 c1.add(Calendar.DATE, -10);
```

##### 使用roll方法进行日期时间计算

```java
Calendar calendar = Calendar.getInstance();
calendar.set(2020, 0, 1);//代表2020年1月1日
calendar.roll(Calendar.MONTH, -1);//这样就将日期设置成了2020年12月1日。
```

#### **4、获取Calendar对象的日期时间信息**

```java
Calendar c1 = Calendar.getInstance();

int year = c1.get(Calendar.YEAR);    //年

int month = c1.get(Calendar.MONTH) + 1;    //月（MONTH+1）

int date = c1.get(Calendar.DATE);    //日

int hour = c1.get(Calendar.HOUR_OF_DAY);    //时

int minute = c1.get(Calendar.MINUTE);    //分

int second = c1.get(Calendar.SECOND);    //秒

int week= c1.get(Calendar.DAY_OF_WEEK);   //星期几 从星期日开始，1-7，1代表星期日，2代表星期一，和Date有点差别

```

### 三、日期格式化SimpleDateFormat类

SimpleDateFormat类用来将日期转换为特定格式的日期字符串以及将特定格式的日期字符串转换为Date类型。

#### **1、使用format() 方法将日期类型转换为指定格式的字符串**

```java
Date date = new Date();
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-mm-dd HH:mm:ss");
String str = dateFormat.format(date);
System.out.println(str);
```

#### **2、使用parse()方法将字符串转换为Date类型**

```java
try{
    String str="2019-1-21";
    SimpleDateFormat sdf= new SimpleDateFormat("yyyy-MM-dd");
    Date date= sdf.parse(str);
    System.out.println(date);
}catch (Exception e){
    e.printStackTrace();
}
```

**注：new SimpleDateFormat 对象时可以设置语言环境：**

```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.CHINESE);
```

SimpleDateFormat 自定义格式中常用的字母及含义

![image-20201026111947604](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201026111947.png)

### 四、时间类和字符串转换

#### **Calendar 转化 String**

```java
Calendar calendar= Calendar.getInstance();
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
String dateStr = sdf.format(calendar.getTime());
```

#### **String 转化Calendar**

```java
String str="2019-1-21";
SimpleDateFormat sdf= new SimpleDateFormat("yyyy-MM-dd");
Date date =sdf.parse(str);
Calendar calendar = Calendar.getInstance();
calendar.setTime(date);
```

#### **Date 转化String**

```java
SimpleDateFormat sdf= new SimpleDateFormat("yyyy-MM-dd");
String dateStr=sdf.format(new Date());
```

#### **String 转化Date**

```java
String str="2019-1-21";
SimpleDateFormat sdf= new SimpleDateFormat("yyyy-MM-dd");
Date date= sdf.parse(str);
```

#### **Date 转化Calendar**

```java
Calendar calendar = Calendar.getInstance();
calendar.setTime(new Date());
```

#### **Calendar转化Date**

```java
Calendar calendar = Calendar.getInstance(); 
Date date =calendar.getTime();
```

## Caffeine缓存

### 一、简介

https://www.cnblogs.com/cjsblog/p/11517761.html

> Caffeine是一种高性能的缓存库，是基于Java 8的最佳（最优）缓存框架。
>
> Cache（缓存），基于Google Guava，Caffeine提供一个内存缓存，大大改善了设计Guava's cache 和 ConcurrentLinkedHashMap 的体验。

### 二、特性

Caffeine提供了灵活的结构来创建缓存，并且有以下特性：

- 自动加载条目到缓存中，可选异步方式
- 可以基于大小剔除
- 可以设置过期时间，时间可以从上次访问或上次写入开始计算
- 异步刷新
- keys自动包装在弱引用中
- values自动包装在弱引用或软引用中
- 条目剔除通知
- 缓存访问统计

#### 1、 加载/填充

Caffeine提供以下四种类型的加载策略：

##### 1.1. Manual

```java
 1 Cache<Key, Graph> cache = Caffeine.newBuilder()
 2     .expireAfterWrite(10, TimeUnit.MINUTES)
 3     .maximumSize(10_000)
 4     .build();
 5 
 6 // Lookup an entry, or null if not found
 7 Graph graph = cache.getIfPresent(key);
 8// 如果缓存中不存在该键，createExpensiveGraph函数将用于提供回退值，该值在计算后插入缓存中
 9 graph = cache.get(key, k -> createExpensiveGraph(key));
10 // Insert or update an entry
11 cache.put(key, graph);
12 // Remove an entry
13 cache.invalidate(key);
```

Cache接口可以显式地控制检索、更新和删除条目。 

##### 1.2. Loading 

```java
1 LoadingCache<Key, Graph> cache = Caffeine.newBuilder()
2     .maximumSize(10_000)
3     .expireAfterWrite(10, TimeUnit.MINUTES)
4     .build(key -> createExpensiveGraph(key));
5 
6 // Lookup and compute an entry if absent, or null if not computable
7 Graph graph = cache.get(key);
8 // Lookup and compute entries that are absent
9 Map<Key, Graph> graphs = cache.getAll(keys);
```

LoadingCache通过关联一个CacheLoader来构建Cache

通过LoadingCache的getAll方法，可以批量查询 

###### 1.2.1.同步加载

> https://blog.csdn.net/qq_42191033/article/details/108961339



LoadingCache对象进行缓存的操作，使用CacheLoader进行缓存存储管理。 批量查找可以使用**getAll()**方法。 默认情况下, getAll()将会对缓存中没有值的key分别调用**CacheLoader.load**方法来构建缓存的值（build中的表达式）。我们可以重写**CacheLoader.loadAll**方法来**提高getAll()的效率**。

![image-20210210154858923](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210210154859.png)

###### 1.2.2.异步加载

AsyncLoadingCache对象进行缓存管理，get()返回一个CompletableFuture对象，默认使用ForkJoinPool.commonPool()来执行异步线程，但是我们可以通过Caffeine.executor(Executor) 方法来替换线程池

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201008120602223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkxMDMz,size_16,color_FFFFFF,t_70#pic_center)



创建和异步转同步

![image-20210210155216454](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210210155216.png)



##### 1.3. Asynchronous (Manual) 

```java
1 AsyncCache<Key, Graph> cache = Caffeine.newBuilder()
2     .expireAfterWrite(10, TimeUnit.MINUTES)
3     .maximumSize(10_000)
4     .buildAsync();
5 
6 // Lookup and asynchronously compute an entry if absent
7 CompletableFuture<Graph> graph = cache.get(key, k -> createExpensiveGraph(key));
```

AsyncCache是另一种Cache，它基于Executor计算条目，并返回一个CompletableFuture。 

##### 1.4. Asynchronously Loading 

```java
 1 AsyncLoadingCache<Key, Graph> cache = Caffeine.newBuilder()
 2     .maximumSize(10_000)
 3     .expireAfterWrite(10, TimeUnit.MINUTES)
 4     // Either: Build with a synchronous computation that is wrapped as asynchronous 
 5     .buildAsync(key -> createExpensiveGraph(key));
 6     // Or: Build with a asynchronous computation that returns a future
 7     .buildAsync((key, executor) -> createExpensiveGraphAsync(key, executor));
 8 
 9 // Lookup and asynchronously compute an entry if absent
10 CompletableFuture<Graph> graph = cache.get(key);
11 // Lookup and asynchronously compute entries that are absent
12 CompletableFuture<Map<Key, Graph>> graphs = cache.getAll(keys);
```

AsyncLoadingCache 是关联了 AsyncCacheLoader 的 AsyncCache

#### 2、剔除





## Guava 缓存Cache用法介绍

> 参考资料：
>
> https://blog.csdn.net/lijingjingchn/article/details/106563195?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param

### 1. 前言

`Guava Cache`是在内存中缓存数据，相比较于数据库或`redis`存储，访问内存中的数据会更加高效。Guava官网介绍，下面的这几种情况可以考虑使用`Guava Cache`：

- 愿意消耗一些内存空间来提升速度。
- 预料到某些键会被多次查询。
- 缓存中存放的数据总量不会超出内存容量。

所以，可以将程序频繁用到的少量数据存储到`Guava Cache`中，以改善程序性能。下面对`Guava Cache`的用法进行详细的介绍。

### 2. 构建缓存对象

`接口Cache`代表一块缓存，它有如下方法：

```java
public interface Cache<K, V> {
    V get(K key, Callable<? extends V> valueLoader) throws ExecutionException;

    ImmutableMap<K, V> getAllPresent(Iterable<?> keys);

    void put(K key, V value);

    void putAll(Map<? extends K, ? extends V> m);

    void invalidate(Object key);

    void invalidateAll(Iterable<?> keys);

    void invalidateAll();

    long size();

    CacheStats stats();

    ConcurrentMap<K, V> asMap();

    void cleanUp();
}

```

可以通过`CacheBuilder`类构建一个缓存对象，`CacheBuilder`类采用`builder`设计模式，它的每个方法都返回`CacheBuilder`本身，直到`build`方法被调用。构建一个缓存对象代码如下：

![image-20201026145856573](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201026145856.png)

上面的代码通过`CacheBuilder.newBuilder().build()`这句代码创建了一个`Cache`缓存对象，并在缓存对象中存储了key为word，value为Hello Guava Cache的一条记录。可以看到`Cache`非常类似于`JDK`中的`Map`，但是相比于`Map`，`Guava Cache`提供了很多更强大的功能。

### 3. 设置最大存储

`Guava Cache`可以在构建缓存对象时指定缓存所能够存储的**最大记录数量**。当`Cache`中的记录数量**达到最大值后**再调用`put`方法向其中添加对象，`Guava`会先从当前缓存的对象记录中**选择一条删除掉**，**腾出空间**后再将新的对象存储到`Cache`中。

![image-20201026150748052](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201026150748.png)

上面代码在构造缓存对象时，通过`CacheBuilder`类的`maximumSize`方法指定`Cache`最多可以**存储两个对象**，然后调用`Cache`的`put`方法向其中添加了三个对象。程序执行结果如下图所示，可以看到第三条对象记录的插入，**导致了第一条对象记录被删除**

### 4. 设置过期时间

在**构建`Cache`对象**时，可以通过`CacheBuilder`类的`expireAfterAccess`和`expireAfterWrite`两个方法为缓存中的对象**指定过期时间**，过期的对象将会被缓存自动删除。其中，`expireAfterWrite`方法指定对象**被写入到缓存后多久过期**，`expireAfterAccess`指定对象**多久没有被访问后过期**

![image-20201026152231873](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201026152232.png)

下面代码是`expireAfterAccess`的例子：

![image-20201026152527016](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201026152527.png)

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        // guava线程池,用来产生ListenableFuture
        ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));
        LoadingCache<Object, Object> cache = CacheBuilder.newBuilder()
                //指定时间内没有被创建/覆盖，则指定时间过后，再次访问时，会去刷新该缓存，在新值没有到来之前，始终返回旧值
                .refreshAfterWrite(2, TimeUnit.SECONDS)
                .build(new CacheLoader<Object, Object>() { //若没有元素,则创建并且放入缓存
                    @Override
                    public Object load(Object key) throws Exception {
                        return System.currentTimeMillis();
                    }
						
				//重写reload,使其异步刷新数据
                    @Override
                    public ListenableFuture<Object> reload(Object key, Object oldValue) throws Exception {
                        System.out.println("......后台线程池异步刷新:" + key);
                        return service.submit(new Callable<Object>() { //模拟一个需要耗时2s的数据库查询任务
                            @Override
                            public Object call() throws Exception {
                                System.out.println("begin to mock query db...");
                                Thread.sleep(2000);
                                System.out.println("success to mock query db...");
                                return UUID.randomUUID().toString() + key;
                            }
                        });

                    }
                });
    }

```

> **分析:**
>
> - **使用expireAfterAccess或expireAfterWrite时,当缓存过期后，恰好有N个客户端发起请求，需要读取值。使用Guava Cache可以保证只让一个线程去加载数据(比如从数据库中)，而其他线程则等待这个线程的返回结果.这样就能避免大量用户请求穿透缓存,但同时也降低了吞吐量.**
> - **refreshAfterWrite: 当缓存数据过期的时候，真正去加载数据的线程会阻塞一段时间，其余线程立马返回过期的值,然这种处理方式更符合实际的使用场景。**
> - **真正加载数据的那个线程一定会阻塞，我们希望这个加载过程是异步的。这样就可以让所有线程立马返回旧值，在后台刷新缓存数据。refreshAfterWrite默认的刷新是同步的，会在调用者的线程中执行。我们可以改造成异步的，实现CacheLoader.reload()。上面的代码就将其实现.**

### 5. 弱引用

可以通过`weakKeys`和`weakValues`方法指定`Cache`只保存对缓存记录key和value的`弱引用`。这样当没有其他强引用指向key和value时，key和value对象就会被垃圾回收器回收。

![image-20201026152653255](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201026152653.png)

### 6. 显式清除

可以调用`Cache`的`invalidateAll`或`invalidate`方法显示删除`Cache`中的记录。`invalidate`方法一次只能删除`Cache`中一个记录，接收的参数是要删除记录的key。`invalidateAll`方法可以批量删除`Cache`中的记录，当没有传任何参数时，`invalidateAll`方法将清除`Cache`中的全部记录。`invalidateAll`也可以接收一个`Iterable`类型的参数，参数中包含要删除记录的所有key值。下面代码对此做了示例。

![image-20201026152805783](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201026152805.png)

### 7. 移除监听器

可以为`Cache`对象添加一个移除监听器，这样**当有记录被删除时可以感知**到这个事件。

![image-20201026212212688](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201026212213.png)

### 8. 自动加载

`Cache`的`get`方法有两个参数，第一个参数是要从`Cache`中获取记录的`key`，第二个记录是一个`Callable`对象。当缓存中**已经存在`key`对应**的记录时，`get`方法直接返回key对应的记录。如果缓存中**不包含key对应的记**录，`Guava`会启动一个线程执行`Callable`对象中的`call`方法，`**call`方法的返回值**会作为key对应的值被存储到缓存中，并且被`get`方法返回。下面是一个多线程的例子：

```java
public class StudyGuavaCache {

    private static Cache<String,String> cache = CacheBuilder.newBuilder()
            .maximumSize(3)
            .build();

    public static void main(String[] args) throws InterruptedException {

        new Thread(new Runnable() {
            public void run() {
                System.out.println("thread1");
                try {
                    String value = cache.get("key", new Callable<String>() {
                        public String call() throws Exception {
                            System.out.println("load1"); //加载数据线程执行标志
                            Thread.sleep(1000); //模拟加载时间
                            return "auto load by Callable";
                        }
                    });
                    System.out.println("thread1 " + value);
                } catch (ExecutionException e) {
                    e.printStackTrace();
                }
            }
        }).start();

        new Thread(new Runnable() {
            public void run() {
                System.out.println("thread2");
                try {
                    String value = cache.get("key", new Callable<String>() {
                        public String call() throws Exception {
                            System.out.println("load2"); //加载数据线程执行标志
                            Thread.sleep(1000); //模拟加载时间
                            return "auto load by Callable";
                        }
                    });
                    System.out.println("thread2 " + value);
                } catch (ExecutionException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }
}

```

![image-20201028170822480](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201028170823.png)

这段代码中有两个线程共享同一个`Cache`对象，两个线程同时调用`get`方法获取同一个key对应的记录。由于key对应的记录不存在，所以两个线程都在**get方法处阻塞**。此处在`call`方法中调用`Thread.sleep(1000)`模拟程序从外存加载数据的时间消耗。代码的执行结果如下图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605093350457.jpg)

从结果中可以看出，虽然是两个线程同时调用`get`方法，但**只有一个`get`方法**中的`Callable`会被执行(没有打印出load2)。`Guava`可以保证当有多个线程同时访问`Cache`中的一个key时，如果key对应的记录不存在，`Guava`**只会启动一个线程执行**`get`方法中`Callable`参数对应的任务加载数据存到缓存。当加载完数据后，**任何线程中的`get`方法都会获取到key对应的值**。

### 9. 统计信息

可以对`Cache`的`命中率`、`加载数据时间`等信息进行统计。在构建`Cache`对象时，可以通过`CacheBuilder`的`recordStats`方法开启统计信息的开关。开关开启后`Cache`会自动对缓存的各种操作进行统计，调用`Cache`的`stats`方法可以查看统计后的信息。

```java
public class StudyGuavaCache {
    public static void main(String[] args) throws InterruptedException {
        Cache<String,String> cache = CacheBuilder.newBuilder()
                .maximumSize(3)
                .recordStats() //开启统计信息开关
                .build();
        cache.put("key1","value1");
        cache.put("key2","value2");
        cache.put("key3","value3");
        cache.put("key4","value4");

        cache.getIfPresent("key1");
        cache.getIfPresent("key2");
        cache.getIfPresent("key3");
        cache.getIfPresent("key4");
        cache.getIfPresent("key5");
        cache.getIfPresent("key6");

        System.out.println(cache.stats()); //获取统计信息
    }
}

```

程序执行结果如下图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605093639341.jpg)

这些统计信息对于调整缓存设置是至关重要的，在性能要求高的应用中应该密切关注这些数据

### 10.并发度

`Guava Cache`可以通过参数`concurrencyLevel(5)` 设置并发度，即可以同时写缓存的线程数。

![image-20201028171157259](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201028171157.png)

### 11. LoadingCache

`LoadingCache`是`Cache`的子接口，相比较于`Cache`，当从`LoadingCache`中读取一个指定key的记录时，如果该记录不存在，则`LoadingCache`可以**自动执行加载数据到缓存**的操作。`LoadingCache`接口的定义如下：

![image-20201028171300728](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201028171300.png)

与构建`Cache`类型的对象类似，`LoadingCache`类型的对象也是通过`CacheBuilder`进行构建，不同的是，在调用`CacheBuilder`的`build`方法时，必须传递一个**`CacheLoader`类型**的参数，`CacheLoader`的`load`方法**需要我们提供实现**。当调用`LoadingCache`的`get`方法时，如果缓存不存在对应key的记录，则`CacheLoader`中的`load`方法会被**自动调用从外存加载数据**，`load`方法的返回值会作为key对应的value存储到`LoadingCache`中，并从`get`方法返回。

![image-20201028172218232](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201028172218.png)

### 12.完整参数

（https://blog.csdn.net/Kincym/article/details/84072648?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control）

```java
ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));
    LoadingCache<String, Object> cache = CacheBuilder.newBuilder()
            .initialCapacity(10)//初始化个数
            .maximumSize(55)//设置最大个数
            .maximumWeight(1000) //设置重量，配合weigher使用
            .weigher(new Weigher<String, Object>() { //weigher相当一杆秤,称每个元数多重
                @Override
                public int weigh(String key, Object value) {
                    return 100;
                }
            })
            .expireAfterAccess(10, TimeUnit.SECONDS) //多长时间未读写后过期
            .expireAfterWrite(10, TimeUnit.SECONDS)  //多长时间未写后过期
            //指定时间内没有被创建/覆盖，则指定时间过后，再次访问时，会去刷新该缓存，在新值没有到来之前，始终返回旧值
            .refreshAfterWrite(2, TimeUnit.SECONDS)
            .concurrencyLevel(1) //写的并发数
            .softValues() //软引用
            .weakKeys() //弱引用
            .weakValues() //弱引用
            .recordStats() //统计的
            .removalListener(new RemovalListener<String, Object>() {
                @Override
                public void onRemoval(RemovalNotification<String, Object> notification) {
                    /**
                     *RemovalCause 枚举
                     * 标明是什么情况下 被移除的
                     */
                    RemovalCause cause = notification.getCause();
                    if (notification.wasEvicted()) { //是否被移除(排除主动删除,和替换)
                        System.out.println(notification.getKey() + notification.getValue());
                    }
                }
            })
            .build(new CacheLoader<Object, Object>() { //若没有元素,则创建并且放入缓存
                @Override
                public Object load(Object key) throws Exception {
                    return System.currentTimeMillis();
                }

                @Override
                public ListenableFuture<Object> reload(Object key, Object oldValue) throws Exception {
                    System.out.println("......后台线程池异步刷新:" + key);
                    return service.submit(new Callable<Object>() { //模拟一个需要耗时2s的数据库查询任务
                        @Override
                        public Object call() throws Exception {
                            System.out.println("begin to mock query db...");
                            Thread.sleep(2000);
                            System.out.println("success to mock query db...");
                            return UUID.randomUUID().toString() + key;
                        }
                    });
                }
            });

```



## 单元测试

### 一、单元测试 vs. 集成测试

> 维基百科是这么说 [单元测试](https://en.wikipedia.org/wiki/Unit_testing) 的：
>
> > 在计算机编程中，单元测试是一种软件测试方法，用以测试源代码的单个单元、一个或多个计算机程序模块的集合以及相关的控制数据、使用过程和操作过程，以确定它们是否适合使用。
>
> [集成测试](https://en.wikipedia.org/wiki/Integration_testing)：
>
> > “集成测试（有时也称集成和测试，缩写为 I&T）是软件测试的一个阶段，在这个阶段中，各个软件模块被组合在一起来进行测试。”
>
> 简而言之，当我们在做单元测试时，只是**测试了一个代码单元**，每次**只测试一个方法**，不包括与正测试组件相交互的其他所有组件。
>
> 另一方面，在**集成测试**中，我们测试各组件之间的集成。**由于单元测试，我们可知这些组件行为与所需一致，但不清楚它们是如何在一起工作的。**这就是集成测试的职责。

#### 1、单元测试做什么？

![image-20210412172231479](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210412172231.png)



#### 2、单元测试的好处

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200610111110662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM2NzU1MA==,size_16,color_FFFFFF,t_70)



#### 3、断言的使用

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200610112055450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM2NzU1MA==,size_16,color_FFFFFF,t_70)



#### 4、Junit基本注解介绍

> @BeforeClass 在所有测试方法前执行一次，一般在其中写上整体初始化的代码，初始化非常耗时的资源, 例如创建数据库
>
> @AfterClass 在所有测试方法后执行一次，一般在其中写上销毁和释放资源的代码，清理@BeforeClass创建的资源, 例如创建数据库
>
> @Before 在每个测试方法前执行，一般用来初始化方法（比如我们在测试别的方法时，类中与其他测试方法共享的值已经被改变，为了保证测试结果的有效性，我们会在@Before注解的方法中重置数据）
>
> @After 在每个测试方法后执行，在方法执行完成后要做的事情
>
> @Test(timeout = 1000) 测试方法执行超过1000毫秒后算超时，测试将失败
>
> @Test(expected = Exception.class) 测试方法期望得到的异常类，如果方法执行没有抛出指定的异常，则测试失败
>
> @Ignore(“not ready yet”) 执行测试时将忽略掉此方法，如果用于修饰类，则忽略整个类
>
> @Test 编写一般测试用例
>
> @RunWith 在JUnit中有很多个Runner，他们负责调用你的测试代码，每一个Runner都有各自的特殊功能，你要根据需要选择不同的Runner来运行你的测试代码。
>
> 如果我们只是简单的做普通Java测试，不涉及Spring Web项目，你可以省略@RunWith注解，这样系统会自动使用默认Runner来运行你的代码。
>
>  对于每一个@Test方法的执行顺序
>
> 注意:** 单个@Test方法执行前会创建新的XxxTest实例, 实例变量的状态不会传递给下一个@Test方法, 单个@Test方法执行前后会执行@Before和@After方法
>
> @BeforeClass 全局只会执行一次，而且是第一个运行
> @Before 在测试方法运行之前运行
> @Test 测试方法
> @After 在测试方法运行之后允许
> @AfterClass 全局只会执行一次，而且是最后一个运行
> @Ignore 忽略此方法
>
> 对于每一个测试，我们都应该保持独立测试，以确保测试结果是有意义的。在程序中，经常会出现，当测试完一个方法后，其参数已经被系统保持或持久化下来。无疑会造成下一次的测试测试数据或者状态的不合理性!为了解决问题，对于此类场景，我们的测试代码必须具备初始化和收尾的能力。也即是@Before和@After的意义所在!
>
> 同理@AfterClass和BeforeClass即是为了满足测试中，那些体积非常大，但只要一次初始化的代码块!



##### 异常测试

![image-20210412171749106](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210412171752.png)

##### 参数化测试

> 参数化测试的目标是为了一次性完成同类型测试，将相同类型的数据按照一定的顺序批量地传入测试方法，并得出结论!其本质是一个批量的化的操作，只是为了方便我们测试而进行了封装。我们只有提供测试的方法以及按照一定的顺序进行设置则可以。
>
> --------->进行类注解：@RunWith(Parameterized.class),为了测试类指定一个ParameterizedRunner运行器
>
> --------->进行参数设置：将测试结果和期望结果，以每一组都是一个数组的形式存放以形成二维数组，转化为list返回并注解。
>
> --------->参数初始化：设置测试方法要入参的参数，并按照"参数设置"的顺序利用构造方法进行初始化的赋值!
>
> --------->测试调用：写一个测试方法进行调用，将参数传递到要测试的类的方法中并返回数据
>
> 注意：参数化测试需要创建一单独用于测试的测试类。并定义两个变量用于接受测试结果和预期目标。数据存放以二维数组的方式，两个为一组。接着便是通过构造方法进行数据初始化。 构造方法入参的顺序要和二维数组中国每一组存放的数据顺序保持一致。

![image-20210412172041985](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210412172042.png)

![image-20210412173431640](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210412173431.png)

#### 5、JUnit5测试框架

JUnit5是对程序代码进行单元测试的Java框架。它用来编写自动化测试工具，降低测试的难度、减少烦琐性、并有效避免出现程序错误。

##### 5.1 JUnit5注解

所有支持的注解都在包 org.junit.jupiter.api 下;

使用@Test、@TestTemplate、@RepeatedTest、@BeforeAll、@AfterAll、@BeforeEach或@AfterEach注释的方法不能返回值。

![image-20201028211031266](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201028211031.png)

##### 5.2 JUnit5断言（Assertions类）

 JUnit5断言都是 org.junit.jupiter.api.Assertions 中的静态方法断言类。

Asser类中主要方法如下：

![image-20201028211328957](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201028211329.png)

**【示例】**SpringBoot 基于 JUnit5 的测试类。

![image-20201028211433095](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201028211433.png)









### 二、SpringBoot单元测试

#### 1.1 快速创建单元测试

（1）在SpringBoot中进行单元测试很简单，它已经自动添加好了Test的Starter依赖，如下：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

（2）只要在“src/test/java”目录下新建一个测试类即可，代码如下：

```java
import com.pjb.entity.UserInfo;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
 
/**
 * 用户业务逻辑测试类（JUnit4）
 * @author pan_junbiao
 **/
@SpringBootTest
@RunWith(SpringRunner.class)
public class UserServiceTest
{
    @Autowired
    private UserService userService;
 
    @Before
    public void setUp()
    {
    }
 
    @After
    public void tearDown()
    {
    }
 
    @Test
    public void getUserInfoById()
    {
        //测试代码
        UserInfo userInfo = userService.getUserInfoById(1);
    }
}
```

**代码说明：**

@SpringBootTest：是SpringBoot用于测试的注解，可指定入口类或测试环境等。

@RunWith(SpringRunner.class)：让测试运行与Spring的测试环境。

@Test：表示为一个测试单元。

##### 步骤一：

> 当测试中需要使用Spring Boot功能时，可以使用`@SpringBootTest`注解，装配Spring上下文。
> 当作为普通Spring单元测试时，可以使用`@ContextConfiguration`，装配Spring 上下文。

##### 步骤二：

> 基于Spring的Junit测试单元需要使用`@RunWith(SpringJUnit4ClassRunner.class)`注解，该注解能够让Junit运行在Spring测试环境中，得到Spring上下文支持。在4.3版本中提供了等同于`SpringJUnit4ClassRunner.class`的简写类`SpringRunner.class`。

##### Spring Boot测试单元启动流程如下：

> 如果未指定classes 参数或者指定的classes参数不是启动main函数入口`SpringBootTest(classes = SpringTestAutoConfig.class)`，则会自动从当前测试类包一层一层向上检索，直到找到`@SpringBootApplication`或`@SpringBootConfiguration`注释类为止。以此来启动`Spring Boot`应用，并装载Spring上下文。
>
> 如果未检索到Spring Boot启动主配置类，则会抛出异常： `java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @ContextConfiguration or @SpringBootTest(classes=…) with your test`
>
> 如果指定的classes为**普通Configer**（`@SpringBootConfiguration`）配置类，则会以此配置初始化Spring 上下文，而**不会加载其他Bean到Spring容**器。可以在Junit测试单元中使用这些类。

![image-20201028212907528](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201028212907.png)



#### 1.2 测试的回滚

在单元测试中可能会产生垃圾数据，可以开启事务功能进行回滚——在方法或者类头部添加@Transactional注解即可，代码如下：

```java
/**
 * 新增员工
 * 加上@Transactional注解，开启事务
 * 这样测试执行完后就会进行回滚操作
 * @author pan_junbiao
 */
@Test
@Transactional
public void addStaff()
{
    //创建新用户信息
    UserInfo userInfo = new UserInfo();
    userInfo.setUserName("pan_junbiao的博客");
    userInfo.setBlogUrl("https://blog.csdn.net/pan_junbiao");
    userInfo.setBlogRemark("您好，欢迎访问 pan_junbiao的博客");
 
    //执行新增操作
    userDao.save(userInfo);
}
```

#### 1.3 常用注解

###### **@SpringBootTest**

是SpringBoot的一个用于测试的注解，通过SpringApplication在测试中创建ApplicationContext。

**@AutoConfigureMockMvc**

是用于自动配置MockMvc。

###### **@RunWith**

**在JUnit**中有很多个Runner，他们负责调用你的测试代码，每一个Runner都有各自的特殊功能，你要根据需要选择不同的Runner来运行你的测试代码。

###### **@Before**

在每个测试方法前执行，一般用来初始化方法。

###### **@After**

在每个测试方法后执行，在方法执行完成后要做的事情。











### 三、Mockito

#### 3.1 什么是mock

在面向对象的程序设计中，**模拟对象**(mock object)是以**可控的方式模拟真实对象**行为的假对象。在编程过程中，通常通过模拟一些输入数据，来验证程序是否达到预期结果。

为什么使用Mock对象
使用模拟对象，可以**模拟复杂的、真实的对**象行为。如果在单元测试中无法使用真实对象，可采用模拟对象进行替代。

在**以下情况**可以采用模拟对象来替代真实对象：

> 真实对象的行为是不确定的（例如，当前的时间或温度）。
> 真实对象很难搭建起来。
> 真实对象的行为很难触发（例如，网络错误）。
> 真实对象速度很慢。
> 真实对象是用户界面，或包括用户界面在内。
> 真实的对象使用了回调机制。 真实对象可能还不存在。
> 真实对象可能包含不能用作测试的信息和方法。

使用Mockito一般分为三个步骤：

> 1.模拟测试类所需的外部依赖
> 2.执行测试代码
> 3.判断执行结果是否达到预期

JUnit和SpringTest基本上可以满足绝大多数单元测试，但是由于现在**系统越来越复杂**，相互之间依赖越来越多。特别是微服务化以后的系统，往往一个模块的代码需要依赖几个其他模块的东西。因此，在做**单元测试**的时候，往往**很难构造出需要的依赖**。一个单元测试，我们只关心一个小的功能，但是为了这个小的功能能跑起来，可能需要依赖一堆其他的东西，这就导致了单元测试无法进行。所以我们就需要在测试过程中引入mock测试。

所谓的Mock测试就是在测试过程中，对于一些**不容易构造**的、或者和这次单元测试无关但是上下文又有依赖的对象，用一个**虚拟的对象(Mock对象)**来模拟，以便单元测试能够进行。
比如有一段代码的依赖为：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200521163925161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDkxMDMz,size_16,color_FFFFFF,t_70)

当我们要进行单元测试的时候，就需要**给A注入**B和C但是**C又依赖了D**，D又依赖了E。这就导致了A的单元测试很难进行。

但是当我们使用Mock来进行模拟对象后，我们就可以把这种依赖解耦，只关心A本身的测试，它所**依赖的B和C**，全部使用Mock出来的对象，并且给`MockB`和`MockC`**指定一个明确**的行为。就像这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200521164034226.png)

因此，当我们使用Mock后，对于那些难以构建的对象，就变成了个模拟对象，只需要提前的做`Stubbing(桩)`即可。所谓的**做桩数据**，也就是告诉Mock对象，当与之交互时执行何种行为过程。比如当**调用B对象的b()**方法时，我们**期望返回一个true**,这就是一个**设置桩数据的预期。**



#### 3.2 依赖

```xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-all</artifactId>
    <version>1.10.19</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.testng</groupId>
    <artifactId>testng</artifactId>
    <version>7.0.0</version>
    <scope>test</scope>
</dependency>
<!--静态类方法模拟-->
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-core</artifactId>
    <version>2.0.2</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-api-mockito</artifactId>
    <version>1.7.4</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-module-testng</artifactId>
    <version>1.7.4</version>
    <scope>test</scope>
</dependency>
```



#### 3.3 mock常用注解

- **@InjectMocks：通过创建一个实例，它可以调用真实代码的方法，其余用@Mock（或@Spy）注解创建的mock将被注入到用该实例中。**

- **@Mock：对函数的调用均执行mock（即虚假函数），不执行真正部分。**

- **@Spy：对函数的调用均执行真正部分。**

  Mockito中的Mock和Spy都可用于拦截那些尚未实现或不期望被真实调用的对象和方法，并为其设置自定义行为。二者的区别在于Mock不真实调用，Spy会真实调用。

  ![image-20210413175336645](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210413175337.png)

![image-20210413175408536](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210413175408.png)

![image-20210413175435923](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210413175436.png)

##### 1、

![image-20200524022536773](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200623113201.png)



##### 2、多次触发返回不同值

![image-20200524022557201](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200623113202.png)

##### 3、模拟抛出异常

![image-20200524022626012](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200623113203.png)

4、![image-20200524022702839](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200623113204.png)

##### 5、参数匹配

![image-20200524022744877](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200623113205.png)

##### 6、自定义参数匹配

![image-20200524022808844](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200623113206.png)

##### 7、预期回调接口生成期望值

![image-20200524022829259](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200623113207.png)

##### 8、预期回调接口生成期望值（直接执行）

![image-20200524022851223](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200623113208.png)

##### 9、修改对未预设的调用返回默认期望（指定返回值）

![image-20200524022915200](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200623113209.png)

##### 10、用spy监控真实对象,设置真实对象行为

![image-20200524022935278](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200623113210.png)

##### 11、调用真实的方法

![image-20200524022945288](https://gitee.com/top20chenql/md_imgs/raw/master/img/20200623113211.png)

#### 3.4 接口方法测试

##### 使用注解自动初始化

> 自动化注解需要使用`@InjectMocks`和`@Mock`搭配使用，这样就可以在测试类运行的时候Mock这些自动注入对象，之后在`@BeforeTest` 中使用`MockitoAnnotations.initMocks(this);` 就可以了。
>
> 实例代码：

```java
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.when;

import com.xing.springDataJpa.first.FirstEntity;
import com.xing.springDataJpa.first.FirstRepository;
import com.xing.springDataJpa.service.impl.IndexServiceImpl;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.ResponseEntity;
import org.testng.Assert;
import org.testng.annotations.BeforeTest;
import org.testng.annotations.Test;

/**
 * 功能描述
 *
 * @since 2020-09-28
 */
public class IndexServiceImplTest {
    @Mock
    private FirstRepository firstRepository;

    // @InjectMocks: 创建一个实例，简单的说是这个Mock可以调用真实代码的方法，其余用@Mock（或@Spy）注解创建的mock将被注入到用该实例中。
    @InjectMocks
    private IndexServiceImpl service;
    
    @BeforeTest
    public void beforeTest() {
        System.out.println("========= beforeTest() ==========");
        // 其中this就是单元测试所在的类，在initMocks函数中Mockito会根据类中不同的注解（如@Mock, @Spy等）创建不同的mock对象，即初始化工作
        MockitoAnnotations.initMocks(this);
    }
    
    @Test
    public void getPerson() {
        String userId = "3423423113";
        String userName = "xiaoming";
        FirstEntity firstEntity = new FirstEntity();
        firstEntity.setUserId(userId);
        firstEntity.setUserName(userName);
        when(firstRepository.findFirstByUserIdAndAndUserName(anyString(), anyString()))
                .thenReturn(firstEntity);
        ResponseEntity<Object> person = service.getPerson(userId, userName);
        Assert.assertNotNull(person);
    }
    
}
2.2.2 使用反射机制初始化注入对象
这种是很简便的使用，如果想多写几行代码可以使用反射机制，set这些对象。

import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.when;

import com.xing.springDataJpa.first.FirstEntity;
import com.xing.springDataJpa.first.FirstRepository;
import com.xing.springDataJpa.service.impl.IndexServiceImpl;

import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.ResponseEntity;
import org.testng.Assert;
import org.testng.annotations.BeforeTest;
import org.testng.annotations.Test;

import java.lang.reflect.Field;

/**
 * 功能描述
 *
 * @since 2020-09-28
 */
public class IndexServiceImplTest {
    IndexServiceImpl service = new IndexServiceImpl();
    
    @Mock
    private FirstRepository firstRepository;
    
    @BeforeTest
    public void beforeTest() throws NoSuchFieldException, IllegalAccessException {
        System.out.println("========= beforeTest() ==========");
        // 其中this就是单元测试所在的类，在initMocks函数中Mockito会根据类中不同的注解（如@Mock, @Spy等）创建不同的mock对象，即初始化工作
        MockitoAnnotations.initMocks(this);
        
        Class serviceClass = service.getClass();
        // 反射获取属性
        Field firstRepositoryField = serviceClass.getDeclaredField("firstRepository");
        firstRepositoryField.setAccessible(true);
        firstRepositoryField.set(service, firstRepository);
    }
    
    @Test
    public void getPerson() {
        String userId = "3423423113";
        String userName = "xiaoming";
        FirstEntity firstEntity = new FirstEntity();
        firstEntity.setUserId(userId);
        firstEntity.setUserName(userName);
        when(firstRepository.findFirstByUserIdAndAndUserName(anyString(), anyString()))
                .thenReturn(firstEntity);
        ResponseEntity<Object> person = service.getPerson(userId, userName);
        Assert.assertNotNull(person);
    }
    
}
```

##### 使用反射机制初始化注入对象

这种是很简便的使用，如果想多写几行代码可以使用反射机制，set这些对象。

```java
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.when;

import com.xing.springDataJpa.first.FirstEntity;
import com.xing.springDataJpa.first.FirstRepository;
import com.xing.springDataJpa.service.impl.IndexServiceImpl;

import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.ResponseEntity;
import org.testng.Assert;
import org.testng.annotations.BeforeTest;
import org.testng.annotations.Test;

import java.lang.reflect.Field;

/**
 * 功能描述
 *
 * @since 2020-09-28
 */
public class IndexServiceImplTest {
    IndexServiceImpl service = new IndexServiceImpl();
    
    @Mock
    private FirstRepository firstRepository;
    
    @BeforeTest
    public void beforeTest() throws NoSuchFieldException, IllegalAccessException {
        System.out.println("========= beforeTest() ==========");
        // 其中this就是单元测试所在的类，在initMocks函数中Mockito会根据类中不同的注解（如@Mock, @Spy等）创建不同的mock对象，即初始化工作
        MockitoAnnotations.initMocks(this);
        
        Class serviceClass = service.getClass();
        // 反射获取属性
        Field firstRepositoryField = serviceClass.getDeclaredField("firstRepository");
        firstRepositoryField.setAccessible(true);
        firstRepositoryField.set(service, firstRepository);
    }
    
    @Test
    public void getPerson() {
        String userId = "3423423113";
        String userName = "xiaoming";
        FirstEntity firstEntity = new FirstEntity();
        firstEntity.setUserId(userId);
        firstEntity.setUserName(userName);
        when(firstRepository.findFirstByUserIdAndAndUserName(anyString(), anyString()))
                .thenReturn(firstEntity);
        ResponseEntity<Object> person = service.getPerson(userId, userName);
        Assert.assertNotNull(person);
    }
    
}

```







#### 3.5 静态类方法测试

> 在复杂的接口业务中，经常会用到一些工具类，静态方法等等，这类单元测试需要通过`PowerMockito`来实现静态方法的模拟。
>
> 静态方法：

```java
public class StaticUtils {
    
    public static String printList(List<String> list) {
            System.out.println("============ StaticUtils.printHello()============");
            list.forEach(System.out::println);
            return "printList";
        }
}
```

> `PowerMockito.mockStatic(StaticUtils.class);` 要放在 `MockitoAnnotations.initMocks(this);` 前面才可以，示例代码：

```java
import static org.mockito.Matchers.anyListOf;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.when;

import com.xing.springDataJpa.first.FirstEntity;
import com.xing.springDataJpa.first.FirstRepository;
import com.xing.springDataJpa.service.impl.IndexServiceImpl;
import com.xing.springDataJpa.utils.StaticUtils;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.testng.PowerMockObjectFactory;
import org.springframework.http.ResponseEntity;
import org.testng.Assert;
import org.testng.IObjectFactory;
import org.testng.annotations.BeforeTest;
import org.testng.annotations.ObjectFactory;
import org.testng.annotations.Test;

/**
 * 功能描述
 *
 * @since 2020-09-28
 */
@PrepareForTest(StaticUtils.class)
public class IndexServiceImplTest  {
    @Mock
    private FirstRepository firstRepository;

    // @InjectMocks: 创建一个实例，简单的说是这个Mock可以调用真实代码的方法，其余用@Mock（或@Spy）注解创建的mock将被注入到用该实例中。
    @InjectMocks
    private IndexServiceImpl service;
    
    @ObjectFactory
    public IObjectFactory getObjectFactory() {
        return new PowerMockObjectFactory();
    }
    
    @BeforeTest
    public void beforeTest() throws NoSuchFieldException, IllegalAccessException {
        System.out.println("========= beforeTest() ==========");
        // 其中this就是单元测试所在的类，在initMocks函数中Mockito会根据类中不同的注解（如@Mock, @Spy等）创建不同的mock对象，即初始化工作
        PowerMockito.mockStatic(StaticUtils.class);
        MockitoAnnotations.initMocks(this);
    }
    
    @Test
    public void getPerson() {
        String userId = "3423423113";
        String userName = "xiaoming";
        FirstEntity firstEntity = new FirstEntity();
        firstEntity.setUserId(userId);
        firstEntity.setUserName(userName);
        when(firstRepository.findFirstByUserIdAndAndUserName(anyString(), anyString()))
                .thenReturn(firstEntity);
        // 模拟静态方法
        String rel = "rel";
        PowerMockito.when(StaticUtils.printList(anyListOf(String.class)))
                .thenReturn(rel);
        ResponseEntity<Object> person = service.getPerson(userId, userName);
        Assert.assertNotNull(person);
    }
    
}
```

#### 3.6 @Mock、@InjectMocks、Mockito的区别

![image-20210416150258158](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210416150258.png)







#### 实际应用

> 但是如果 userDao 还没写好，又想先测 userService 的话，就需要使用 Mockito 去模拟一个假的 userDao 出来。
>
> 使用方法是在 userDao 上加上一个 @MockBean 注解，当 userDao 被加上这个注解之后，表示 Mockito 会帮我们创建一个假的 Mock 对象，替换掉 Spring 中已存在的那个真实的 userDao Bean，也就是说，注入进 userService 的 userDao Bean，已经被我们替换成假的 Mock 对象了，所以当我们再次调用 userService 的方法时，会去调用的实际上是 mock userDao Bean 的方法，而不是真实的 userDao Bean。
>
> 当我们创建了一个假的 userDao 后，我们需要为这个 mock userDao 自定义方法的返回值，这里有一个公式用法，下面这段代码的意思为，当调用了某个 Mock 对象的方法时，就回传我们想要的自定义结果。

```java
package com.chenqiao.fight.mock.user;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class UserService {
    
    @Autowired
    private UserDao userDao;
    
    public User getUserById(Integer id) {
        return userDao.getUserById(id);
    }
    
    public Integer insertUser(User user) {
        return userDao.insertUser(user);
    }
    
    public void print() {
        
    }
}
```

```java
package com.chenqiao.fight.mock.user;

/**
 * @Author: qiaole
 * @Description:
 * @Date: Created in 1:49 2020/5/24
 * @Modified By:
 */
public class UserDao {
    public User getUserById(Integer id) {
        return null;
    }
    
    public Integer insertUser(User user) {
        return null;
    }
}

```

```java
package com.chenqiao.fight.mock.user;

import com.chenqiao.fight.mock.MockApplication;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.junit4.SpringRunner;

/**
 * @Author: qiaole
 * @Description:
 * @Date: Created in 1:50 2020/5/24
 * @Modified By:
 */

@RunWith(SpringRunner.class)
@SpringBootTest(classes = MockApplication.class)
public class UserServiceTest {
    
    //先普通的注入一个userService bean
    @Autowired
    private UserService userService;
    
    @MockBean
    private UserDao userDao;
    
    @Test
    public void getUserById() {
        User user = userService.getUserById(1);
        //检查结果
        Assert.assertNotNull(user);
        Assert.assertEquals(user.getId(), new Integer(1));
        Assert.assertEquals(user.getName(), "John");
    }
    
    @Test
    public void mockGetUserById() {
        Mockito.when(userDao.getUserById(3)).thenReturn(new User(200, "i am mock 3"));
        User user = userService.getUserById(3);
        //检查结果
        Assert.assertNotNull(user);
        Assert.assertEquals(user.getId(), new Integer(200));
        Assert.assertEquals(user.getName(), "i am mock 3");
    }
    
    //    thenReturn 系列方法
    @Test
    public void mock1() {
        //    当使用任何整数值调用 userService 的 getUserById() 方法时，就回传一个名字为 I'm mock3 的 User 对象。
        Mockito.when(userService.getUserById(Mockito.anyInt())).thenReturn(new User(3, "I am mock"));
        User user1 = userService.getUserById(3);
        User user2 = userService.getUserById(200);
        System.out.println(user1.toString());
        System.out.println(user2.toString());
        
    }
    
    //    限制只有当参数的数字是 3 时，才会回传名字为 I'm mock 3 的 user 对象。
    @Test
    public void mock2() {
        Mockito.when(userService.getUserById(3)).thenReturn(new User(3, "i am mock"));
        User user1 = userService.getUserById(3);
        User user2 = userService.getUserById(200);
        System.out.println(user1.toString());
        System.out.println(user2);
    }
    
    //当调用 userService 的 insertUser() 方法时，不管传进来的 user 是什么，都回传 100。
    @Test
    public void mock3() {
        Mockito.when(userService.insertUser(Mockito.any(User.class))).thenReturn(100);
        Integer num = userService.insertUser(new User());
        System.out.println(num);
    }
    
    //    thenThrow 系列方法
    @Test
    public void mock4() {
        //当调用 userService 的 getUserById() 时的参数是 9 时，抛出一个 RuntimeException。
        Mockito.when(userService.getUserById(9)).thenThrow(new RuntimeException("mock throw exception"));
        userService.getUserById(9);
    }
    
    @Test
    public void mock5(){
        //如果方法没有返回值的话（即是方法定义为 public void myMethod() {...}），要改用 doThrow() 抛出 Exception。
        Mockito.doThrow(new RuntimeException("mock throw exception")).when(userService).print();
        userService.print();
    }
    
    //verify 系列方法
    public void mock6(){
        //检查调用 userService 的 getUserById()、且参数为3的次数是否为1次。
        Mockito.verify(userService,Mockito.times(1)).getUserById(Mockito.eq(3));
    }
}

```



```java
package com.nd.elearning.library.business.service;

import com.nd.egoods.GoodsApi;
import com.nd.egoods.SkuApi;
import com.nd.egoods.vo.GoodsVo;
import com.nd.egoods.vo.SkuVo;
import com.nd.elearning.library.business.constants.GoodsMqConstant;
import com.nd.esales.SalesApi;
import com.nd.esales.vo.GoodsPromotionVo;
import com.nd.esales.vo.PromotionVo;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

import java.math.BigDecimal;
import java.util.*;

import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.when;

public class GoodsMqServiceTest {

    @Mock
    private GoodsApi goodsApi;
    @Mock
    private SkuApi skuApi;
    @Mock
    private SalesApi salesApi;
    @InjectMocks
    private GoodsMqService goodsMqService = Mockito.mock(GoodsMqService.class, Mockito.CALLS_REAL_METHODS);

    @Before
    public void before() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testUpdateExtraCommodity() {
        UUID goodsId = UUID.fromString("018ab8c3-e7d9-449f-97cc-ed53335f5639");
        GoodsVo goodsVo = new GoodsVo();
        goodsVo.setGoodsId(goodsId);
        goodsVo.setStatus(GoodsMqConstant.STATUS_ON);
        when(this.goodsApi.getByResource(anyInt(), any(UUID.class))).thenReturn(goodsVo);

        UUID skuId = UUID.fromString("f43ea3a4-568d-4294-8b2a-aa28d01d972b");
        List<SkuVo> skuVos = new ArrayList<>();
        SkuVo skuVo = new SkuVo();
        skuVo.setSkuId(skuId);
        skuVo.setStatus(GoodsMqConstant.STATUS_ON);
        skuVo.setAmount(new BigDecimal("1"));
        skuVos.add(skuVo);
        when(this.skuApi.findByGoodsId(any(UUID.class))).thenReturn(skuVos);

        List<PromotionVo> promotionVos = new ArrayList<>();
        GoodsPromotionVo goodsPromotionVo = new GoodsPromotionVo();
        goodsPromotionVo.setSalesType(PromotionVo.SALES_TYPE_SINGLE);
        goodsPromotionVo.setSalesSubType(GoodsPromotionVo.SALES_SUB_TYPE_TJ);
        Map salesConfig = new HashMap();
        salesConfig.put("amount", 11);
        salesConfig.put("amount_type", "CHANNEL_CASH");
        goodsPromotionVo.setSalesConfig(salesConfig);
        goodsPromotionVo.setStatus(PromotionVo.STATUS_IN);
        promotionVos.add(goodsPromotionVo);
        when(this.salesApi.getSkuPromotions(any(UUID.class))).thenReturn(promotionVos);

        Map<String, Object> extra = new HashMap<>();
        goodsMqService.updateExtraCommodity(UUID.randomUUID(), extra);
        Assert.assertFalse("error", extra.isEmpty());
    }

    @Test
    public void testUpdateExtraCommodityOther() {
        goodsMqService.updateExtraCommodity(UUID.randomUUID(), null);

        UUID goodsId = UUID.fromString("018ab8c3-e7d9-449f-97cc-ed53335f5639");
        GoodsVo goodsVo = new GoodsVo();
        goodsVo.setGoodsId(goodsId);
        goodsVo.setStatus(GoodsMqConstant.STATUS_OFF);
        when(this.goodsApi.getByResource(anyInt(), any(UUID.class))).thenReturn(goodsVo);


        goodsVo.setStatus(GoodsMqConstant.STATUS_ON);
        when(this.goodsApi.getByResource(anyInt(), any(UUID.class))).thenReturn(goodsVo);
        goodsMqService.updateExtraCommodity(UUID.randomUUID(), null);

        UUID skuId = UUID.fromString("f43ea3a4-568d-4294-8b2a-aa28d01d972b");
        List<SkuVo> skuVos = new ArrayList<>();
        SkuVo skuVo = new SkuVo();
        skuVo.setSkuId(skuId);
        skuVo.setStatus(GoodsMqConstant.STATUS_OFF);
        skuVo.setAmount(new BigDecimal("1"));
        skuVos.add(skuVo);
        when(this.skuApi.findByGoodsId(any(UUID.class))).thenReturn(skuVos);
        goodsMqService.updateExtraCommodity(UUID.randomUUID(), null);

        skuVo = new SkuVo();
        skuVo.setSkuId(skuId);
        skuVo.setStatus(GoodsMqConstant.STATUS_ON);
        skuVo.setAmount(new BigDecimal("0"));
        skuVos.clear();
        skuVos.add(skuVo);
        when(this.skuApi.findByGoodsId(any(UUID.class))).thenReturn(skuVos);
        goodsMqService.updateExtraCommodity(UUID.randomUUID(), null);
    }
}

```

#### Springboot集成案例

##### 1.项目结构

https://blog.csdn.net/Guesshat/article/details/115045909

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210321182357916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0d1ZXNzaGF0,size_16,color_FFFFFF,t_70)

##### 2.依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.example</groupId>
    <artifactId>mockito</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>mockito</name>
    <description>Demo project for Spring Boot</description>
    <properties>
        <java.version>1.8</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>


```

##### 3.domain类

```java
package com.example.mockito.domain;

public class Student {
    private String name;
    private int age;
    private Integer id;


    public Student(String name, Integer age, Integer id) {
        this.name = name;
        this.age = age;
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public int getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }
}


```

##### 4.dao

```java
package com.example.mockito.dao;

import com.example.mockito.domain.Student;
import org.springframework.stereotype.Component;

@Component
public class StudentDao {

    public Student getById(Integer id) {

        return new Student("张三", 20, 5);
    }
}


```

##### 5.service

```java
package com.example.mockito.service;

import com.example.mockito.dao.StudentDao;
import com.example.mockito.domain.Student;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class StudentService {
    @Autowired
    StudentDao studentDao;

    public Student getStudentById(Integer id) {
        return studentDao.getById(id);
    }
}


```

##### 6.主启动类

```java
package com.example.mockito;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MockitoApplication {

    public static void main(String[] args) {
        SpringApplication.run(MockitoApplication.class, args);
    }

}


```

##### 7.测试类

```java
package com.example.mockito.service;

import com.example.mockito.dao.StudentDao;
import com.example.mockito.domain.Student;


import org.junit.Assert;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;

import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;


@SpringBootTest
class StudentServiceTest {

    @Autowired
    StudentService studentService;

    @MockBean
    StudentDao studentDao;


    @BeforeEach
    void setUp() {
        Mockito.when(studentDao.getById(5)).thenReturn(new Student("李四", 30, 5));
    }

    @Test
    void getStudentById() {
        Student student = studentService.getStudentById(5);

        Assert.assertNotNull(student);
        Assert.assertEquals(student.getAge(), 30);
        Assert.assertEquals(student.getName(), "李四");
    }
}

```

##### 8.主测试类

```java
package com.example.mockito;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class MockitoApplicationTests {

    @Test
    void contextLoads() {
    }

}


```



## MongoDB

### 一、安装

#### 1.1 配置环境变量

![image-20210416194600515](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210416194600.png)

#### 1.2 设置

![image-20210416194909514](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210416194909.png)

```xml
1.	D:
2.	cd D:\MongoDB\Server\4.0\bin
3.	mongod --dbpath "D:\MongoDB\Server\4.0\bin" --logpath "D: \MongoDB\Server\4.2\log\MongoDB.log" --install --serviceName "MongoDB"

```



```shell
1.	NET start MongoDB
2.	NET stop MongoDB

```

![image-20210416194946768](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210416194946.png)



### 二、基本操作



> show dbs;                  #查看全部数据库
>
> show collections;          #显示当前数据库中的集合（类似关系数据库中的表）
>
> show users;                #查看当前数据库的用户信息
>
> use <db name>;             #切换数据库跟mysql一样
>
> db;或者db.getName();        #查看当前所在数据库
>
> db.help();                 #显示数据库操作命令，里面有很多的命令 
> db.foo.help();             #显示集合操作命令，同样有很多的命令，foo指的是当前数据库下，一个叫foo的集合，并非真正意义上的命令 
> db.foo.find();             #对于当前数据库中的foo集合进行数据查找（由于没有条件，会列出所有数据） 
> db.foo.find( { a : 1 } );  #对于当前数据库中的foo集合进行查找，条件是数据中有一个属性叫a，且a的值为1

#### 2.1 创建一个数据库

```shell
> use test;             #创建数据库
switched to db test
> db;               
test
> show dbs;           #检查数据库
admin 0.000GB
local 0.000GB

> db.test.insert({"_id":"520","name":"xiaoming"})         #创建表

WriteResult({ "nInserted" : 1 })

> db.createUser({user:"xiaoming",pwd:"123456",roles:[{role:"userAdmin",db:"test"}]})        #创建用户
Successfully added user: {
"user" : "xiaoming",
"roles" : [
{
"role" : "userAdmin",
"db" : "test"
}
]
}db.removeUser("userName");         #删除用户show users;                        #显示当前所有用户

```

db.dropDatabase(); #删除当前使用数据库

```shell
> show dbs;
admin 0.000GB
local 0.000GB
test 0.000GB
test_1 0.000GB

> db;
test_1

> db.dropDatabase();
{ "dropped" : "test_1", "ok" : 1 }


> show dbs;
admin 0.000GB
local 0.000GB
test 0.000GB

```

db.stats(); #显示当前db状态

```shell
> db.stats();
{
    "db" : "test_1",
    "collections" : 0,
    "views" : 0,
    "objects" : 0,
    "avgObjSize" : 0,
    "dataSize" : 0,
    "storageSize" : 0,
    "numExtents" : 0,
    "indexes" : 0,
    "indexSize" : 0,
    "fileSize" : 0,
    "ok" : 1
}

```

db.version(); #当前db版本

db.getMongo(); #查看当前db的链接机器地址



#### 2.2 **mongodb find查询文档**

```shell
基本语法：

db.表名.find({'key':'value'});

实例：

> show dbs;
admin 0.000GB
easy-mock 0.001GB
local 0.000GB
> use easy-mock
switched to db easy-mock
> db
easy-mock
> show collections;
groups
mock_counts
mocks
projects
user_group
user_project
users
> db.users.find({'name':'xiaoming'});
{ "_id" : ObjectId("5bc859307e81d95b15f67c5c"), "head_img" : "//img.souche.com/20161230/png/fd9f8aecab317e177655049a49b64d02.png", "nick_name" : "1539856688465", "password" : "$2a$08$7mAecPo6N8ATesAxfKrPG.wb10Ns.LfntUNkce7p2pAJ0kAvW3fPm", "name" : "xiaoming", "create_at" : ISODate("2018-10-18T09:58:08.465Z"), "__v" : 0 }

```

#### 2.3 **mongodb update修改文档**

```shell
# 查找name为xiaoming的用户，将用户的密码更改

> db.users.update({'name':'xiaoming'},{$set:{'password':'$2a$08$UIEXZ7uK1opggCsTkmE2buE.EuWjchH42GYDnPcEn0PL/Y5dVT7l2'}})
　> db.users.find({'name':'xiaoming'});{ "_id" : ObjectId("5bc859307e81d95b15f67c5c"), "head_img" : "//img.souche.com/20161230/png/fd9f8aecab317e177655049a49b64d02.png", "nick_name" : "1539856688465", "password" : "$2a$08$UIEXZ7uK1opggCsTkmE2buE.EuWjchH42GYDnPcEn0PL/Y5dVT7l2", "name" : "xiaoming", "create_at" : ISODate("2018-10-18T09:58:08.465Z"), "__v" : 0 }

```

#### 2.4 开启远程访问

```shell
编辑配置文件：vi /etc/mongod.conf
bindIp: 172.16.40.205      #数据库所在服务器IP地址
保存重启数据库！
本地登录：mongo 172.16.40.205/admin -uadmin -p123456
远程登录：
1. 下载mongodb压缩包
mongodb-linux-x86_64-3.4.10.tgz
2. 解压
> tar zxvf mongodb-linux-x86_64-3.4.10.tgz
3. 进入bin目录
> cd mongodb-linux-x86_64-3.4.10/bin
4. 连接远程数据库
> ./mongo 172.16.40.205:27017/admin  -u user  -p  password

```

#### 2.5 **mongodDB备份与恢复**

##### mongodDB备份

```shell
【语法】：mongodump -h <dbhost> -d <dbname> -o <dbdirectory>
-h：
MongDB所在服务器地址，例如：127.0.0.1或localhost，当然也可以指定端口号：127.0.0.1:27017

-d：
需要备份的数据库实例名，例如：users

-o：
指定备份的数据存放的目录位置，例如：/root/mongdbbak/，当然该目录需要提前建立，在备份完成后，系统自动在/root/mongdbbak/目录下建立一个users目录，这个目录里面存放该数据库实例的备份数据。数据形式是以JSON的格式文件存储。

例如： 
mongodump -h localhost -d users -o /root/mongdbbak/

```

##### mongodDB恢复

```shell
【语法】：mongorestore -h <hostname><:port> -d dbname <path>
--host <:port>, -h <:port>：
MongoDB所在服务器地址，默认为:localhost:27017

-d ：
需要恢复的数据库实例名，例如：users，当然这个名称也可以和备份时候的不一样，比如user2

--drop：
恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，谨慎使用！

--dir：
指定备份的目录。

例如：
mongorestore -h localhost -d users --dir /root/mongdbbak/users

```



### 三、MongoDB的体系结构

![image-20210420135649640](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420140045.png)



![image-20210420135906403](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420135906.png)



#### 3.1  数据类型

![image-20210420140026415](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420140026.png)

BSON数据类型参考列表：

![image](https://img-blog.csdnimg.cn/img_convert/ffb50c177eb497e7b1b863feca0cb9b1.png)

#### 3.2 特点

![image-20210420140244173](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420140244.png)



### 四、CURD

https://blog.csdn.net/qq_45173404/article/details/114260970

#### 4.1 增：插入文档

```shell
db.集合名.insert(json数据)
```

![image-20210420165522865](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420165524.png)

##### 4.1.1  插入一条数据

![image-20210420165630502](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210420165630502.png)

```shell
db.student.insert({name:"zsr",age:20})
```

##### 4.1.2  一次插入多条数据并指定`_id`

![image-20210420165737741](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420165738.png)

```shell
db.student.insertMany([{_id:1,name:"z",age:20},{_id:2,name:"s",age:21},{_id:3,name:"r",age:22}])
```

##### 4.1.3  利用for循环插入数据

![image-20210420165815060](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420165815.png)

```shell
for(var i=1;i<10;i++){
	db.student.insert({name:"a"+i,age:i})
}

```

#### 4.2  删：删除文档

![image-20210420170115688](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420170115.png)

![image-20210420170253392](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420170253.png)



#### 4.3 改：修改文档

![image-20210420170402370](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420170402.png)

##### 4.3.1  **准备工作**：插入十条数据

![image-20210420170529746](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420170530.png)

##### 4.3.2  将{name:“zsr1”}更改为{name:“zsr2”}

```shell
db.people.update({name:"zsr1"},{name:"zsr2"})
```

![image-20210420171220743](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420171221.png)

解决问题：使用修改器将{name:“zsr3”}更改为{name:“zsr3333”}

```shell
db.people.update({name:"zsr3"},{$set:{name:"zsr3333"}})
```

![image-20210223102308690](https://img-blog.csdnimg.cn/img_convert/2b807f5039b545b03f178823e14a9e0f.png)



##### 4.3.3 给{name:“zsr10”}的年龄增加或减少2岁

```shell
# 增加两岁
db.people.update({name:"zsr10"},{$inc:{age:2}})

# 减少两岁
db.people.update({name:"zsr10"},{$inc:{age:-2}})

```

![image-20210420171524017](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420171524.png)

##### 4.3.4  一次写多个修改器

首先插入一条数据

```shell
db.people.insert({username:"gcc",age:20,sex:"女",address:"unknown"})
```


任务：修改gcc的username为bareth，age+11，sex字段重命名为sexuality，删除address字段

```shell
db.people.update({username:"gcc"},{
	$set:{username:"bareth"},
	$inc:{age:11},
	$rename:{sex:"sexuality"},
	$unset:{address:true}
})
```

![image-20210420172348556](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420172348.png)



#### 4.4 查：查询文档

![image-20210420172454997](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420172455.png)



##### 4.4.1  查询指定列的所有数据

![image-20210420172521110](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210420172521.png)

##### 4.4.2 查询指定条件的数据

![image-20210421111549718](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210421111549718.png)

#### 4.5 排序&分页

```shell
for(var i=1;i<5;i++){
	db.person.insert({_id:i,name:"p"+i,age:10+i})
}

```

![image-20210421111643866](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210421111644.png)

##### 4.5.1  排序

![image-20210421111817598](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210421111818.png)

###### 按年龄降序排列

![image-20210421112103703](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210421112103.png)

##### 4.5.2  分页

![image-20210421112133576](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210421112133.png)

![image-20210421112311233](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210421112311.png)

#### 4.6 聚合查询

##### 4.6.1   语法

![image-20210421112652669](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210421112652.png)


数据准备：

```shell
db.people.insert({_id:1,name:"a",sex:"男",age:21})
db.people.insert({_id:2,name:"b",sex:"男",age:20})
db.people.insert({_id:3,name:"c",sex:"女",age:20})
db.people.insert({_id:4,name:"d",sex:"女",age:18})
db.people.insert({_id:5,name:"e",sex:"男",age:19})
```

##### 4.6.2  统计男生、女生的总年龄

```shell
db.people.aggregate([
	{$group:{_id:"$sex",age_sum:{$sum:"$age"}}}
])

```

![image-20210223234358509](https://img-blog.csdnimg.cn/img_convert/27c8188a95e589bd7ca9665b0ea93294.png)



##### 4.6.3 统计男生女生的总人数

```shell
db.people.aggregate([
	{$group:{_id:"$sex",sum:{$sum:1}}}
])

```

![image-20210223234722079](https://img-blog.csdnimg.cn/img_convert/5dd2167f88bd5fd89775781c8798dfd5.png)

##### 4.6.4 求学生总数和平均年龄

```shell
db.people.aggregate([
	{$group:{_id:null,total_num:{$sum:1},total_avg:{$avg:"$age"}}}
])

```

![image-20210224103820145](https://img-blog.csdnimg.cn/img_convert/f99dabec22dbe9153b987bd423014e44.png)



##### 4.6.5  查询男生、女生人数，按人数升序

```shell
db.people.aggregate([
	{$group:{_id:"$sex",rs:{$sum:1}}},
	{$sort:{rs:1}}
])

```

![image-20210224104707963](https://img-blog.csdnimg.cn/img_convert/7a1ea66121e1c458068875e1b45b4f7c.png)



### 五、索引

![image-20210421152118922](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210421152119.png)



#### 5.1 语法

![image-20210421152158521](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210421152158.png)

#### 5.2  **创建普通索引**

![image-20210421171516844](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210421171516844.png)

![image-20210421171638434](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210421171638.png)

#### 5.3  **删除索引**

![image-20210421171733010](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210421171733.png)



#### 5.4 **创建复合/组合索引**

![image-20210421171823868](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210421171824.png)

#### 5.5  **创建唯一索引**

![image-20210421171845797](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210421171845.png)

#### 5.6  分析索引(explain)

```shell
db.集合名.find().explain('executionStats')

```

三种扫描方式

- `COLLSCAN`：全盘扫描
- `INSCAN`：索引扫描
- `FETCH`：根据索引去检索指定document

我们通过简单的案例来测试索引的好处

- 不加索引时查询`age=500`的数据

```json
> db.data.find({age:500}).explain('executionStats')
{
        "queryPlanner" : {
                "plannerVersion" : 1,
                "namespace" : "test.data",
                "indexFilterSet" : false,
                "parsedQuery" : {
                        "age" : {
                                "$eq" : 500
                        }
                },
                "winningPlan" : {
                        "stage" : "COLLSCAN",
                        "filter" : {
                                "age" : {
                                        "$eq" : 500
                                }
                        },
                        "direction" : "forward"
                },
                "rejectedPlans" : [ ]
        },
        "executionStats" : {	#执行计划相关统计信息
                "executionSuccess" : true,	#执行成功的状态
                "nReturned" : 1,	#返回结果集数目
                "executionTimeMillis" : 37,	#执行所需要的ms数
                "totalKeysExamined" : 0,	#索引检查的时间
                "totalDocsExamined" : 100000,	#检查文档总数
                "executionStages" : {
                        "stage" : "COLLSCAN",	#索引扫描方式
                        "filter" : {	#过滤条件
                                "age" : {
                                        "$eq" : 500
                                }
                        },
                        "nReturned" : 1,	#返回结果集数目
                        "executionTimeMillisEstimate" : 1,	#预估执行时间(ms)
                        "works" : 100002,	#工作单元数,一个查询会被派生为一个小的工作单元
                        "advanced" : 1,	#优先返回的结果数
                        "needTime" : 100000,
                        "needYield" : 0,
                        "saveState" : 100,
                        "restoreState" : 100,
                        "isEOF" : 1,
                        "direction" : "forward",	 
                        "docsExamined" : 100000	#文档检查数目
                }
        },
        "serverInfo" : {
                "host" : "LAPTOP-8J48VF43",
                "port" : 27017,
                "version" : "4.4.2",
                "gitVersion" : "15e73dc5738d2278b688f8929aee605fe4279b0e"
        },
        "ok" : 1
}

```

- 给age添加一个升序索引后

```json
# 给age添加升序索引
> db.data.createIndex({age:1})
{
        "createdCollectionAutomatically" : false,
        "numIndexesBefore" : 2,
        "numIndexesAfter" : 3,
        "ok" : 1
}
# 性能分析
> db.data.find({age:500}).explain('executionStats')
{
        "queryPlanner" : {
                "plannerVersion" : 1,
                "namespace" : "test.data",
                "indexFilterSet" : false,
                "parsedQuery" : {
                        "age" : {
                                "$eq" : 500
                        }
                },
                "winningPlan" : {
                        "stage" : "FETCH",
                        "inputStage" : {
                                "stage" : "IXSCAN",
                                "keyPattern" : {
                                        "age" : 1
                                },
                                "indexName" : "age_1",
                                "isMultiKey" : false,
                                "multiKeyPaths" : {
                                        "age" : [ ]
                                },
                                "isUnique" : false,
                                "isSparse" : false,
                                "isPartial" : false,
                                "indexVersion" : 2,
                                "direction" : "forward",
                                "indexBounds" : {
                                        "age" : [
                                                "[500.0, 500.0]"
                                        ]
                                }
                        }
                },
                "rejectedPlans" : [ ]
        },
        "executionStats" : {	#执行计划相关统计信息
                "executionSuccess" : true,	#执行成功的状态
                "nReturned" : 1,	#返回结果集数目
                "executionTimeMillis" : 1,	#执行所需要的ms数
                "totalKeysExamined" : 1,	#索引检查的时间
                "totalDocsExamined" : 1,	#检查文档总数
                "executionStages" : {
                        "stage" : "FETCH",	#索引扫描方式
                        "nReturned" : 1,	#返回结果集数目
                        "executionTimeMillisEstimate" : 0,	#预估执行时间(ms)
                        "works" : 2,	#工作单元数,一个查询会被派生为一个小的工作单元
                        "advanced" : 1,	#优先返回的结果数
                        "needTime" : 0,
                        "needYield" : 0,
                        "saveState" : 0,
                        "restoreState" : 0,
                        "isEOF" : 1,
                        "docsExamined" : 1,
                        "alreadyHasObj" : 0,
                        "inputStage" : {
                                "stage" : "IXSCAN",
                                "nReturned" : 1,
                                "executionTimeMillisEstimate" : 0,
                                "works" : 2,
                                "advanced" : 1,
                                "needTime" : 0,
                                "needYield" : 0,
                                "saveState" : 0,
                                "restoreState" : 0,
                                "isEOF" : 1,
                                "keyPattern" : {
                                        "age" : 1
                                },
                                "indexName" : "age_1",
                                "isMultiKey" : false,
                                "multiKeyPaths" : {
                                        "age" : [ ]
                                },
                                "isUnique" : false,
                                "isSparse" : false,
                                "isPartial" : false,
                                "indexVersion" : 2,
                                "direction" : "forward",
                                "indexBounds" : {
                                        "age" : [
                                                "[500.0, 500.0]"
                                        ]
                                },
                                "keysExamined" : 1,
                                "seeks" : 1,
                                "dupsTested" : 0,
                                "dupsDropped" : 0
                        }
                }
        },
        "serverInfo" : {
                "host" : "LAPTOP-8J48VF43",
                "port" : 27017,
                "version" : "4.4.2",
                "gitVersion" : "15e73dc5738d2278b688f8929aee605fe4279b0e"
        },
        "ok" : 1
}

```

#### 5. 7 选择规则

如何选择合适的列创建索引？

- 为常做条件、排序、分组的字段建立索引
- 选择唯一性索引
- 选择较小的数据列，为较长的字符串使用前缀索引



### 六、Spring Boot整合Mongo DB



新建一个Spring Boot项目，版本为2.1.3.RELEASE，并引入如下依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```



然后可以通过Mongo Shell或者Mongo Compass工具创建一个名称为testdb的数据库，并新增user文档（文档，类似与关系型数据库里的数据表）：

![QQ截图20190402141210.png](https://mrbird.cc/img/QQ截图20190402141210.png)

在配置文件application.yml里配置Mongo DB：

```yaml
spring:
  data:
    mongodb:
      host: localhost
      port: 27017
      database: testdb
```



Mongo DB的默认端口为27017，使用的数据库为刚刚创建的testdb。

#### 常用注解

##### @Document

> 使用`@Document`（org.springframework.data.mongodb.core.mapping.Document）标注`Java`的类名对应的`MongoDB`的集合名称。

##### @Id、@MongoId

> 使用`@Id`（org.springframework.data.annotation.Id）或`@MongoId`（低版本依赖可能需升级才有）映射`MongoDB`的`_id`字段，若没有使用这两个注解，则字段中名称为`id`的字段将自动映射到`_id`上。使用这两个注解可标注的字段类型为`String`、`ObjectId`（org.bson.types.ObjectId）。

##### @Field

> 使用`@Field`（org.springframework.data.mongodb.core.mapping.Field）字段，将`Java`类中字段名称与`MongoDB`集合中字段名称不一致的字段映射成一致的。如`Java`中使用了驼峰命名的`startTs`字段，想要映射成`MongoDB`中的`start_ts`字段就可以使用`@Field`完成。

##### @Transient

> 使用`@Transient`（org.springframework.data.annotation.Transient）标注该字段不持久化至数据库中。

```java
@Document("test_dto")
public class TestDto {

    @Id
    private String id;
//    @MongoId
//    private String id;

    @Field("create_ts")
    private long createTs;

    @Transient
    private String ignoreProperty;

}
```



#### 创建User实体类：

```java
@Document(collection = "user")
public class User {

    @Id
    private String id;

    private String name;

    private Integer age;

    private String description;

    // get set 略
}
```

`@Document(collection = "user")`表明这是一个文档对象，名称为`user`，对应Mongo DB里的user表。`@Id`标注主键字段，String类型的主键值在插入的时候Mongo DB会帮我们自动生成。如果对象中的某个属性为非表字段，可以使用注解`@Transient`进行排除。

准备好这些后，我们开始编写一些简单的增删改查样例。

#### 简单增删改查

#### 创建一个UserDao接口：

```
@Repository
public interface UserDao extends MongoRepository<User, String> {
}
```



接口继承自`MongoRepository`，泛型分别为实体对象和主键类型。通过继承`MongoRepository`，`UserDao`包含了一些增删改查的方法，如下图所示：

![QQ截图20190404094010.png](https://mrbird.cc/img/QQ截图20190404094010.png)

接着编写UserService，为了方便这里不再编写接口：

```java
@Service
public class UserService {

    @Autowired
    private UserDao userDao;

    public List<User> getUsers() {
        return userDao.findAll();
    }

    public Optional<User> getUser(String id) {
        return this.userDao.findById(id);
    }

    /**
     * 新增和修改都是 save方法，
     * id 存在为修改，id 不存在为新增
     */
    public User createUser(User user) {
        user.setId(null);
        return userDao.save(user);
    }

    public void deleteUser(String id) {
        this.userDao.findById(id)
                .ifPresent(user -> this.userDao.delete(user));
    }

    public void updateUser(String id, User user) {
        this.userDao.findById(id)
            .ifPresent(
                u -> {
                    u.setName(user.getName());
                    u.setAge(user.getAge());
                    u.setDescription(user.getDescription());
                    this.userDao.save(u);
                }
            );
    }
}
```



上面我们编写了基本的增删改查样例，新增和修改都是通过`save`方法完成的，当主键存在时则为修改，主键不存在则为新增。

最后编写一个RESTful的UserController（为了方便，没有对参数进行校验）：

```java
@RestController
@RequestMapping("user")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping
    public List<User> getUsers() {
        return userService.getUsers();
    }

    @PostMapping
    public User createUser(User user) {
        return userService.createUser(user);
    }

    @DeleteMapping("/{id}")
    public void deleteUser(@PathVariable String id) {
        userService.deleteUser(id);
    }

    @PutMapping("/{id}")
    public void updateUser(@PathVariable String id, User user) {
        userService.updateUser(id, user);
    }

    /**
     * 根据用户 id查找
     * 存在返回，不存在返回 null
     */
    @GetMapping("/{id}")
    public User getUser(@PathVariable String id) {
        return userService.getUser(id).orElse(null);
    }
}
```



启动项目，使用postman来测试接口的可用性。

测试新增用户：

![QQ截图20190402142923.png](https://mrbird.cc/img/QQ截图20190404094900.png)

新增成功，查看数据库：

![QQ截图20190404094944.png](https://mrbird.cc/img/QQ截图20190404094944.png)

测试查询用户：

![QQ截图20190402143028.png](https://mrbird.cc/img/QQ截图20190404095026.png)

查询成功。

测试通过用ID查找用户：

![QQ截图20190402143107.png](https://mrbird.cc/img/QQ截图20190404095104.png)

更新用户：

![QQ截图20190402143139.png](https://mrbird.cc/img/QQ截图20190404095151.png)

查看数据库是否更新成功：

![QQ截图20190402143232.png](https://mrbird.cc/img/QQ截图20190404095609.png)

更新成功。

最后测试通过用户ID删除用户：

![QQ截图20190402143320.png](https://mrbird.cc/img/QQ截图20190404095646.png)

返回状态码200，删除成功。

查看数据库，删除成功：

![QQ截图20190404095710.png](https://mrbird.cc/img/QQ截图20190404095710.png)

#### 多条件查询

其实`UserDao`通过继承`MongoRepository`已经具有了JPA的特性，我们可以通过方法名来构建多查询条件的SQL。比如通过用户的年龄段来查询：

```java
@Repository
public interface UserDao extends MongoRepository<User, String> {

    /**
     * 根据年龄段来查找
     *
     * @param from from
     * @param to   to
     * @return List<User>
     */
    List<User> findByAgeBetween(Integer from, Integer to);
}
```



在输入`findBy`后，IDEA会根据实体对象的属性和SQL的各种关键字自动组合提示：

![QQ截图20190404101118.png](https://mrbird.cc/img/fasdfasdf.png)

比如再在创建一个通过年龄段，用户名和描述（模糊查询）查询用户的方法：

```java
/**
 * 通过年龄段，用户名，描述（模糊查询）
 *
 * @param from        from
 * @param to          to
 * @param name        name
 * @param description description
 * @return List<User>
 */
List<User> findByAgeBetweenAndNameEqualsAndDescriptionIsLike(Integer from, Integer to, String name, String description);
```

方法参数个数需要和方法名中所需要的参数个数对应上。

#### 排序与分页

排序和分页需要使用`MongoTemplate`对象来完成，在`UserService`里新增一个`getUserByCondition`方法：

```java
@Autowired
private MongoTemplate template;

public Page<User> getUserByCondition(int size, int page, User user) {
    Query query = new Query();
    Criteria criteria = new Criteria();

    if (!StringUtils.isEmpty(user.getName())) {
        criteria.and("name").is(user.getName());
    }
    if (!StringUtils.isEmpty(user.getDescription())) {
        criteria.and("description").regex(user.getDescription());
    }

    query.addCriteria(criteria);

    Sort sort = new Sort(Sort.Direction.DESC, "age");
    Pageable pageable = PageRequest.of(page, size, sort);

    List<User> users = template.find(query.with(pageable), User.class);
    return PageableExecutionUtils.getPage(users, pageable, () -> template.count(query, User.class));
}
```



`size`表示每页显示的条数，`page`表示当前页码数，0表示第一页。上面的方法通过`name`和`description`（模糊查询）来查询用户分页信息，并且查询结果使用`age`字段降序排序。方法返回`Page`对象。

在`UserController`里添加：

```java
@GetMapping("/condition")
public Page<User> getUserByCondition(int size, int page, User user) {
    return userService.getUserByCondition(size, page, user);
}
```



重启项目，我们往数据库里多加几条数据：

![QQ截图20190404102609.png](https://mrbird.cc/img/QQ截图20190404102609.png)

获取第1页数据，每页显示10条：

![QQ截图20190404102736.png](https://mrbird.cc/img/QQ截图20190404102736.png)

返回数据：

```java
{
    "content": [
        {
            "id": "5ca56ae2f08f0b6048fd470d",
            "name": "jane",
            "age": 26,
            "description": "web developer"
        },
        {
            "id": "5ca56ad1f08f0b6048fd470c",
            "name": "scott",
            "age": 23,
            "description": "ui designer"
        },
        {
            "id": "5ca56afaf08f0b6048fd470e",
            "name": "mike",
            "age": 21,
            "description": "python developer"
        },
        {
            "id": "5ca56b38f08f0b6048fd470f",
            "name": "mrbird",
            "age": 18,
            "description": "java noob"
        }
    ],
    "pageable": {
        "sort": {
            "sorted": true,
            "unsorted": false,
            "empty": false
        },
        "offset": 0,
        "pageSize": 10,
        "pageNumber": 0,
        "unpaged": false,
        "paged": true
    },
    "last": true,
    "totalPages": 1,
    "totalElements": 4,
    "number": 0,
    "size": 10,
    "sort": {
        "sorted": true,
        "unsorted": false,
        "empty": false
    },
    "numberOfElements": 4,
    "first": true,
    "empty": false
}
```



剩下可以自己测试。

https://www.cnblogs.com/bookc/p/9887922.html

#### DBObject对象查询

> MongoDB 查询有四种方式：Query，TextQuery，BasicQuery 和 BsonBasicQuery 相对于 Query 更加的灵活，BasicQuery 就是 Query 的扩展，BasicQuery 可以返回指定列数据。**最灵活的是Bson方式。**
>
> 1.MongoDB 虽然存储很灵活，但是，不要存储Map类型的，不要存储Map类型的，不要存储Map类型的。尽量存储强类型的，尽量存储强类型的，尽量存储强类型的。如果有Map类型的，对于查询指定列的，只能用Bson ，如果是强类型的，就可以直接用Query，TextQuery。
>
> 2.复杂类型查询 可以考虑 Bson 方式

测试数据代码

```java
 for (Long i = 0L; i < 10L; i++) {
     MongoDBTestVo vo=new MongoDBTestVo();
     vo.setUserId(i);
     vo.setEmail("1@1.com");
     vo.setName("test"+i.toString());
     vo.setPhone(i.toString());
     vo.setCreateDate(new Date());
     mongoTemplate.insert(vo,"mongodbtest");
}
```

```java
public class MongoDBTestVo implements Serializable {
    private Long userId;
    private String email;
    private String name;
    private String phone;
    private Date createDate;

    public Long getUserId() {
        return userId;
    }

    public void setUserId(Long userId) {
        this.userId = userId;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public Date getCreateDate() {
        return createDate;
    }

    public void setCreateDate(Date createDate) {
        this.createDate = createDate;
    }
}
```

##### 单条件查询

```java
DBObject obj = new BasicDBObject();
obj.put("userId", new BasicDBObject("$gte", 2)); // userId>=2的条件
//obj.put("userId", 2); userId=2 的条件
```

```java
Query query = new BasicQuery(obj.toString()); 
List<MongoDBTestVo> result = mongoTemplate.find(query, MongoDBTestVo.class, "mongodbtest");
```

##### 多条件查询

```java
BasicDBList basicDBList = new BasicDBList();
basicDBList.add(new BasicDBObject("userId", 2L));
basicDBList.add(new BasicDBObject("name","test2"));

DBObject obj = new BasicDBObject();
obj.put("$and", basicDBList);

Query query = new BasicQuery(obj.toString());

List<MongoDBTestVo> result = mongoTemplate.find(query, MongoDBTestVo.class, "mongodbtest");
```

##### 查看指定列的数据

```java
DBObject obj = new BasicDBObject();
obj.put("userId", new BasicDBObject("$gte", 2));

BasicDBObject fieldsObject = new BasicDBObject();
fieldsObject.put("userId", 1);
fieldsObject.put("name", 1);

Query query = new BasicQuery(obj.toString(), fieldsObject.toString());

List<Map> result = mongoTemplate.find(query, Map.class, "mongodbtest");
```

> BasicQuery查询语句可以指定返回字段，构造函数BasicQuery(DBObject queryObject, DBObject fieldsObject)，fieldsObject 这个字段可以指定返回字段
>
> fieldsObject.put(key,value)
>
> ​      key：字段
>
> ​      value：
>
> ​       说明：
>
> ​         1或者true表示返回字段
>
> ​         0或者false表示不返回该字段
>
> ​        _id:默认就是1，没指定返回该字段时，默认会返回，除非设置为0是，就不会返回该字段。
>
> 指定返回字段，有时文档字段多并数据大时，我们指定返回我们需要的字段，这样既节省传输数据量，减少了内存消耗，提高了性能，在数据大时，性能很明显的。



##### Bson查询方式



```java
Bson bson = Filters.and(Arrays.asList(
                    Filters.gte("createdTime", Calendar.getInstance().getTime()),
                    Filters.gte("apis.count", 1)));
MongoCursor<Document> cursor = null;
try {
    FindIterable<Document> findIterable = mongoTemplate.getCollection("mongodbtest").find(bson);
    cursor = findIterable.iterator();
    List<MongoDBTestVo> list = new ArrayList<>();
    while (cursor.hasNext()) {
          Document object = cursor.next();
          MongoDBTestVo entity = JSON.parseObject(object.toJson(), MongoDBTestVo.class);
          list.add(entity);
     }
     return list;
} finally {
   if (cursor != null) {
       cursor.close();
   }
}
```

######  Bson返回指定列



```java
Bson bson = Filters.and(Arrays.asList(
                    Filters.gte("createdTime", Calendar.getInstance().getTime()),
                    Filters.gte("apis.count", 1)));
```



```java
BasicDBObject fieldsObject = new BasicDBObject();
fieldsObject.put("apis.count", 1);
fieldsObject.put("_id", 0);
```



```java
MongoCursor<Document> cursor = null;
try {
    FindIterable<Document> findIterable = mongoTemplate.getCollection("mongodbtest").find(bson).projection(Document.parse(fieldsObject.toString()));
    cursor = findIterable.iterator();
    List<MongoDBTestVo> list = new ArrayList<>();
    while (cursor.hasNext()) {
          Document object = cursor.next();
          MongoDBTestVo entity = JSON.parseObject(object.toJson(), MongoDBTestVo.class);
          list.add(entity);
     }
     return list;
} finally {
   if (cursor != null) {
       cursor.close();
   }
}
```

 Bson 排序



```java
Bson bson = Filters.and(Arrays.asList(
```



```java
Filters.gte("createdTime", Calendar.getInstance().getTime()),
Filters.gte("apis.count", 1)));
```



```java
BasicDBObject fieldsObject = new BasicDBObject();
fieldsObject.put("apis.count", 1);
fieldsObject.put("_id", 0);
```



```java
BasicDBObject sort = new BasicDBObject();
sort.put("createdTime", 1);
```



```java
MongoCursor<Document> cursor = null;
try {
    FindIterable<Document> findIterable = mongoTemplate.getCollection("mongodbtest").find(bson).projection(Document.parse(fieldsObject.toString())).sort(sort);
    cursor = findIterable.iterator();
    List<MongoDBTestVo> list = new ArrayList<>();
    while (cursor.hasNext()) {
          Document object = cursor.next();
          MongoDBTestVo entity = JSON.parseObject(object.toJson(), MongoDBTestVo.class);
          list.add(entity);
     }
     return list;
} finally {
   if (cursor != null) {
       cursor.close();
   }
}
```









## SpringSecurity











## Redis

### 一、批量删除

https://blog.csdn.net/lixiaohai_918/article/details/107067589

```java
 public Set<Object> scan(String pattern) {
        redisTemplate.execute((RedisCallback<Set<Object>>) connection -> {
            JedisCommands commands = (JedisCommands) connection.getNativeConnection();
            MultiKeyCommands multiKeyCommands = (MultiKeyCommands) commands;
            int scanInvokeCount = 0;
            int totalCount = 0;
            log.info("RedisHelper_clearScan_invoke_start scanInvokeCount:{}",scanInvokeCount);
            ScanParams scanParams = new ScanParams();
            scanParams.match(pattern + "*");
            scanParams.count(500);
            ScanResult<String> scan = multiKeyCommands.scan("0", scanParams);
            scanInvokeCount++;
            while (null != scan.getStringCursor()) {
                List<String> keys = scan.getResult();
                if (!CollectionUtils.isEmpty(keys)){
                    int count = 0;
                    for (String key : keys) {
                        try {
                            connection.del(key.getBytes());
                            log.info("RedisHelper_clearScan key:{}",key);
                            count++;
                            totalCount++;
                        } catch (Exception e) {
                            log.info("RedisHelper_clearScan_fail key:{}",key);
                            e.printStackTrace();
                        }
                    }
                    log.info("RedisHelper_clearScan_delete count:{}",count);
                }
                if (!StringUtils.equals("0", scan.getStringCursor())) {
                    scan = multiKeyCommands.scan(scan.getStringCursor(), scanParams);
                    scanInvokeCount++;
                    log.info("RedisHelper_clearScan_invoke scanInvokeCount:{}",scanInvokeCount);
                    continue;
                } else {
                    break;
                }
            }
            log.info("RedisHelper_clearScan_invoke_end totalCount:{}",totalCount);
            log.info("RedisHelper_clearScan_invoke_end scanInvokeCount:{}",scanInvokeCount);
            return null;
        });
        return null;
    }

```

### 二、利用pipeline进行高效率批量操作

https://blog.csdn.net/xiaoliu598906167/article/details/82218525?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-8.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-8.control

#### 单机Redis

```java
public class RedisUtil {
 
    @Autowired
    private RedisTemplate<Object, Object> redisTemplate;
 
    /**
     * 功能描述: 使用pipelined批量存储
     *
     * @param: [map, seconds]
     * @return: void
     * @auther: liyiyu
     * @date: 2020/4/19 14:34
     */
    public void executePipelined(Map<String, String> map, long seconds) {
        RedisSerializer<String> serializer = redisTemplate.getStringSerializer();
        redisTemplate.executePipelined(new RedisCallback<String>() {
            @Override
            public String doInRedis(RedisConnection connection) throws DataAccessException {
                map.forEach((key, value) -> {
                    connection.set(serializer.serialize(key), serializer.serialize(value),Expiration.seconds(seconds), RedisStringCommands.SetOption.UPSERT);
                });
                return null;
            }
        },serializer);
    }
 
}
```

#### 集群下优化RedisPipeline操作

> 在redis集群上使用上面的方法操作，会导致执行时间变成长，也会带来额外的消耗。那么集群下如何使用Pipeline操作呢？Redis 集群中内置了 16384 个哈希槽，redisCluster把所有的物理节点映射到[0-16383]slot上，由cluster 负责维护。比如A,B,C三个节点，那么对应槽点的范围值可能是分别是0-5400，5401-10800，10801-16383。我们需要根据key用CRC16算法计算出该key的槽点值，获取到相应的节点，然后把同一节点的数据通过pipeline获取。则可以极大提升效率。

```java
public List<String> clusterPiplineGet(List<String> keys) {
        RedisSerializer keySerializer = redisClusterComponent.getRedisTemplate().getKeySerializer();
        RedisSerializer<String> valueSerializer = redisClusterComponent.getRedisTemplate().getValueSerializer();
        HashMap<RedisClusterNode, List<String>> nodeKeyMap = new HashMap<>();
        List<String> result = new ArrayList<>();
        RedisClusterConnection redisClusterConnection = redisClusterComponent.getRedisTemplate().getConnectionFactory().getClusterConnection();
        try {
            //通过计算每个key的槽点，并获取相应节点
            Iterable<RedisClusterNode> redisClusterNodes = redisClusterConnection.clusterGetNodes();
            for (RedisClusterNode redisClusterNode : redisClusterNodes) {
                RedisClusterNode.SlotRange slotRange = redisClusterNode.getSlotRange();
                for (String key : keys) {
                    int slot = JedisClusterCRC16.getSlot(key);
                    if (slotRange.contains(slot)) {
                        List<String> list = nodeKeyMap.get(redisClusterNode);
                        if (null == list) {
                            list = new ArrayList<>();
                            nodeKeyMap.putIfAbsent(redisClusterNode, list);
                        }
                        list.add(key);
                    }
                }
            }
            for (Map.Entry<RedisClusterNode, List<String>> clusterNodeListEntry : nodeKeyMap.entrySet()) {
                RedisClusterNode redisClusterNode = clusterNodeListEntry.getKey();
                //连接节点
                JedisPool jedisPool = ((JedisCluster) redisClusterConnection.getNativeConnection()).getClusterNodes().get(new HostAndPort(redisClusterNode.getHost(), redisClusterNode.getPort()).toString());
                List<String> nodeListEntryValue = clusterNodeListEntry.getValue();
 
                byte[][] arr = new byte[nodeListEntryValue.size()][];
                int count = 0;
                //获取key数据
                for (String nodeKey : nodeListEntryValue) {
                    arr[count++] = keySerializer.serialize(nodeKey);
                }
                Jedis jedis = jedisPool.getResource();
                List<Response<byte[]>> responses = new ArrayList<>();
                try {
                    Pipeline pipeline = jedis.pipelined();
                    for (String nodeKey : nodeListEntryValue) {
                        responses.add(pipeline.get(keySerializer.serialize(nodeKey)));
                    }
                    pipeline.close();
                } catch (IOException e) {
                    e.printStackTrace();
                } finally {
                    jedis.close();
                }
                for (Response<byte[]> response : responses) {
                    byte[] data = response.get();
                    result.add(valueSerializer.deserialize(data));
                }
            }
        } finally {
            RedisConnectionUtils.releaseConnection(redisClusterConnection, redisClusterComponent.getRedisTemplate().getConnectionFactory());
        }
        return result;
    }
```



## MySQL

### 一、建表

#### 1、语句

```mysql
DROP TABLE IF EXISTS `sys_user`;

CREATE TABLE `sys_user`
(
    `id`                   bigint      NOT NULL auto_increment COMMENT '主键ID',
    `username`             varchar(50) NOT NULL COMMENT '用户账号',
    `user_password`        varchar(50) NOT NULL COMMENT '登录密码',
    `password_salt`        varchar(10) NOT NULL COMMENT '密码盐:放于密码后面',
    `user_email`           varchar(50) NULL COMMENT '邮箱地址',
    `telephone`            varchar(20) NULL COMMENT '固话',
    `mobile_phone`         varchar(20) NULL COMMENT '手机号',
    `gender_enum`          tinyint     NOT NULL DEFAULT '1' COMMENT '性别:[1=保密=PRIVACY, 2=男性=MALE, 3=女性=FEMALE, 4=中性=NEUTRAL]max=4',
    `register_type_enum`   tinyint     NOT NULL DEFAULT '1' COMMENT '注册方式:[1=系统预置=SYSTEM_INIT, 2=后台管理系统新增=MANAGEMENT_ADD, 3=主动注册=REGISTER, 4=被邀请注册=INVITE]max=4',
    `register_origin_enum` tinyint     NOT NULL DEFAULT '1' COMMENT '注册来源:[1=WEB方式=WEB, 2=安卓APP=ANDROID, 3=苹果APP=IOS, 4=H5=H5, 5=微信小程序=WECHAT_MINI_PROGRAM, 6=微信公众号=WECHAT_OFFICIAL_ACCOUNT]max=6',
    `state_enum`           tinyint     NOT NULL DEFAULT '1' COMMENT '启用状态:[1=启用=ENABLE, 2=禁用=DISABLE]max=2',
    `delete_enum`          tinyint     NOT NULL DEFAULT '1' COMMENT '删除状态:[1=未删除=NOT_DELETED, 2=已删除=DELETED]max=2',
    `create_date`          bigint      NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE COMMENT '创建时间',
    `create_user_id`       bigint      NOT NULL COMMENT '创建人',
    `update_date`          bigint      NOT NULL COMMENT '更新时间',
    `update_user_id`       bigint      NOT NULL COMMENT '更新人',
    `delete_date`          bigint      NULL COMMENT '删除时间',
    `delete_user_id`       bigint      NULL COMMENT '删除人',
    PRIMARY KEY (`id`),
    UNIQUE KEY `unique_username` (`username`) USING BTREE COMMENT '登录用户名唯一',
    KEY `index_fk_id` (`fk_id`) USING BTREE,
	KEY `index_sys_xzqh` (`sys_xzqh`,`mdjlx`,`type`) USING BTREE,
	KEY `index_mhzsfz` (`mhzsfz`) USING BTREE,
	KEY `index_mhz` (`mhz`) USING BTREE,
	KEY `index_type` (`type`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT COMMENT ='用户表';
```

```mysql
create table tablename(
     col_name1 type auto_increment,
     col_name2 type not null|null default val,
     col_name3 type unique,
     .... ,
    primary key(col_name),
    index idx_name(col_name1,col_name2,...),
    foreign key(col_name) references tablename(col_name)
) engine=innoDB|myISAM default charset=字符集;

```



#### 2、建表的编码和排序

一般选择utf8.下面介绍一下utf8与utfmb4的区别。

![image-20210324173102223](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210324173102.png)



排序一般分为两种：utf_bin和utf_general_ci

![image-20210324172908351](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210324172910.png)





### 二、建索引

#### 1、普通索引

这是最基本的索引，它没有任何限制。它有以下几种创建方式：

##### 创建索引

![image-20210322152020546](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210322152106.png)



#### 2、唯一索引

它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：

![image-20210322152150790](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210322152151.png)



#### 3、ALTER 命令添加和删除索引

![image-20210322152308538](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210322152308.png)

#### 4、显示索引信息

![image-20210322152347300](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210322152347.png)



### 三、批量操作多表

```mysql

Select CONCAT( 'drop table ', table_name, ';' )
FROM information_schema.tables
Where table_name LIKE 'user_prefer_content_record_%';
```





### 四、字段类型

#### 数值

MySQL 的数值数据类型可以大致划分为两个类别，一个是整数，另一个是浮点数或小数。
许多不同的子类型对这些类别中的每一个都是可用的，每个子类型支持不同大小的数据，并且 MySQL 允许我们指定数值字段中的值是否有正负之分(UNSIGNED)或者用零填补(ZEROFILL)。
![191200073386330.png](https://images0.cnblogs.com/blog2015/487276/201505/191200073386330.png)

- INT
  在 MySQL 中支持的 5 个主要整数类型是 TINYINT，SMALLINT，MEDIUMINT，INT 和 BIGINT。这些类型在很大程度上是相同的，只有它们存储的值的大小是不相同的。
  MySQL 以一个可选的显示宽度指示器的形式对 SQL 标准进行扩展(如 INT(6),6即是其宽度指示器,**该宽度指示器并不会影响int列存储字段的大小,也就是说,超过6位它不会自动截取,依然会存储,只有超过它本身的存储范围才会截取;此处宽度指示器的作用在于该字段是否有zerofill,如果有就未满足6位的部分就会用0来填充**)，这样当从数据库检索一个值时，可以把这个值加长到指定的长度。例如，指定一个字段的类型为 INT(6)，就可以保证所包含数字少于 6 个的值从数据库中检索出来时能够自动地用空格填充。需要注意的是，使用一个宽度指示器不会影响字段的大小和它可以存储的值的范围。
  万一我们需要对一个字段存储一个超出许可范围的数字，MySQL 会根据允许范围最接近它的一端截短后再进行存储。还有一个比较特别的地方是，MySQL 会在不合规定的值插入表前自动修改为 0。
- unsigned 和 zerofill
  UNSIGNED 修饰符规定字段只保存正值,即无符号,而mysql字段默认是有符号的。因为不需要保存数字的正、负符号，可以在储时节约一个"位"的空间(即翻一倍)。从而增大这个字段可以存储的值的范围。注意这个修饰符要紧跟在数值类型后面;
  ZEROFILL 修饰符规定 0（不是空格）可以用来真补输出的值。使用这个修饰符可以阻止 MySQL 数据库存储负值,如果某列设置为zerofill,那它自动就unsigned。这个值要配合int,tinyint,smallint,midiumint等字段的宽度指示器来用;XXint(M),如果没有zerofill,这个M的宽度指示器是没有意义的.(注意,测试前导0的时候,还是去黑窗口测试;)

> 为什么mysql存储的值要分有符号和无符号呢?因为一个字节,占8bit;也就1个bit有0和1两种可能,8个bit就是2^8 = 256种可能,也就是0~255;但如果是有符号的话,就得拿一个1bit来存储这个负号,本来8bit只剩7bit,2^7 = 128,也就是-128~127(正数部分包含一个0);

- FLOAT、DOUBLE 和 DECIMAL 类型
  MySQL 支持的三个浮点类型是 FLOAT、DOUBLE 和 DECIMAL 类型。FLOAT 数值类型用于表示单精度浮点数值，而 DOUBLE 数值类型用于表示双精度浮点数值。
  与整数一样，这些类型也带有附加参数：一个显示宽度指示器和一个小数点指示器(必须要带有指示器,要不然会查不到结果,**并且宽度指示器和XXint类型的宽度指示器不同,这里是有实际限制宽度的**)。比如语句 FLOAT(7,3) 规定显示的值不会超过 7 位数字(包括小数位)，小数点后面带有 3 位数字。对于小数点后面的位数超过允许范围的值，MySQL 会自动将它四舍五入为最接近它的值，再插入它。
  DECIMAL 数据类型用于精度要求非常高的计算中，这种类型允许指定数值的精度和计数方法作为选择参数。精度在这里指为这个值保存的有效数字的总个数，而计数方法表示小数点后数字的位数。比如语句 DECIMAL(7,3) 规定了存储的值不会超过 7 位数字，并且小数点后不超过 3 位。
  FLOAT 类型在长度比较高比如 float(10,2)和 decimal(10,2)同时插入一个符合(10,2)宽度的数值,float 就会出现最后小数点出现一些出入;
  UNSIGNED 和 ZEROFILL 修饰符也可以被 FLOAT、DOUBLE 和 DECIMAL 数据类型使用。并且效果与 INT 数据类型相同。

> 关于flaot和double
> 在这里我建议,干脆忘记mysql有double这个数据类型。至于why？就不要管它了

#### 字符串类型

MySQL 提供了 8 个基本的字符串类型，可以存储的范围从简单的一个字符到巨大的文本块或二进制字符串数据。
![191316571971301.png](https://images0.cnblogs.com/blog2015/487276/201505/191316571971301.png)

- BINARY
  BINARY不是函数，是类型转换运算符，它用来强制它后面的字符串为一个二进制字符串，可以理解为在字符串比较的时候区分大小写

```sql
SELECT BINARY 'ABCD' = 'abcd' as COM1,'ABCD' = 'abcd' as COM2; -- COM1输出为0,COM2输出为1;
```

- CHAR 和 VARCHAR 类型
  CHAR 类型用于定长字符串，并且必须在圆括号内用一个大小修饰符来定义。这个大小修饰符的范围从 0-255。**比指定长度大的值将被截短，而比指定长度小的值将会用空格作填补**。
  CHAR 类型可以使用 BINARY 修饰符。当用于比较运算时，这个修饰符使 CHAR 以二进制方式参于运算，而不是以传统的区分大小写的方式。
  CHAR 类型的一个变体是 VARCHAR 类型。它是一种可变长度的字符串类型，并且也必须带有一个范围在 0-255 之间的指示器。
  CHAR 和 VARCHGAR 不同之处在于 MYSQL 数据库处理这个指示器的方式：CHAR 把这个大小视为值的大小，不长度不足的情况下就用空格补足。而 VARCHAR 类型把它视为最大值并且只使用存储字符串实际需要的长度（增加一个额外字节来存储字符串本身的长度）来存储值。所以短于指示器长度的 VARCHAR 类型不会被空格填补，但长于指示器的值仍然会被截短。
  因为 VARCHAR 类型可以根据实际内容动态改变存储值的长度，所以在不能确定字段需要多少字符时使用 VARCHAR 类型可以大大地节约磁盘空间、提高存储效率。**但如果确切知道字符串长度,比如就在50~55之间,那就用 CHAR 因为 CHAR 类型由于本身定长的特性使其性能要高于 VARCHAR**;
  VARCHAR 类型在使用 BINARY 修饰符时与 CHAR 类型完全相同。
- TEXT 和 BLOB 类型
  对于字段长度要求超过 255 个的情况下，MySQL 提供了 TEXT 和 BLOB 两种类型。根据存储数据的大小，它们都有不同的子类型。这些大型的数据用于存储文本块或图像、声音文件等二进制数据类型。
  TEXT 和 BLOB 类型在分类和比较上存在区别。BLOB 类型区分大小写，而 TEXT 不区分大小写。大小修饰符不用于各种 BLOB 和 TEXT 子类型。比指定类型支持的最大范围大的值将被自动截短。

#### 时间类型

在处理日期和时间类型的值时，MySQL 带有 5 个不同的数据类型可供选择。
![191330344949224.png](https://images0.cnblogs.com/blog2015/487276/201505/191330344949224.png)

- DATE、TIME 和 YEAR 类型
  MySQL 用 DATE 和 YEAR 类型存储简单的日期值，使用 TIME 类型存储时间值。这些类型可以描述为字符串或不带分隔符的整数序列。如果描述为字符串，DATE 类型的值应该使用连字号作为分隔符分开，而 TIME 类型的值应该使用冒号作为分隔符分开。
  **需要注意的是，没有冒号分隔符的 TIME 类型值，将会被 MySQL 理解为持续的时间，而不是时间戳。**
  MySQL 还对日期的年份中的两个数字的值，或是 SQL 语句中为 YEAR 类型输入的两个数字进行最大限度的通译。因为所有 YEAR 类型的值必须用 4 个数字存储。MySQL 试图将 2 个数字的年份转换为 4 个数字的值。把在 00-69 范围内的值转换到 2000-2069 范围内。把 70-99 范围内的值转换到 1970-1979 之内。如果 MySQL 自动转换后的值并不符合我们的需要，请输入 4 个数字表示的年份。
- DATETIME 和 TIMESTAMP 类型
  除了日期和时间数据类型，MySQL 还支持 DATETIME 和 TIMESTAMP 这两种混合类型。它们可以把日期和时间作为单个的值进行存储。这两种类型通常用于自动存储包含当前日期和时间的时间戳，并可在需要执行大量数据库事务和需要建立一个调试和审查用途的审计跟踪的应用程序中发挥良好作用。

> 如果我们对 TIMESTAMP 类型的字段没有明确赋值，或是被赋与了 null 值。MySQL 会自动使用系统当前的日期和时间来填充它。

#### 复合类型

MySQL 还支持两种复合数据类型 ENUM 和 SET，它们扩展了 SQL 规范。虽然这些类型在技术上是字符串类型，但是可以被视为不同的数据类型。一个 ENUM 类型只允许从一个集合中取得一个值；而 SET 类型允许从一个集合中取得任意多个值。

- ENUM 类型
  ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。ENUM 类型字段可以从集合中取得一个值或使用 null 值，除此之外的输入将会使 MySQL 在这个字段中插入一个空字符串。另外如果插入值的大小写与集合中值的大小写不匹配，MySQL 会自动使用插入值的大小写转换成与集合中大小写一致的值。
  ENUM 类型在系统内部可以存储为数字，并且从 1 开始用数字做索引。一个 ENUM 类型最多可以包含 65536 个元素，其中一个元素被 MySQL 保留，用来存储错误信息，这个错误值用索引 0 或者一个空字符串表示。
  MySQL 认为 ENUM 类型集合中出现的值是合法输入，除此之外其它任何输入都将失败。这说明通过搜索包含空字符串或对应数字索引为 0 的行就可以很容易地找到错误记录的位置。
- SET 类型
  SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。并且与 ENUM 类型相同的是任何试图在 SET 类型字段中插入非预定义的值都会使 MySQL 插入一个空字符串。**如果插入一个即有合法的元素又有非法的元素的记录，MySQL 将会保留合法的元素，除去非法的元素。**
  一个 SET 类型最多可以包含 64 项元素。还去除了重复的元素，所以 SET 类型中不可能包含两个相同的元素。
  希望从 SET 类型字段中找出非法的记录只需查找包含空字符串或二进制值为 0 的行。

#### 字段类型总结

1. 虽然上面列出了很多字段类型,但最常用也就是 varchar(255),char(255),text,tinyint(4),smallint(6),mediumint,int(11)几种。
2. 复合类型我们一般用tinyint,更快的时间更省的空间以及更容易扩展
3. 关于手机号，推荐用char(11),char(11)在查询上更有效率，因为手机号是一个活跃字段参与逻辑会很多。
4. 一些常用字段举例
   姓名：char(20)
   价格：DECIMAL(7, 3)
   产品序列号：SMALLINT(5) unsigned
   文章内容: TEXT
   MD5: CHAR(32)
   ip: char(15)
   time: int(10)
   email char(32)

#### 合理的选择数据类型

- 选择合理范围内最小的
  我们应该选择最小的数据范围，因为这样可以大大减少磁盘空间及磁盘I/0读写开销，减少内存占用，减少CPU的占用率。
- 选择相对简单的数据类型
  数字类型相对字符串类型要简单的多，尤其是在比较运算时，所以我们应该选择最简单的数据类型，*比如说在保存时间时，因为PHP可以良好的处理LINUX时间戳所以我们可以将日期存为int(10)要方便、合适、快速的多*。

> 但是，工作中随着项目越做越多，业务逻辑的处理越来越难以后，我发现时间类型还是用时间类型本身的字段类型要好一些，因为mysql有着丰富的时间函数供我使用，方便我完成很多与时间相关的逻辑，比如月排行榜，周排行榜，当日热门，生日多少天等等逻辑

- 不要使用null
  为什么这么说呢，因为MYSQL对NULL字段索引优化不佳，增加更多的计算难度，同时在保存与处理NULL类形时，也会做更多的工作，所以从效率上来说，不建议用过多的NULL。有些值他确实有可能没有值，怎么办呢？解决方法是数值弄用整数0，字符串用空来定义默认值即可。

- 字符串类型的使用
  字符串数据类型是一个万能数据类型，可以储存数值、字符串、日期等。
  保存数值类型最好不要用字符串数据类型，这样存储的空间显然是会更大，而且在排序时字符串的9是大于22的，其实如果进行运算时mysql会将字符串转换为数值类型，大大降低效果，而且这种转换是不会走原有的索引的。
  如果明确数据在一个完整的集合中如男，女，那么可以使用set或enum数据类型，这种数据类型在运算及储存时以数值方式操作，所以效率要比字符串更好，同时空间占用更少。

- VARCHAR与CHAR

  - VARCHAR是可变长度字符串类型，那么即然长度是可变的就会使用1，2个字节来保存字符的长度，如果长度在255内使用1个字节来保存字符长度，否则使用2个字符来保存长度。由于varchar是根据储存的值来保存数据，所以可以大大节约磁盘空间。
    如果数据经常被执行更新操作，由于VARCHAR是根据内容来进行储存的，所以mysql将做更多的工作来完成更新操作，如果新数据长度大于老数据长度一些存储引擎会进行拆分操作处理。同时varchar会完全保留内部所有数据，最典型的说明就是尾部的空格。
  - CHAR固定长度的字符串保存类型，CHAR会去掉尾部的空格。在数据长度相近时使用char类型比较合适，比如md5加密的密码用户名等。
    如果数据经常进行更新修改操作，那么CHAR更好些，因为char长度固定，性能上要快。

- 数值类型的选择

  数值数据类型要比字符串执行更快，区间小的数据类型占用空间更少，处理速度更快，如tinyint可比bigint要快的多

  选择数据类型时要考虑内容长度，比如是保存毫米单位还是米而选择不同的数值类型

  - 整数
    整数类型很多比如tinyint、int、smallint、bigint等，那么我们要根据自己需要存储的数据长度决定使用的类型，同时tinyint(10)与tinyint(100)在储存与计算上并无任何差别，区别只是显示层面上，但是我们也要选择适合合适的数据类型长度。可以通过指定zerofill属性查看显示时区别。
  - 浮点数与精度数值
    浮点数float在储存空间及运行效率上要优于精度数值类型decimal，但float与double会有舍入错误而decimal则可以提供更加准确的小数级精确运算不会有错误产生计算更精确，适用于金融类型数据的存储。



### 五、常见数据库操作



![image-20210408140542458](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210408140545174.png)

#### 5.1 **修改字段属性：**



```sql
-- 修改字段属性
-- ALTER TABLE tb_name MODIFY 字段名称 字段类型 [完整性约束条件]
-- 将email字段 VARCHAR(50)修改成VARCHAR(200)
-- 注意，修改时如果不带完整性约束条件，原有的约束条件将丢失，如果想保留修改时就得带上完整性约束条件
ALTER TABLE user10 MODIFY email VARCHAR(200) NOT NULL DEFAULT 'a@a.com';

-- 将card移到test后面
ALTER TABLE user10 MODIFY card CHAR(10) AFTER test;

-- 将test放到第一个，保留原完整性约束条件
ALTER TABLE user10 MODIFY test CHAR(32) NOT NULL DEFAULT '123' FIRST;


mysql修改字段类型：	 
--能修改字段类型、类型长度、默认值、注释
--对某字段进行修改
ALTER  TABLE 表名 MODIFY [COLUMN] 字段名 新数据类型 新类型长度  新默认值  新注释;
 -- COLUMN关键字可以省略不写
 
alter  table table1 modify  column column1  decimal(10,1) DEFAULT NULL COMMENT '注释'; -- 正常，能修改字段类型、类型长度、默认值、注释
 
alter  table table1 modify column1  decimal(10,2) DEFAULT NULL COMMENT '注释'; 
-- 正常，能修改字段类型、类型长度、默认值、注释
 
mysql修改字段名：
ALTER  TABLE 表名 CHANGE [column] 旧字段名 新字段名 新数据类型;	 
alter  table table1 change column1 column1 varchar(100) DEFAULT 1.2 COMMENT '注释'; -- 正常，此时字段名称没有改变，能修改字段类型、类型长度、默认值、注释
alter  table table1 change column1 column2 decimal(10,1) DEFAULT NULL COMMENT '注释' -- 正常，能修改字段名、字段类型、类型长度、默认值、注释
alter  table table1 change column2 column1 decimal(10,1) DEFAULT NULL COMMENT '注释' -- 正常，能修改字段名、字段类型、类型长度、默认值、注释
alter  table table1 change column1 column2; -- 报错 
 
mysql> alter table white_user change column name nick_name  varchar(50) null comment '昵称'; -- 正确
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0
 
```

##### 5.1.1 在指定位置插入新字段

```sql
ALTER TABLE 表名 ADD [COLUMN] 字段名 字段类型 是否可为空 COMMENT '注释' AFTER 指定某字段 ;
--COLUMN关键字可以省略不写
 
mysql> alter table white_user_new add column erp varchar(50) not null comment 'erp账号' after name ;
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0
--在name字段后面添加erp字段
 
mysql> show create table white_user_new ;
CREATE TABLE `white_user_new` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(50) NOT NULL COMMENT '姓名',
  `erp` varchar(50) NOT NULL COMMENT 'erp账号', 
  `created_time` datetime DEFAULT NULL COMMENT '创建时间',
  `updated_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COMMENT='新表-白名单表'      
 
 
 
 
mysql> alter table white_user_new add position varchar(50) not null comment '岗位' after name ;
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0
--在name字段后面添加position字段。
 
mysql> show create table white_user_new ;                                      
CREATE TABLE `white_user_new` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(50) NOT NULL COMMENT '姓名',
  `position` varchar(50) NOT NULL COMMENT '岗位',
  `erp` varchar(50) NOT NULL COMMENT 'erp账号',
  `created_time` datetime DEFAULT NULL COMMENT '创建时间',
  `updated_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COMMENT='新表-白名单表'      
 
 
 
mysql> alter table white_user_new add  mobile varchar(50) not null comment '手机号码' before position ;
--报错，在position字段前添加mobile字段，不能使用before关键字
```

##### 5.1.2 删除字段

```sql
ALTER TABLE 表名 DROP [COLUMN] 字段名 ;
--COLUMN关键字可以省略不写
 
mysql> alter table white_user_new drop column position ;
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0
 
mysql> alter table white_user_new drop erp ;
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0
 
mysql> show create table white_user_new ;                                      
CREATE TABLE `white_user_new` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(50) NOT NULL COMMENT '姓名',
  `created_time` datetime DEFAULT NULL COMMENT '创建时间',
  `updated_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COMMENT='新表-白名单表'      
 
 
 
```



#### 5.2 **修改字段名称和属性：**

```sql
-- 将test字段改为test1
-- ALTER TABLE 表名 CHANGE 原字段名 新字段名 字段类型 约束条件
ALTER TABLE user10 CHANGE test test1 CHAR(32) NOT NULL DEFAULT '123';
```

#### 5.3 **添加删除默认值：**

```sql
-- 创建新表
CREATE TABLE user11(
id TINYINT UNSIGNED KEY AUTO_INCREMENT,
username VARCHAR(20) NOT NULL UNIQUE,
age TINYINT UNSIGNED
);

-- 给age添加默认值
ALTER TABLE user11 ALTER age SET DEFAUTL 18;
-- 添加一个字段
ALTER TABLE user11 ADD email VARCHAR(50);
-- 给email添加默认值
ALTER TABLE user11 ALTER email SET DEFAULT 'a@a.com';

-- 删除默认值
ALTER TABLE user11 ALTER age DROP DEFAULT;
ALTER TABLE user11 ALTER email DROP DEFAULT;
```

#### 5.4  **添加主键：**

```sql
-- 创建一个表
CREATE TABLE test12(
id INT
);
-- 添加主键
-- ALTER TABLE tb_name ADD [CONSTRAINT [sysmbol]] PRIMARY KEY [index_type] (字段名称,...)
ALTER TABLE test12 ADD PRIMARY KEY(id);


-- 添加复合主键
-- 先创建个表
CREATE TABLE test13(
id INT,
card CHAR(18),
username VARCHAR(20) NOT NULL
);
-- 添加复合主键
ALTER TABLE test13 ADD PRIMARY KEY(id,card);
```

#### 5.5 **删除主键：**

```sql
-- 删除主键
ALTER TABLE test12 DROP PRIMARY KEY;

-- 再给test12添加主键, 完整形式
ALTER TABLE test12 ADD CONSTRAINT symbol PRIMARY KEY index_type(id);
```

在删除主键时，有一种情况是需要注意的，我们知道具有自增长的属性的字段必须是主键，如果表里的主键是具有自增长属性的；那么直接删除是会报错的。如果想要删除主键的话，可以先去年自增长属性，再删除主键

```sql
-- 再创建一个表，
CREATE TABLE test14(
id INT UNSIGNED KEY AUTO_INCREMENT
);

-- 删除主键，这样会报错，因为自增长的必须是主键
ALTER TABLE test14 DROP PRIMARY KEY;

-- 先用MODIFY删除自增长属性，注意MODIFY不能去掉主键属性
ALTER TABLE test14 MODIFY id INT UNSIGNED;
-- 再来删除主键
ALTER TABLE test14 DROP PRIMARY KEY;
```



#### 5.6 **唯一索引：**

```sql
-- 添加唯一性约束
-- ALTER TABLE tb_name ADD [CONSTANT [symbol]] UNIQUE [INDEX | KEY] [索引名称](字段名称,...)

-- 创建测试表
CREATE TABLE user12(
id TINYINT UNSIGNED KEY AUTO_INCREMENT,
username VARCHAR(20) NOT NULL,
card CHAR(18) NOT NULL,
test VARCHAR(20) NOT NULL,
test1 CHAR(32) NOT NULL
);

-- username添加唯一性约束，如果没有指定索引名称，系统会以字段名建立索引
ALTER TABLE user12 ADD UNIQUE(username);
-- car添加唯一性约束
ALTER TABLE user12 ADD CONSTRAINT symbol UNIQUE KEY uni_card(card);
-- 查看索引
SHOW CREATE TABLE user12;

-- test,test1添加联合unique
ALTER TABLE user12 ADD CONSTRAINT symbol UNIQUE INDEX mulUni_test_test1(test, test1);

-- 删除唯一
-- ALTER TABLE tb_name DROP {INDEX|KEY} index_name;
-- 删除刚刚添加的唯一索引
ALTER TABLE user12 DROP INDEX username;
ALTER TABLE user12 DROP KEY uni_card;
ALTER TABLE user12 DROP KEY mulUni_test_test1;
```



#### 5.7 **修改表的存储引擎：**

```sql
-- 修改表的存储引擎
-- ALTER TABLE tb_name ENGINE=存储引擎名称
ALTER TABLE user12 ENGINE=MyISAM;
ALTER TABLE user12 ENGINE=INNODB;
```

#### 5.8 **修改自增长值：**

```sql
-- 修改自增长的值
-- ALTER TABLE tb_name AUTO_INCREMENT=值
ALTER TABLE user12 AUTO_INCREMENT=100;
```

#### 5.9 修改表名

```sql
ALTER TABLE 旧表名 RENAME TO 新表名 ;
 
mysql> show tables ;
+-------------------+
| Tables_in_db_test |
+-------------------+
| white_user   |
+-------------------+
1 row in set (0.00 sec)
 
 
 
mysql> alter table white_user rename to white_user_new ;
Query OK, 0 rows affected (0.00 sec)
 
mysql> show tables ;
+-------------------+
| Tables_in_db_test |
+-------------------+
| white_user_new    |
+-------------------+
1 row in set (0.00 sec)
```

#### 5.10 修改表的注释

```java
ALTER TABLE 表名 COMMENT '新注释'
 
mysql> alter table  white_user_new comment '新表-白名单表' ;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0
 
mysql> show create table white_user_new ;
 CREATE TABLE `white_user_new` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(50) NOT NULL COMMENT '姓名',
  `created_time` datetime DEFAULT NULL COMMENT '创建时间',
  `updated_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COMMENT='新表-白名单表' 
 
 
```

#### 5.11 复制表结构和数据



![image-20210521141539594](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210521141544.png)





### 六、常用CRUD语句











## Maven

## **pom.xml详解**

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd">
    <!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。-->
    <parent>
        <!--被继承的父项目的构件标识符-->
        <artifactId/>
        <!--被继承的父项目的全球唯一标识符-->
        <groupId/>
        <!--被继承的父项目的版本-->
        <version/>
        <!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 目的pom，
其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。-->
        <relativePath/>
    </parent>
    <!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。-->
    <modelVersion>4.0.0</modelVersion>
    <!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app-->
    <groupId>cn.erhuowang</groupId>
    <!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，
artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。-->
    <artifactId>erhuowang-maven2</artifactId>
    <!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型-->
    <packaging>war</packaging>
    <!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号-->
    <version>1.0-SNAPSHOT</version>
    <!--项目的名称, Maven产生的文档用-->
    <name>erhuo-maven</name>
    <!--项目主页的URL, Maven产生的文档用-->
    <url>http://erhuowang.cn</url>
    <!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 
不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。-->
    <description>A maven project to study maven.</description>
    <!--描述了这个项目构建环境中的前提条件。-->
    <prerequisites>
        <!--构建该项目或使用该插件所需要的Maven的最低版本-->
        <maven/>
    </prerequisites>
    <!--项目名称和URL-->
    <issueManagement>
        <!--项目名字，-->
        <system>erhuowang</system>
        <!--该项目使用的URL-->
        <url>http://erhuowang.cn</url>
    </issueManagement>
    <!--项目持续集成信息-->
    <ciManagement>
        <!--持续集成系统的名字，例如continuum-->
        <system/>
        <!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。-->
        <url/>
        <!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）-->
        <notifiers>
            <!--配置一种方式，当构建中断时，以该方式通知用户/开发者-->
            <notifier>
                <!--传送通知的途径-->
                <type/>
                <!--发生错误时是否通知-->
                <sendOnError/>
                <!--构建失败时是否通知-->
                <sendOnFailure/>
                <!--构建成功时是否通知-->
                <sendOnSuccess/>
                <!--发生警告时是否通知-->
                <sendOnWarning/>
                <!--不赞成使用。通知发送到哪里-->
                <address/>
                <!--扩展配置项-->
                <configuration/>
            </notifier>
        </notifiers>
    </ciManagement>
    <!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。-->
    <inceptionYear/>
    <!--项目相关邮件列表信息-->
    <mailingLists>
        <!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。-->
        <mailingList>
            <!--邮件的名称-->
            <name>Demo</name>
            <!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建-->
            <post>chaibozhou@163.com</post>
            <!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建-->
            <subscribe>chaibozhou@163.com</subscribe>
            <!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建-->
            <unsubscribe>chaibozhou@163.com</unsubscribe>
            <!--你可以浏览邮件信息的URL-->
            <archive>chaibozhou@163.com</archive>
        </mailingList>
    </mailingLists>
    <!--项目开发者列表-->
    <developers>
        <!--某个项目开发者的信息-->
        <developer>
            <!--SCM里项目开发者的唯一标识符-->
            <id>HELLO WORLD</id>
            <!--项目开发者的全名-->
            <name>chaimm</name>
            <!--项目开发者的email-->
            <email>chaibozhou@163.com</email>
            <!--项目开发者的主页的URL-->
            <url/>
            <!--项目开发者在项目中扮演的角色，角色元素描述了各种角色-->
            <roles>
                <role>Project Manager</role>
                <role>Architect</role>
            </roles>
            <!--项目开发者所属组织-->
            <organization>demo</organization>
            <!--项目开发者所属组织的URL-->
            <organizationUrl>http://erhuowang.cn</organizationUrl>
            <!--项目开发者属性，如即时消息如何处理等-->
            <properties>
                <dept>No</dept>
            </properties>
            <!--项目开发者所在时区， -11到12范围内的整数。-->
            <timezone>-5</timezone>
        </developer>
    </developers>
    <!--项目的其他贡献者列表-->
    <contributors>
        <!--项目的其他贡献者。参见developers/developer元素-->
        <contributor>
            <name/><email/><url/><organization/><organizationUrl/><roles/><timezone/><properties/>
        </contributor>
    </contributors>
    <!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。-->
    <licenses>
        <!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。-->
        <license>
            <!--license用于法律上的名称-->
            <name>Apache 2</name>
            <!--官方的license正文页面的URL-->
            <url>http://www.baidu.com/erhuwoang/LICENSE-2.0.txt</url>
            <!--项目分发的主要方式：
            repo，可以从Maven库下载
            manual， 用户必须手动下载和安装依赖-->
            <distribution>repo</distribution>
            <!--关于license的补充信息-->
            <comments>A business-friendly OSS license</comments>
        </license>
    </licenses>
    <!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。-->
    <scm>
        <!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。-->
        <connection>
            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)
        </connection>
        <!--给开发者使用的，类似connection元素。即该连接不仅仅只读-->
        <developerConnection>
            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk
        </developerConnection>
        <!--当前代码的标签，在开发阶段默认为HEAD-->
        <tag/>
        <!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。-->
        <url>http://svn.baidu.com/banseon</url>
    </scm>
    <!--描述项目所属组织的各种属性。Maven产生的文档用-->
    <organization>
        <!--组织的全名-->
        <name>demo</name>
        <!--组织主页的URL-->
        <url>http://www.erhuowang.cn</url>
    </organization>
    <!--构建项目需要的信息-->
    <build>
        <!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。-->
        <sourceDirectory/>
        <!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。-->
        <scriptSourceDirectory/>
        <!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。-->
        <testSourceDirectory/>
        <!--被编译过的应用程序class文件存放的目录。-->
        <outputDirectory/>
        <!--被编译过的测试class文件存放的目录。-->
        <testOutputDirectory/>
        <!--使用来自该项目的一系列构建扩展-->
        <extensions>
            <!--描述使用到的构建扩展。-->
            <extension>
                <!--构建扩展的groupId-->
                <groupId/>
                <!--构建扩展的artifactId-->
                <artifactId/>
                <!--构建扩展的版本-->
                <version/>
            </extension>
        </extensions>
        <!--当项目没有规定目标（Maven2 叫做阶段）时的默认值-->
        <defaultGoal/>
        <!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。-->
        <resources>
            <!--这个元素描述了项目相关或测试相关的所有资源路径-->
            <resource>
                <!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。
举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。-->
                <targetPath/>
                <!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。-->
                <filtering/>
                <!--描述存放资源的目录，该路径相对POM路径-->
                <directory/>
                <!--包含的模式列表，例如**/*.xml.-->
                <includes/>
                <!--排除的模式列表，例如**/*.xml-->
                <excludes/>
            </resource>
        </resources>
        <!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。-->
        <testResources>
            <!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明-->
            <testResource>
                <targetPath/><filtering/><directory/><includes/><excludes/>
            </testResource>
        </testResources>
        <!--构建产生的所有文件存放的目录-->
        <directory/>
        <!--产生的构件的文件名，默认值是${artifactId}-${version}。-->
        <finalName/>
        <!--当filtering开关打开时，使用到的过滤器属性文件列表-->
        <filters/>
        <!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置-->
        <pluginManagement>
            <!--使用的插件列表 。-->
            <plugins>
                <!--plugin元素包含描述插件所需要的信息。-->
                <plugin>
                    <!--插件在仓库里的group ID-->
                    <groupId/>
                    <!--插件在仓库里的artifact ID-->
                    <artifactId/>
                    <!--被使用的插件的版本（或版本范围）-->
                    <version/>
                    <!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。-->
                    <extensions/>
                    <!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。-->
                    <executions>
                        <!--execution元素包含了插件执行需要的信息-->
                        <execution>
                            <!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标-->
                            <id/>
                            <!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段-->
                            <phase/>
                            <!--配置的执行目标-->
                            <goals/>
                            <!--配置是否被传播到子POM-->
                            <inherited/>
                            <!--作为DOM对象的配置-->
                            <configuration/>
                        </execution>
                    </executions>
                    <!--项目引入插件所需要的额外依赖-->
                    <dependencies>
                        <!--参见dependencies/dependency元素-->
                        <dependency>
                            ......
                        </dependency>
                    </dependencies>
                    <!--任何配置是否被传播到子项目-->
                    <inherited/>
                    <!--作为DOM对象的配置-->
                    <configuration/>
                </plugin>
            </plugins>
        </pluginManagement>
        <!--使用的插件列表-->
        <plugins>
            <!--参见build/pluginManagement/plugins/plugin元素-->
            <plugin>
                <groupId/><artifactId/><version/><extensions/>
                <executions>
                    <execution>
                        <id/><phase/><goals/><inherited/><configuration/>
                    </execution>
                </executions>
                <dependencies>
                    <!--参见dependencies/dependency元素-->
                    <dependency>
                        ......
                    </dependency>
                </dependencies>
                <goals/><inherited/><configuration/>
            </plugin>
        </plugins>
    </build>
    <!--在列的项目构建profile，如果被激活，会修改构建处理-->
    <profiles>
        <!--根据环境参数或命令行参数激活某个构建处理-->
        <profile>
            <!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。-->
            <id/>
            <!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它
            能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。-->
            <activation>
                <!--profile默认是否激活的标志-->
                <activeByDefault/>
                <!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。-->
                <jdk/>
                <!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。-->
                <os>
                    <!--激活profile的操作系统的名字-->
                    <name>Windows XP</name>
                    <!--激活profile的操作系统所属家族(如 'windows')-->
                    <family>Windows</family>
                    <!--激活profile的操作系统体系结构 -->
                    <arch>x86</arch>
                    <!--激活profile的操作系统版本-->
                    <version>5.1.2600</version>
                </os>
                <!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值
                字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段-->
                <property>
                    <!--激活profile的属性的名称-->
                    <name>mavenVersion</name>
                    <!--激活profile的属性的值-->
                    <value>2.0.3</value>
                </property>
                <!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活
                profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。-->
                <file>
                    <!--如果指定的文件存在，则激活profile。-->
                    <exists>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</exists>
                    <!--如果指定的文件不存在，则激活profile。-->
                    <missing>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</missing>
                </file>
            </activation>
            <!--构建项目所需要的信息。参见build元素-->
            <build>
                <defaultGoal/>
                <resources>
                    <resource>
                        <targetPath/><filtering/><directory/><includes/><excludes/>
                    </resource>
                </resources>
                <testResources>
                    <testResource>
                        <targetPath/><filtering/><directory/><includes/><excludes/>
                    </testResource>
                </testResources>
                <directory/><finalName/><filters/>
                <pluginManagement>
                    <plugins>
                        <!--参见build/pluginManagement/plugins/plugin元素-->
                        <plugin>
                            <groupId/><artifactId/><version/><extensions/>
                            <executions>
                                <execution>
                                    <id/><phase/><goals/><inherited/><configuration/>
                                </execution>
                            </executions>
                            <dependencies>
                                <!--参见dependencies/dependency元素-->
                                <dependency>
                                    ......
                                </dependency>
                            </dependencies>
                            <goals/><inherited/><configuration/>
                        </plugin>
                    </plugins>
                </pluginManagement>
                <plugins>
                    <!--参见build/pluginManagement/plugins/plugin元素-->
                    <plugin>
                        <groupId/><artifactId/><version/><extensions/>
                        <executions>
                            <execution>
                                <id/><phase/><goals/><inherited/><configuration/>
                            </execution>
                        </executions>
                        <dependencies>
                            <!--参见dependencies/dependency元素-->
                            <dependency>
                                ......
                            </dependency>
                        </dependencies>
                        <goals/><inherited/><configuration/>
                    </plugin>
                </plugins>
            </build>
            <!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径-->
            <modules/>
            <!--发现依赖和扩展的远程仓库列表。-->
            <repositories>
                <!--参见repositories/repository元素-->
                <repository>
                    <releases>
                        <enabled/><updatePolicy/><checksumPolicy/>
                    </releases>
                    <snapshots>
                        <enabled/><updatePolicy/><checksumPolicy/>
                    </snapshots>
                    <id/><name/><url/><layout/>
                </repository>
            </repositories>
            <!--发现插件的远程仓库列表，这些插件用于构建和报表-->
            <pluginRepositories>
                <!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素-->
                <pluginRepository>
                    <releases>
                        <enabled/><updatePolicy/><checksumPolicy/>
                    </releases>
                    <snapshots>
                        <enabled/><updatePolicy/><checksumPolicy/>
                    </snapshots>
                    <id/><name/><url/><layout/>
                </pluginRepository>
            </pluginRepositories>
            <!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。-->
            <dependencies>
                <!--参见dependencies/dependency元素-->
                <dependency>
                    ......
                </dependency>
            </dependencies>
            <!--不赞成使用. 现在Maven忽略该元素.-->
            <reports/>
            <!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素-->
            <reporting>
                ......
            </reporting>
            <!--参见dependencyManagement元素-->
            <dependencyManagement>
                <dependencies>
                    <!--参见dependencies/dependency元素-->
                    <dependency>
                        ......
                    </dependency>
                </dependencies>
            </dependencyManagement>
            <!--参见distributionManagement元素-->
            <distributionManagement>
                ......
            </distributionManagement>
            <!--参见properties元素-->
            <properties/>
        </profile>
    </profiles>
    <!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径-->
    <modules/>
    <!--发现依赖和扩展的远程仓库列表。-->
    <repositories>
        <!--包含需要连接到远程仓库的信息-->
        <repository>
            <!--如何处理远程仓库里发布版本的下载-->
            <releases>
                <!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 -->
                <enabled/>
                <!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），
interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。-->
                <updatePolicy/>
                <!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。-->
                <checksumPolicy/>
            </releases>
            <!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。
例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 -->
            <snapshots>
                <enabled/><updatePolicy/><checksumPolicy/>
            </snapshots>
            <!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库-->
            <id>banseon-repository-proxy</id>
            <!--远程仓库名称-->
            <name>banseon-repository-proxy</name>
            <!--远程仓库URL，按protocol://hostname/path形式-->
            <url>http://192.168.1.169:9999/repository/</url>
            <!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。
我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。-->
            <layout>default</layout>
        </repository>
    </repositories>
    <!--发现插件的远程仓库列表，这些插件用于构建和报表-->
    <pluginRepositories>
        <!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素-->
        <pluginRepository>
            ......
        </pluginRepository>
    </pluginRepositories>

    <!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。-->
    <dependencies>
        <dependency>
            <!--依赖的group ID-->
            <groupId>org.apache.maven</groupId>
            <!--依赖的artifact ID-->
            <artifactId>maven-artifact</artifactId>
            <!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。-->
            <version>3.8.1</version>
            <!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 
尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。-->
            <type>jar</type>
            <!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，
一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。-->
            <classifier></classifier>
            <!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。
            - compile ：默认范围，用于编译
            - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath
            - runtime: 在执行时需要使用
            - test: 用于test任务时使用
            - system: 需要外在提供相应的元素。通过systemPath来取得
            - systemPath: 仅用于范围为system。提供相应的路径
            - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用-->
            <scope>test</scope>
            <!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。
推荐使用属性匹配绝对路径，例如${java.home}。-->
            <systemPath></systemPath>
            <!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题-->
            <exclusions>
                <exclusion>
                    <artifactId>spring-core</artifactId>
                    <groupId>org.springframework</groupId>
                </exclusion>
            </exclusions>
            <!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。-->
            <optional>true</optional>
        </dependency>
    </dependencies>
    <!--不赞成使用. 现在Maven忽略该元素.-->
    <reports></reports>
    <!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。-->
    <reporting>
        <!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。-->
        <excludeDefaults/>
        <!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。-->
        <outputDirectory/>
        <!--使用的报表插件和他们的配置。-->
        <plugins>
            <!--plugin元素包含描述报表插件需要的信息-->
            <plugin>
                <!--报表插件在仓库里的group ID-->
                <groupId/>
                <!--报表插件在仓库里的artifact ID-->
                <artifactId/>
                <!--被使用的报表插件的版本（或版本范围）-->
                <version/>
                <!--任何配置是否被传播到子项目-->
                <inherited/>
                <!--报表插件的配置-->
                <configuration/>
                <!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。
1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标-->
                <reportSets>
                    <!--表示报表的一个集合，以及产生该集合的配置-->
                    <reportSet>
                        <!--报表集合的唯一标识符，POM继承时用到-->
                        <id/>
                        <!--产生报表集合时，被使用的报表的配置-->
                        <configuration/>
                        <!--配置是否被继承到子POMs-->
                        <inherited/>
                        <!--这个集合里使用到哪些报表-->
                        <reports/>
                    </reportSet>
                </reportSets>
            </plugin>
        </plugins>
    </reporting>
    <!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），
如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。-->
    <dependencyManagement>
        <dependencies>
            <!--参见dependencies/dependency元素-->
            <dependency>
                ......
            </dependency>
        </dependencies>
    </dependencyManagement>
    <!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。-->
    <distributionManagement>
        <!--部署项目产生的构件到远程仓库需要的信息-->
        <repository>
            <!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素-->
            <uniqueVersion/>
            <id>banseon-maven2</id>
            <name>banseon maven2</name>
            <url>file://${basedir}/target/deploy</url>
            <layout/>
        </repository>
        <!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素-->
        <snapshotRepository>
            <uniqueVersion/>
            <id>banseon-maven2</id>
            <name>Banseon-maven2 Snapshot Repository</name>
            <url>scp://svn.baidu.com/banseon:/usr/local/maven-snapshot</url>
            <layout/>
        </snapshotRepository>
        <!--部署项目的网站需要的信息-->
        <site>
            <!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置-->
            <id>banseon-site</id>
            <!--部署位置的名称-->
            <name>business api website</name>
            <!--部署位置的URL，按protocol://hostname/path形式-->
            <url>
                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web
            </url>
        </site>
        <!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。-->
        <downloadUrl/>
        <!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。-->
        <relocation>
            <!--构件新的group ID-->
            <groupId/>
            <!--构件新的artifact ID-->
            <artifactId/>
            <!--构件新的版本号-->
            <version/>
            <!--显示给用户的，关于移动的额外信息，例如原因。-->
            <message/>
        </relocation>
        <!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），
partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。-->
        <status/>
    </distributionManagement>
    <!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是<name>value</name>。-->
    <properties/>
</project>
```

## maven基础



#### 1 概述

> 在 Maven 的术语中，仓库是一个位置（place）。
> Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。
> 在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。
> Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。

------

#### 2 解读Jar在仓库中的存储路径

![img](https://img-blog.csdnimg.cn/20200915093132630.png)

> 1、基于 groupId 准备路径，将点分隔符转换成路径分隔符，就是将 “.” 转换成 “/”；例如：org.mybatis --> org/mybatis
>
> 2、基于 artifactId 准备路径，将 aftifactId 连接到 groupId 后面，org/mybatis/mybatis-spring
>
> 3、基于version 准备路径，将 version 连接到 artifactId 后面，org/mybatis/mybatis-spring/2.0.2
>
> 4、连接 artifactId 和 version 以分隔符分隔，org/mybatis/mybatis-spring/2.0.2/mybatis-spring-2.0.2
>
> 5、判断如果构件有 classifier，就要在第4项后增加分隔连字号 再加上 classifer，org/mybatis/mybatis-spring/2.0.2/mybatis-spring-2.0.2/mybatis-spring-2.0.2-jdk8
>
> 6、检查构件的 extension，如果 extension 存在，则加上句点分隔符和extension，而 extension 是由 packing 决定的，
> org/mybatis/mybatis-spring/2.0.2/mybatis-spring-2.0.2/mybatis-spring-2.0.2-jdk8.jar

**
TIPS**

classifier可以是任意的字符串，用于拼接在 gav 之后来确定指定的文件，可用来区分不同jdk版本生成的 jar包。当使用gav出错时，可以查看一下仓库中的jar路径，查看 jar 是否是按 jdk 版本进行划分导致找不到依赖，如果是，在pom中对应的依赖节点gav后添加 classifier 标签。

------

#### 3 maven仓库

**maven仓库类型**

![img](https://img-blog.csdnimg.cn/20200915184417525.png)

##### 3.1 本地仓库

顾名思义，存放在本地磁盘的maven仓库

maven 的本地仓库，在安装 maven 后并不会创建，是在第一次执行 maven 命令的时候才被创建

maven本地仓库默认位置：无论是 Windows 还是 Linux ，在用户的目录下都有一个 .m2/repository/的仓库目录，如何更改 maven 默认的本地仓库位置？在maven 的 settings.xml 文件中使用 <localRepository> 标签进行配置

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200915102537310.png#pic_center)

此时，maven 的本地仓库地址就会变成自己配置的地址，注：此时配置的 maven 的本地仓库是属于用户范围的。一般情况下不推荐全局范围的本地仓库，用户范围的本地仓库就可以了。

##### 3.2 远程仓库

###### 3.2.1 私服

私服是一种特殊的远程仓库，是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的 maven 用户使用。当 maven 需要下载构件的时候，会从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上后，再为 maven 的下载请求提供服务。

**maven私服特性**

> - 节省外网宽带，：减少重复请求造成的外网带宽消耗
> - 加速 maven 构件：如项目中配置很多外部远程仓库时，构建速度会大大降低
> - 部署第三方构件：有些构件无法从外部仓库获得时，可以把这些构件部署到内部仓库（私服）中，供内部 maven 项目使用
> - 提高稳定性，增强控制：Internet 不稳定时，maven 构建也会很不稳定
> - 降低中央仓库的负荷：maven 中央仓库被请求的数量是巨大的，配置私服可以大大降低中央仓库的压力

**主流的maven私服**

- Apache 的 Archiva
- JForg 的 Artifactory
- Sonatype 的 Nexus

###### 3.2.2 中央仓库

maven默认中央仓库：

- 默认maven中央仓库
- 默认maven中央仓库的搜索页面

中央仓库由maven社区管理，包含了大量常用的库，流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。

所有的 maven 项目都会继承`超级pom`，`超级pom`结构如下：

```xml
<repositories>  
    <repository>  
      <id>central</id>  
      <name>Central Repository</name>  
      <url>http://repo.maven.apache.org/maven2</url>  
      <layout>default</layout>  
      <snapshots>  
        <enabled>false</enabled>  
      </snapshots>  
    </repository>  
</repositories>
```

**特点：**

- 仓库由maven社区管理；

- 不需要配置

- 需要网络才能访问

- 国内下载速度慢

  

------

#### 4 远程仓库配置

由于默认的官方 maven 仓库在国内下载速度太慢，好在有一些镜像仓库，下载速度会快很多！在平时的开发中，我们往往不会使用默认的中央仓库，不仅是速度慢，可能项目的某些构件中央仓库是没有的，而其他远程仓库中有，如最常用的是 阿里云仓库。

```xml
<!-- 阿里云仓库 -->
<mirrors>
	<mirror>
	   <id>alimaven</id>
	   <mirrorOf>central</mirrorOf>
	   <name>aliyun maven</name>
	   <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>
	</mirror>
</mirrors>

<!-- 私服 -->
<mirrors>
	<mirror>
		<id>nexus</id>
		<mirrorOf>central</mirrorOf>
		<name>nexus repository</name>
		<url>http://nexus.dmsd.tech/nexus/content/groups/dynamic-public</url>
	</mirror> 
</mirrors>

<profile>
<id>central</id>
	<repositories>
		<repository>
			<id>central</id>
			<name>Central</name>
			<url>http://nexus.dmsd.tech/nexus/content/groups/dynamic-public </url>
		</repository>
	</repositories>
</profile> 
```

##### mirrors 与 respository

如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的一个镜像。换句话说，任何一个可以从仓库Y获得的构件，都能从它的镜像中获取。例如：

```xml
http://repo1.maven.org/maven2/  是中央仓库，
http://maven.oschina.net/content/groups/public/ 是其在中国的镜像，
由于地理位置的因素，该镜像往往能提供比中央仓库更快的服务。因此，可以配置 maven 使用该镜像来替代中央仓库。

<mirrors>
     <mirror>
       <id>maven.oschina.net</id>
       <name>maven mirror in China</name>
      <url>http://maven.oschina.net/content/groups/public/</url>
       <mirrorOf>central</mirrorOf>
    </mirror>
</mirrors>

其中，mirrorOf的值是 central，表示该配置为中央仓库的镜像，任何对于中央仓库的请求都会转至该镜像，
用户也可以使用同样的方法配置其他仓库的镜像，id 表示镜像的唯一标识符，name 表示镜像的名称，url 表示镜像的地址。


关于镜像的一个更为常见的用法是结合私服，由于私服可以代理任何外部的远程仓库（包括中央仓库），因此，对于组织内部的maven用户来说 
使用一个私服地址就等于使用了所有需要的外部仓库，这可以将配置集中到私服，从而简化maven本身的配置。在这种情况下，
任何需要的构件都可以从私服中获得，私服就是所有仓库的镜像，这时，可以这样配置：

<!--配置私服镜像-->
 <mirrors> 
     <mirror>  
         <id>nexus</id>  
         <name>internal nexus repository</name>  
         <url>http://183.238.2.182:8081/nexus/content/groups/public/</url>  
        <mirrorOf>*</mirrorOf>  
   </mirror>  
</mirrors>

该例中<mirrorOf>的值为星号，表示该配置是所有Maven仓库的镜像，任何对于远程仓库的请求都会被转至局域网的 url地址，如果该镜像
需要认证，则配置一个 id 为 nexus 的认证信息即可。

如果 repositories 的 id 和 mirror 的 mirrorOf 的值相同，则该mirror 替代该 repository.
如果该 repository 找不到对应的 mirror，则使用其本身，所以起到最终作用的是 repository 集合，repositories 中默认
包含了中央仓库 central，当然也可以重写URL

mirror相当于一个拦截器，它会拦截 maven 对 repository 的相关请求，把请求里的 remote repository 地址，重定向到
mirror 里配置的地址。
```

#### 5 maven依赖搜索顺序

maven 多仓库查询依赖的顺序大致如下：

1. 在本地仓库寻找，如果没有则进入下一步
2. 在全局配置的私服仓库 (settings.xml) 中寻找，如果没有则下一步
3. 在项目自身配置的私服仓库 (pom.xml) 中寻找，如没有则下一步
4. 在中央仓库中寻找，如果没有则终止寻找

![在这里插入图片描述](https://img-blog.csdnimg.cn/202009151750512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY1MzUyMg==,size_16,color_FFFFFF,t_70#pic_center)
注：

1、如果在找寻的过程中，如果发现该仓库有镜像设置，则用镜像的地址代替，例如现在进行到要在respository A仓库中查找某个依赖，但A仓库配置了mirror，则会转到从A的mirror中查找该依赖，不会再从A中查找。

2、settings.xml中配置的profile（激活的）下的respository优先级高于项目中pom文件配置的respository。

3、如果仓库的id设置成“central”，则该仓库会覆盖maven默认的中央仓库配置。





#### 6、修改本地仓库及镜像

![image-20210427200603280](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210427200603280.png)



```xml
  <mirrors>
    <mirror>
      <id>alimaven</id>
      <name>aliyun maven</name>
      <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
      <mirrorOf>central</mirrorOf>        
    </mirror>
  </mirrors>

```

#### 7、maven常用命令

```java
// 编译源代码
mvn compile
// 运行测试
mvn test
// 项目打包
mvn package
// 清除产生的项目
mvn clean
//项目打包时跳过测试
mvn package -Dmaven.test.skip=ture

```

![image-20210428114451284](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210428114451.png)

#### 8、maven坐标



```json
//定义当前 Maven 项目从属的实际项目，表述形式同 Java 包名的表述方式类似，通常与域名反向一一对应
groupId
//定义实际项目中的一个 Maven 项目（实际项目中的一个模块），表述形式为当前项目名
artifactId
//定义 Maven 当前所处的版本
version
//定义 Maven 项目的打包方式
packaging
//定义构件输出的附属构件
classifier
//依赖描述：
type: 依赖的类型
scope: 依赖的范围
optional: 标记依赖是否可选
exclusions: 用来排除传递性依赖

```

![image-20210428114217690](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210428114217690.png)

##### 8.1 版本号

![image-20210428114342022](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210428114342.png)

#### 9 、 Maven聚合



### 二、maven生命周期



![image-20210427201003330](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210427201003.png)



### 三、maven依赖管理



#### 1.依赖范围

![image-20210427201318890](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210427201319.png)



#### 2.依赖传递

![image-20210427201418034](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210427201418.png)



#### 3.依赖冲突

![image-20210428114429783](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210428114430.png)













## URL

URL:统一资源定位符（Uniform Resource Locator）,网址。
     在万维网（world wide web）每一个信息和资源都有统一且唯一的地址

#### java使用url的标准流程：

```java
		//1、	创建一个URL类的对象url
		URL url = new URL("网址");
		//2、	通过URL类的对象url打开网络连接，并得到连接对象conn
		URLConnection conn = url.openConnection();
		//3、	通过连接对象，得到用于读取网页内容的输入流
		InputStream is = conn.getInputStream();
		//4、	将上述字节流is 装饰为字符流，将字符流再装饰为一次能读取一行的字符流br
		BufferedReader br = new BufferedReader(new InputStreamReader(is));
		//5、	通过字符流br,读取一行内容，并将内容存储到变量text中
		String text = br.readLine();
		//6、	可以将读取到的内容text 输出显示到控制台
		System.out.println(text);
```

#### 一、URL初识

   Java的基本网络功能是通过java.net包中声明的类和接口来实现的。通过Java提供的以流为基础的通信方式，使应用程序通过数据流查看网络。
    统一资源定位符（URL）适用于完整地描述Internet上网页和其他资源的地址的一种标识方法，俗称“网址”。

#### 二、URL与URL类

##### 1、URL的组成

​    三部分：协议类型、主机名、路径及文件名。
​    通过URL可以指定的主要有：http，ftp，file等

 网址的组成部分：
     **通信协议://域名:端口号/虚拟路径?参数列表#锚点**

>  **通信协议**：
>    传输速率控制；
>    传输编码控制；
>    出错控制；
>    等
>
>  **域名**：
>    ip地址的别名
>    ip地址：是计算机在互联网中的唯一表示（公网ip）。
>  **端口号**：
>    范围：0~65535之间
>    **http**协议访问时，可以忽略端口号，自动寻找80
>    https协议访问时，可以忽略端口号，自动寻找443
>  参数列表（重要）：
>    访问网络时，给服务器发送的参数内容
>    参数列表由多个参数组成，参数与参数之间使用&连接
>    每一个参数又由参数名称和参数内容组成，名称与内容之间使用 = 连接
>  锚点：
>    百度百科
>    网页过长时，便于用户访问，快速到达指定的点
>
> ### URL中“#” “？” &“”号的作用
>
> **1. #**
>
> **（1）#的涵义**
> 　　#代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如，http://www.example.com/index.html#print就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。
> 　　为网页位置指定标识符，有两个方法。一是使用锚点，比如<a name="print"></a>，二是使用id属性，比如<div id="print">。
>
> 
> **（2）HTTP请求不包括#**
> 　　#是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括#。
> 比如，访问下面的网址，http://www.example.com/index.html#print，浏览器实际发出的请求是这样的：
>
> ```
> GET /index.html HTTP/1.1
> Host: www.example.com
> ```
>
>  
>
> **（3）#后的字符**
> 　　在第一个#后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。
> 比如，下面URL的原意是指定一个颜色值：http://www.example.com/?color=#fff，但是，浏览器实际发出的请求是：
>
> ```
> GET /?color= HTTP/1.1
> Host: www.example.com
> ```
>
>  　
>
> **（4）改变#不触发网页重载**
> 　　单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页。
> 比如，从http://www.example.com/index.html#location1改成http://www.example.com/index.html#location2，浏览器不会重新向服务器请求index.html。
>
>  
>
> **（5）改变#会改变浏览器的访问历史**
> 　　每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用"后退"按钮，就可以回到上一个位置。这对于**ajax**应用程序特别有用，可以用不同的#值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。
> 　　
>
> **(6)window.location.hash读取#值**
> 　　window.location.hash这个属性可读可写。读取时，可以用来判断网页状态是否改变；写入时，则会在不重载网页的前提下，创造一条访问历史记录。
> 　　
>
> **(7)onhashchange事件**
> 　　这是一个HTML 5新增的事件，当#值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。
> 　　它的使用方法有三种：
>
> - window.onhashchange = func;
> - <body οnhashchange="func();">
> - window.addEventListener("hashchange"， func, false);
>
> 　　对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。
>
> **(8)Google抓取#的机制**
> 　　默认情况下，Google的网络蜘蛛**忽视**URL的#部分。
> 　　但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用"#!"，Google会自动将其后面的内容转成查询字符串_escaped_fragment_的值。
> 　　比如，Google发现新版twitter的URL：http://twitter.com/#!/username
> 　　就会自动抓取另一个URL：http://twitter.com/?_escaped_fragment_=/username
> 　　通过这种机制，Google就可以索引动态的Ajax内容。
>
> **2. ？**
>
> (1)连接作用：比如
>
> ```
> http://www.xxx.com/Show.asp?id=77&nameid=2905210001&page=1
> ```
>
> (2)清除缓存：比如
>
> ```
> http://www.xxxxx.com/index.html 
> http://www.xxxxx.com/index.html?test123123
> ```
>
> 两个url打开的页面一样，但是后面这个有问号，说明不调用缓存的内容，而认为是一个新地址，重新读取。
>
> **3. &**
>
> 不同参数的间隔符

##### 2、URL类

https://blog.csdn.net/qq_41320782/article/details/105507857

  Java将URL封装成URL类，可以记录下完整的URL信息。

######  **2.1 构造方法**

![image-20201211154831119](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201211154831.png)

###### **2.2 基本方法**

![image-20201211154856012](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201211154856.png)

######  **2.3 应用举例**

 **源码：**

![image-20201211154959399](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201211154959.png)

##### 3、URLConnection类

URLConnection类是一个抽象类，代表与URL指定的数据源的动态连接，提供比URL类更强的服务器交互控制，允许用POST或PUT或其他HTTP请求方法将数据传送回服务器。

###### **3.1 构建方式**

> 1.创建一个**URL对象。**
> 2.调用URL对象的**openConnection()**方法创建该**URLConnection对象。**
> 3.配置URLConnection。
> 4.读首部字段。
> 5.获取**输入流并读数据**。
> 6.获取**输出流并写数据。**
> 7.关闭连接。

###### **3.2基本方法**

```java
public int getContentLength()：取得文件的长度。
public String getContentType()：取得文件的类型。
public long getDate()：取得文件的创建时间。
public long getLastModified()：取得文件的最后修改时间。
public InputStream getInputStream()：取得输入流，以便获取稳健的数据。

```

注：使用try-catch语句解决传输协议问题。

######  **3.3 应用举例**

![image-20201211155618307](https://gitee.com/top20chenql/md_imgs/raw/master/img/20201211155618.png)

### 浏览器http header

https://segmentfault.com/a/1190000018234763?utm_source=tag-newest



## UML图

### 一、活动图

> 活动图的作用是描述一系列具体动态过程的执行逻辑，展现活动和活动之间转移的控制流，并且它采用一种着重逻辑过程的方式来叙述。
>
> •活动图和交互图是UML中对**系统动态**方面建模的两种主要形式
>
> •交互图强调的是**对象到对象**的控制流，而活动图则强调的是**从活动到活动**的控制流
>
> •活动图是一种表述过程基理、业务过程以及工作流的技术。它可以用来对业务过程、工作流建模，也可以对用例实现甚至是程序实现来建模
>
> •UML 2.0而言，去除了“活动图是状态图的一种特例”这一规定
>
> 【用途】活动图是UML用于对系统的动态行为建模的另一种常用工具，它描述活动的顺序，展现从一个活动到另一个活动的控制流。**活动图在本质上是一种流程图**。活动图着重表现从一个活动到另一个活动的控制流，是内部处理驱动的流程。
>
> 活动图的主要组成元素包括动作、活动、动作流、分支与合并、分叉与汇合、泳道和对象流等。

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208210203897-758111335.png)

活动图组成元素：动作和活动节点、开始和终止、控制流、判断节点、合并节点、泳道。

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208210221798-234501374.png)

#### **（一）活动图的组成元素**

##### 1、活动状态图（Activity）

**——**活动状态用于表达状态机中的**非原子**的运行

　　活动状态图特点如下：

　　(1)、活动状态可以分解成其他子活动或者动作状态。

　　(2)、活动状态的内部活动可以用另一个活动图来表示。

　　(3)、和动作状态不同，活动状态可以有**入口动作**和**出口动作**，也可以有**内部转移**。

　　(4)、动作状态是活动状态的一个特例，**如果某个活动状态只包括一个动作，那么它就是一个动作状态**。

　　UML中活动状态和动作状态的图标相同，但是**活动状态可以在图标中给出入口动作和出口动作等信息**。

　　【图形】平滑的圆角矩形

​             ![img](https://images0.cnblogs.com/blog2015/775886/201506/211049270609855.png)

##### **2、动作状态（Actions）** 

动作状态是指**原子**的，不可中断的动作，并在此动作完成后通过完成转换转向另一个状态。

　　动作状态有如下特点：

　　(1)、动作状态是原子的，它是**构造活动图的最小单位**。

　　(2)、动作状态是**不可中断**的。

　　(3)、动作状态是**瞬时**的行为。

　　(4)、动作状态**可以有入转换**，入转换既可以是动作流，也可以是对象流。动作状态**至少有一条出转换**，这条转换**以内部的完成为起点，与外部事件无关**。

　　(5)、动作状态与状态图中的状态不同，**它不能有入口动作和出口动作，更不能有内部转移**。

　　(6)、在一张活动图中，动作状态允许多处出现。

　　【图形】平滑的圆角矩形

​              ![img](https://images0.cnblogs.com/blog2015/775886/201506/211055116709743.png)

##### **3、动作状态约束（Action Constraints）**

动作状态约束：用来**约束动作状态**。

　　【图形】如下图展示了动作状态的前置条件和后置条件

​          ![img](https://images0.cnblogs.com/blog2015/775886/201506/211059492799464.png) 

##### **4、动作流（Control Flow）**

动作之间的转换称之为动作流活动图的转换

　　【图形】用带箭头的直线表示，箭头的方向指向转入的方向。

​          ![img](https://images0.cnblogs.com/blog2015/775886/201506/211107492325836.png)

##### **5**、开始节点（Initial Node）

——活动开始节点
　　【图形】实心黑色圆点

​          ![img](https://images0.cnblogs.com/blog2015/775886/201506/211110062328248.png)

##### 6、终止节点（Final Node）

**——分为**活动终止节点（**activity final nodes**）**和**流程终止节点（flow final nodes）

　　(1)、活动终止节点表示**整个活动**的结束

　　【图形】圆圈+内部实心黑色圆点

​                ![img](https://images0.cnblogs.com/blog2015/775886/201506/211114294045681.png)

　　(2)、而流程终止节点表示是**子流程**的结束。

　　【图形】圆圈+内部十字叉

​                ![img](https://images0.cnblogs.com/blog2015/775886/201506/211115501078292.png)

##### 7、对象（Objects）

　　【图形】矩形方框　　

　　　　　　　　　　　　　**![img](https://images0.cnblogs.com/blog2015/775886/201506/211116575297928.png)**

##### **8**、数据存储对象（DataStore） 

使用关键字«datastore»

 　【图形】矩形方框，内含关键字

​                ![img](https://images0.cnblogs.com/blog2015/775886/201506/211123114209036.png)

##### **9**、对象流（Object Flows）

对象流是**动作状态**或者**活动状态**与**对象**之间的**依赖关系**，表示**动作使用对象或动作对对象的影响**。

　　用活动图描述某个对象时，可以把涉及到的对象放置在活动图中并用一个依赖将其连接到进行创建、修改和撤销的动作状态或者活动状态上，对象的这种使用方法就构成了对象流。

　　对象流中的对象有以下特点：

　　(1)、一个对象可以**由多个动作操作**。

　　(2)、一个动作输出的对象可以作为另一个动作输入的对象。

　　(3)、在活动图中，同一个对象可以多次出现，它的每一次出现表面该对象正处于对象生存期的不同时间点。

　　【图形】用带有箭头的虚线表示。如果箭头是从动作状态出发指向对象，则表示动作对对象施加了一定的影响。施加的影响包括创建、修改和撤销等。如果箭头从对象指向动作状态，则表示该动作使用对象流所指向的对象。

　　状态图中的**对象用矩形表示**，**矩形内是该对象的名称**，**名称下的方括号表明对象此时的状态**。

​       ![img](https://images0.cnblogs.com/blog2015/775886/201506/211130147016421.png) 

##### **10**、分支与合并（Decision and Merge Nodes）

选择分支
　　【图形】分支与合并用菱形表示，它有一个进入转换（箭头从外指向分支符号），一个或多个离开转换（箭头从分支符号指向外）。而**每个离开转换上都会有一个监护条件**，用来表示满足什么条件的时候执行该转换。

​                     ![img](https://images0.cnblogs.com/blog2015/775886/201506/211428067327755.png)

**11**、分叉与汇合（Fork and Join Nodes）

分叉用于将动作流分为两个或多个**并发运行的分支**，而**汇合则用于同步这些并发分支**，以达到共同完成一项事务的目的。

　　对象在运行时可能会存在两个或多个并发运行的控制流，为了对并发的控制流建模，UML中引入了分叉与汇合的概念。

　　【图形】分为水平风向和垂直方向。

![img](https://images0.cnblogs.com/blog2015/775886/201506/211430021387897.png)![img](https://images0.cnblogs.com/blog2015/775886/201506/211432134986001.png)

##### **12**、时间信号

　　              ![img](https://images0.cnblogs.com/blog2015/775886/201506/211442208419219.png)

##### **13**、发送信号

​             **![img](https://images0.cnblogs.com/blog2015/775886/201506/211444024664473.png)**

**14、接收信号**

​            **![img](https://images0.cnblogs.com/blog2015/775886/201506/211445013739044.png)**

**14**、泳道（Partition）

泳道将活动图中的活动划分为若干组，并把每一组指定给负责这组活动的业务组织，即对象。
在活动图中，泳道区分了负责活动的对象，它明确地表示了哪些活动是由哪些对象进行的。在包含泳道的活动图中，每个活动只能明确地属于一个泳道。

泳道是用垂直实线绘出，垂直线分隔的区域就是泳道。在泳道的上方可以给出泳道的名字或对象的名字，该对象负责泳道内的全部活动。泳道没有顺序，不同泳道中的活动既可以顺序进行也可以并发进行，**动作流和对象流允许穿越分隔线**。

​        ![img](https://images0.cnblogs.com/blog2015/775886/201506/211447504664217.png)

### 二、活动图案例分析

https://www.cnblogs.com/xiaolongbao-lzh/p/4591953.html

#### **例1.购物用例图**

![img](https://images0.cnblogs.com/blog2015/775886/201506/211448577957583.jpg)

```json
1、 泳道分为：会员泳道和系统泳道。会员选择商品并加入购物车，系统完成订单生成及其支付完毕。

2、 开始节点：会员添加商品到购物车，点击【订单确认】，开始交于系统处理订单流程

3、 结束节点：商品发送完毕和付款成功，订单处理流程结束

4、 活动状态：产生订单、Check Credit Cart核对信用卡、Check Stock 核对库存量、Deliver Goods 发送商品、Process Credit Cart付款

5、 分叉与汇合：【产生订单】份叉为检查库存量和会员支付金额是否足够，如果不足，取消订单，如过库存量和支付金额足够，发送商品和付款，最后汇合为订单完成。
```

#### **例2. 带有发送信号与接收信号的活动图**

![image](https://images.cnblogs.com/cnblogs_com/TerryFeng/WindowsLiveWriter/UML_AFD4/image_thumb_9.png)

#### **例3.带对象流的活动图**

[![image](https://images.cnblogs.com/cnblogs_com/TerryFeng/WindowsLiveWriter/UML_AFD4/image_thumb_7.png)](http://images.cnblogs.com/cnblogs_com/TerryFeng/WindowsLiveWriter/UML_AFD4/image_16.png)

 

 

#### **例4.辅助活动图**

[![image](https://images.cnblogs.com/cnblogs_com/TerryFeng/WindowsLiveWriter/UML_AFD4/image_thumb_8.png)](http://images.cnblogs.com/cnblogs_com/TerryFeng/WindowsLiveWriter/UML_AFD4/image_18.png)

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208210654556-681407422.png)

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208210650287-35157639.png)



![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208210518417-920062149.png)

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208210530860-1746848859.png)







## 笛卡尔积排序算法

##### Java 多List（集合）列表获取笛卡尔积（多数组中所有的排列组合）

https://blog.csdn.net/qq_33475202/article/details/91970636?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-3&spm=1001.2101.3001.4242



https://www.jianshu.com/p/f9887a38ff1f

##### JAVA 多个数组之间的排列组合

https://blog.csdn.net/dong1208401589/article/details/61619083

##### 多个数组间元素排列组合问题求解（Java实现）

https://blog.csdn.net/tyhj_sf/article/details/53893125?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242

##### 多个数组间元素排列组合问题求解（Java实现）

https://blog.csdn.net/tyhj_sf/article/details/53893125?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242

##### [LeetCode] java的排列与组合C(m,n)、A(m,n)

https://blog.csdn.net/tzdwsy/article/details/81279064?utm_source=blogxgwz1&utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242

##### [Java实现数列的排列组合](https://www.cnblogs.com/paopaolx/p/11306920.html)

https://www.cnblogs.com/paopaolx/p/11306920.html



## 雪花算法

https://www.cnblogs.com/liuyangjava/p/13670237.html



![image-20210524145017367](https://gitee.com/top20chenql/md_imgs/raw/master/img/20210524145110.png)



```java
package com.ihrm.common.utils;

public class IdWorker {

    //下面两个每个5位，加起来就是10位的工作机器id
    private long workerId;    //工作id
    private long datacenterId;   //数据id
    //12位的序列号
    private long sequence;

    public IdWorker(long workerId, long datacenterId, long sequence) {
        // sanity check for workerId
        if (workerId > maxWorkerId || workerId < 0) {
            throw new IllegalArgumentException(String.format("worker Id can't be greater than %d or less than 0", maxWorkerId));
        }
        if (datacenterId > maxDatacenterId || datacenterId < 0) {
            throw new IllegalArgumentException(String.format("datacenter Id can't be greater than %d or less than 0", maxDatacenterId));
        }
        System.out.printf("worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d",
                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);

        this.workerId = workerId;
        this.datacenterId = datacenterId;
        this.sequence = sequence;
    }

    //初始时间戳
    private long twepoch = 1288834974657L;

    //长度为5位
    private long workerIdBits = 5L;
    private long datacenterIdBits = 5L;
    //最大值
    private long maxWorkerId = -1L ^ (-1L << workerIdBits);
    private long maxDatacenterId = -1L ^ (-1L << datacenterIdBits);
    //序列号id长度
    private long sequenceBits = 12L;
    //序列号最大值
    private long sequenceMask = -1L ^ (-1L << sequenceBits);

    //工作id需要左移的位数，12位
    private long workerIdShift = sequenceBits;
    //数据id需要左移位数 12+5=17位
    private long datacenterIdShift = sequenceBits + workerIdBits;
    //时间戳需要左移位数 12+5+5=22位
    private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;

    //上次时间戳，初始值为负数
    private long lastTimestamp = -1L;

    public long getWorkerId() {
        return workerId;
    }

    public long getDatacenterId() {
        return datacenterId;
    }

    public long getTimestamp() {
        return System.currentTimeMillis();
    }

    //下一个ID生成算法
    public synchronized long nextId() {
        long timestamp = timeGen();

        //获取当前时间戳如果小于上次时间戳，则表示时间戳获取出现异常
        if (timestamp < lastTimestamp) {
            System.err.printf("clock is moving backwards.  Rejecting requests until %d.", lastTimestamp);
            throw new RuntimeException(String.format("Clock moved backwards.  Refusing to generate id for %d milliseconds",
                    lastTimestamp - timestamp));
        }

        //获取当前时间戳如果等于上次时间戳（同一毫秒内），则在序列号加一；否则序列号赋值为0，从0开始。
        if (lastTimestamp == timestamp) {
            sequence = (sequence + 1) & sequenceMask;
            if (sequence == 0) {
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            sequence = 0;
        }

        //将上次时间戳值刷新
        lastTimestamp = timestamp;

        /**
         * 返回结果：
         * (timestamp - twepoch) << timestampLeftShift) 表示将时间戳减去初始时间戳，再左移相应位数
         * (datacenterId << datacenterIdShift) 表示将数据id左移相应位数
         * (workerId << workerIdShift) 表示将工作id左移相应位数
         * | 是按位或运算符，例如：x | y，只有当x，y都为0的时候结果才为0，其它情况结果都为1。
         * 因为个部分只有相应位上的值有意义，其它位上都是0，所以将各部分的值进行 | 运算就能得到最终拼接好的id
         * 所以会保留下来有意义位上的1下来
         */
        return ((timestamp - twepoch) << timestampLeftShift) |
                (datacenterId << datacenterIdShift) |
                (workerId << workerIdShift) |
                sequence;
    }

    //获取时间戳，并与上次时间戳比较
    private long tilNextMillis(long lastTimestamp) {
        long timestamp = timeGen();
        while (timestamp <= lastTimestamp) {
            timestamp = timeGen();
        }
        return timestamp;
    }

    //获取系统时间戳
    private long timeGen() {
        return System.currentTimeMillis();
    }

    //---------------测试---------------
    public static void main(String[] args) {
        IdWorker worker = new IdWorker(1, 1, 1);
        for (int i = 0; i < 30; i++) {
            System.out.println(worker.nextId());
        }
    }

}
```

```java
package com.nd.elearning.resourcelibrary.util;

import com.nd.gaea.core.utils.RandomUtils;

/**
 * twitter的snowflake算法 -- java实现
 *
 * @author beyond
 * @date 2016/11/26
 */
public class SnowFlake {
    /**
     * 起始的时间戳
     */
    private final static long START_STMP = 1480166465631L;

    /**
     * 每一部分占用的位数
     */
    private final static long SEQUENCE_BIT = 12; //序列号占用的位数
    private final static long MACHINE_BIT = 5;   //机器标识占用的位数
    private final static long DATACENTER_BIT = 5;//数据中心占用的位数

    /**
     * 每一部分的最大值
     */
    private final static long MAX_DATACENTER_NUM = -1L ^ (-1L << DATACENTER_BIT);
    private final static long MAX_MACHINE_NUM = -1L ^ (-1L << MACHINE_BIT);
    private final static long MAX_SEQUENCE = -1L ^ (-1L << SEQUENCE_BIT);

    /**
     * 每一部分向左的位移
     */
    private final static long MACHINE_LEFT = SEQUENCE_BIT;
    private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;
    private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT;

    private long datacenterId;  //数据中心
    private long machineId;     //机器标识
    private long sequence = 0L; //序列号
    private long lastStmp = -1L;//上一次时间戳

    public SnowFlake(long datacenterId, long machineId) {
        if (datacenterId > MAX_DATACENTER_NUM || datacenterId < 0) {
            throw new IllegalArgumentException("datacenterId can't be greater than MAX_DATACENTER_NUM or less than 0");
        }
        if (machineId > MAX_MACHINE_NUM || machineId < 0) {
            throw new IllegalArgumentException("machineId can't be greater than MAX_MACHINE_NUM or less than 0");
        }
        this.datacenterId = datacenterId;
        this.machineId = machineId;
    }

    /**
     * 产生下一个ID
     *
     * @return
     */
    public synchronized long nextId() {
        long currStmp = System.currentTimeMillis();
        if (currStmp < lastStmp) {
            throw new RuntimeException("Clock moved backwards.  Refusing to generate id");
        }

        if (currStmp == lastStmp) {
            //相同毫秒内，序列号自增
            sequence = (sequence + 1) & MAX_SEQUENCE;
            //同一毫秒的序列数已经达到最大
            if (sequence == 0L) {
                currStmp = getNextMill();
            }
        } else {
            //不同毫秒内，序列号置为0
            sequence = 0L;
        }

        lastStmp = currStmp;

        return (currStmp - START_STMP) << TIMESTMP_LEFT //时间戳部分
                | datacenterId << DATACENTER_LEFT       //数据中心部分
                | machineId << MACHINE_LEFT             //机器标识部分
                | sequence;                             //序列号部分
    }

    private long getNextMill() {
        long mill = System.currentTimeMillis();
        while (mill <= lastStmp) {
            mill = System.currentTimeMillis();
        }
        return mill;
    }

    private static final SnowFlake snowFlake;

    static {
        snowFlake = new SnowFlake(1, RandomUtils.nextLong(1L, MAX_MACHINE_NUM));
    }

    public static long getNextId() {
        return snowFlake.nextId();
    }

}
```

```java
    /**
     * HashMap允许key为null，null的hash为0（也意味着HashMap允许key为null的键值对），
     * 非null的key的hash高16位和低16位分别由由：key的hashCode
     * 高16位和hashCode的高16位异或hashCode的低16位组成。主要是为了增强hash的随机性减少hash&(n-1)的
     * 随机性，即减小hash冲突，提高HashMap的性能。所以作为HashMap的key的hashCode函数的实现对HashMap
     * 的性能影响较大，极端情况下：所有key的hashCode都相同，这是HashMap的性能很糟糕！
     */
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
 
 
    /**
     * 在new HashMap的时候，如果我们传入了大小参数，这是HashMap会对我们传入的HashMap容量进行传到
     * tableSizeFor函数处理：这个函数主要功能是：返回一个数：这个数是大于等于cap并且是2的整数次幂
     * 的所有数中最小的那个，即返回一个最接近cap(>=cap)，并且是2的整数次幂的那个数。
     * 具体逻辑如下:一个数是2的整数次幂，那么这个数减1的二进制就是一串掩码，即二进制从某位开始是一 串连续的1。
     */
    static final int tableSizeFor(int cap) {
        //举例而言：n的第三位是1(从高位开始数)， 
        int n = cap - 1;
 
        n |= n >>> 1; 
        n |= n >>> 2; 
        n |= n >>> 4; 
        n |= n >>> 8; 
        n |= n >>> 16; 
        //举例而言：如果n为: 00010000 00000000 00000000 000
        /*
        n |= n >>> 1;->n：00011000 00000000 00000000 0000
        n |= n >>> 2;->n: 00011110 00000000 00000000 0000
        n |= n >>> 4;->n: 00011111 11100000 00000000 0000
        n |= n >>> 8;->n: 00011111 11111111 11100000 0000
        n |= n >>> 16;->n:00011111 11111111 11111111 1111
        
        返回n+1：00010000 00000000 00000000 000(>=cap并且为2的整数次幂，与cap差值最小的那个)
        最后的n+1一定是2的整数次幂，并且一定是>=cap
        整体的思路就是：如果n二进制的第k为1，那么经过上面四个‘|’运算后[0,k]位都变成了1,
        即：一连串连续的二进制‘1’(掩码)，最后n+1一定是2的整数次幂（如果不溢出）
        */
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
```



## 代码

#### while循环

```java
package com.cn.elearning.businesslibrary.gateway.core.util;

import com.nd.gaea.core.utils.CollectionUtils;
import com.nd.gaea.uranus.gql.PagerResult;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.util.ArrayList;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Function;

/**
 * @description: 业务库工具类
 * @author: Chenql
 * @time: 2021/3/25 12:02
 */
public class BusinessLibraryUtils {

    /**
     * while循环模板代码获取数据，可用于循环调用api获取数据，api返回的结果必须是PagerResult封装的结果
     *
     * @param function 获取数据的function，两个参数是分页offset和limit，默认是0和500，结果是PagerResult封装的结果
     * @param <R>      返回的记录封装对象
     * @return List<R> 所有记录的集合
     */
    public static <R> List<R> getApiAllResult(BiFunction<Integer, Integer, PagerResult<R>> function) {
        Integer pageSize = 500;
        return getApiAllResult(function, pageSize);
    }

    /**
     * while循环模板代码获取数据，可用于循环调用api获取数据，api返回的结果必须是PagerResult封装的结果
     *
     * @param function 获取数据的function，两个参数是分页offset和limit，结果是PagerResult封装的结果
     * @param pageSize 指定每次循环获取记录大小，offset默认从0开始
     * @param <R>      返回的记录封装对象
     * @return List<R> 所有记录的集合
     */
    public static <R> List<R> getApiAllResult(BiFunction<Integer, Integer, PagerResult<R>> function, Integer pageSize) {
        int pageNo = 0;
        return getApiAllResult(function, pageNo, pageSize);
    }

    /**
     * while循环模板代码获取数据，可用于循环调用JPA接口方法获取数据，JPA接口返回的结果必须是Page封装的结果
     *
     * @param function 获取数据的function，两个参数是分页offset和limit，结果是PagerResult封装的结果
     * @param <R>      返回的记录封装对象
     * @return List<R> 所有记录的集合
     */
    public static <R> List<R> getJpaRepositoryAllResult(Function<Pageable, Page<R>> function) {
        Integer pageNo = 0, pageSize = 500;
        return getJpaRepositoryAllResult(function, pageNo, pageSize);
    }

    /**
     * while循环模板代码获取数据，可用于循环调用JPA接口方法获取数据，JPA接口返回的结果必须是Page封装的结果
     *
     * @param function 获取数据的function，两个参数是分页offset和limit，结果是Page封装的结果
     * @param pageSize 指定每次循环获取记录大小，offset默认从0开始
     * @param <R>      返回的记录封装对象
     * @return List<R> 所有记录的集合
     */
    public static <R> List<R> getJpaRepositoryAllResult(Function<Pageable, Page<R>> function, Integer pageNo, Integer pageSize) {
        List<R> totalResultList = new ArrayList<>(pageSize);
        while (true) {
            Pageable pageable = new PageRequest(pageNo, pageSize);
            Page<R> subResultPage = function.apply(pageable);
            if (CollectionUtils.isEmpty(subResultPage.getContent())) {
                break;
            }
            totalResultList.addAll(subResultPage.getContent());
            if (subResultPage.getTotalElements() <= pageSize) {
                break;
            }
            pageNo++;
        }
        return totalResultList;
    }

    /**
     * while循环模板代码获取数据，可用于循环调用api获取数据，api返回的结果必须是PagerResult封装的结果
     *
     * @param function 获取数据的function，两个参数是分页offset和limit，结果是PagerResult封装的结果
     * @param pageNo   指定开始遍历的页码
     * @param pageSize 指定每次循环获取记录大小，
     * @param <R>      返回的记录封装对象
     * @return List<R> 所有记录的集合
     */
    public static <R> List<R> getApiAllResult(BiFunction<Integer, Integer, PagerResult<R>> function, Integer pageNo, Integer pageSize) {
        List<R> subResultList = new ArrayList<>(pageSize);
        while (true) {
            int offset = pageNo * pageSize;
            PagerResult<R> subResultPage = function.apply(offset, pageSize);
            if (CollectionUtils.isEmpty(subResultPage.getItems())) {
                break;
            }
            subResultList.addAll(subResultPage.getItems());
            if (subResultPage.getTotal() <= pageSize) {
                break;
            }
            pageNo++;
        }
        return subResultList;
    }

    public static void main(String[] args) {
        String a = "206400600579";
        System.out.println(Math.abs(a.hashCode() % 50));
    }
}

```

#### 缓存

```java
package com.nd.elearning.library.core.util;

import com.fasterxml.jackson.core.type.TypeReference;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.google.common.collect.Lists;
import com.nd.elearning.library.application.config.RedisCacheNames;
import com.nd.elearning.library.domain.jpa.ContentTypeGroupPo;
import com.nd.elearning.library.domain.jpa.ContentTypePo;
import com.nd.elearning.library.sdk.client.TranslationApi;
import com.nd.elearning.library.sdk.vo.contenttype.I18nConfigVo;
import com.nd.elearning.library.sdk.vo.translation.PairMap;
import com.nd.elearning.library.sdk.vo.translation.TranslationValue;
import com.nd.gaea.core.utils.CollectionUtils;
import com.nd.gaea.core.utils.MapUtils;
import com.nd.gaea.core.utils.ObjectUtils;
import com.nd.gaea.core.utils.StringUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.connection.RedisStringCommands;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.types.Expiration;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.stereotype.Component;
import org.springframework.util.Assert;

import java.security.SecureRandom;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * @author chenl
 * @date 2020-02-04
 */
@Component
@Slf4j
public class TranslationUtils {

    @Autowired
    private StringRedisTemplate redisTemplate;
    @Autowired
    private TranslationApi translationApi;

    public static final Cache<String, PairMap<String, String>> entryLocalCache = Caffeine.newBuilder()
                                                                                         .maximumSize(1000)
                                                                                         .initialCapacity(200)
                                                                                         .expireAfterWrite(24, TimeUnit.HOURS)
                                                                                         .build();
    @Autowired
    private ExecutorService executorService;

    /**
     * 单个词条翻译获取
     *
     * @param targetWord        待翻译词条
     * @param i18nConfigVo      翻译配置
     * @param translateValueMap 翻译词条Map
     * @return 翻译
     */
    public String getI18nValues(String targetWord, I18nConfigVo i18nConfigVo, Map<String, String> translateValueMap) {
        return translateValueMap.getOrDefault(this.genCacheKey(i18nConfigVo, ContextUtils.getContextLanguageTag(), targetWord), targetWord);
    }

    /**
     * 单个词条翻译获取
     *
     * @param targetWord   待翻译词条
     * @param i18nConfigVo 翻译配置
     * @return 翻译
     */
    public String getI18nValues(String targetWord, I18nConfigVo i18nConfigVo) {
        Map<String, String> i18nValues = this.getI18nValues(Collections.singletonList(targetWord), i18nConfigVo);
        return i18nValues.getOrDefault(this.genCacheKey(i18nConfigVo, ContextUtils.getContextLanguageTag(), targetWord), targetWord);
    }

    /**
     * 同组件词条获取
     *
     * @param targetWordsList 待翻译词条集合
     * @param i18nConfigVo    翻译配置
     * @return 翻译集合
     */
    public Map<String, String> getI18nValues(List<String> targetWordsList, I18nConfigVo i18nConfigVo) {
        String languageTag = ContextUtils.getContextLanguageTag();
        List<String> redisKeyList = targetWordsList.stream().map(k -> this.genCacheKey(i18nConfigVo, languageTag, k)).collect(Collectors.toList());
        Map<String, I18nConfigVo> keyI18nSettingMap = targetWordsList.stream().collect(Collectors.toMap(k -> k, v -> i18nConfigVo));
        return this.getI18nValues(redisKeyList, targetWordsList, languageTag, keyI18nSettingMap);
    }

    /**
     * 批量获取不同组件的词条翻译
     *
     * @param cacheKeyList      缓存key集合
     * @param targetWordsList   待翻译词条集合
     * @param languageTag       语言
     * @param keyI18nSettingMap 翻译配置map
     * @return 翻译集合
     */
    private Map<String, String> getI18nValues(List<String> cacheKeyList, List<String> targetWordsList, String languageTag, Map<String, I18nConfigVo> keyI18nSettingMap) {
        if (CollectionUtils.isEmpty(targetWordsList)) {
            return Collections.emptyMap();
        }
        //本地缓存中取
        Map<String, PairMap<String, String>> localCacheMap = entryLocalCache.getAllPresent(cacheKeyList);
        if (MapUtils.isNotEmpty(localCacheMap) && localCacheMap.keySet().size() == targetWordsList.size()) {
            return localCacheMap.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, v -> v.getValue().getRight()));
        }
        List<String> unHitsWords = Lists.newArrayList(targetWordsList);
        List<String> redisResultList = this.redisTemplate.opsForValue().multiGet(cacheKeyList);
        List<String> redisResult = new ArrayList<>();
        List<PairMap<String, String>> cachedI18ns = new ArrayList<>();
        for (String result : redisResultList) {
            if (StringUtils.isBlank(result)) {
                continue;
            }
            redisResult.add(result);
        }
        if (CollectionUtils.isNotEmpty(redisResult)) {
            cachedI18ns = redisResult.stream().map(e -> ObjectUtils.fromJson(e, new TypeReference<PairMap<String, String>>() {
            })).collect(Collectors.toList());
            List<String> redisExistsKeys = cachedI18ns.stream().map(PairMap::getLeft).collect(Collectors.toList());
            unHitsWords = (List<String>) CollectionUtils.disjunction(unHitsWords, redisExistsKeys);
        }
        Map<String, String> needCachingMap = new HashMap<>(128);
        if (CollectionUtils.isNotEmpty(unHitsWords)) {
            //使用CompletableFuture异步发送请求，请求结果的map结构为（待翻译词条：future封装的翻译api返回值）
            Map<String, CompletableFuture<String>> wordsFutures = unHitsWords.stream().map(word -> Collections.singletonMap(word, CompletableFuture.supplyAsync(() -> {
                I18nConfigVo i18nConfigVo = keyI18nSettingMap.get(word);
                if (i18nConfigVo == null) {
                    //未设置翻译组件配置，默认取内容库组件的翻译
                    i18nConfigVo = this.defaultI18nSetting();
                    keyI18nSettingMap.put(word, i18nConfigVo);
                }
                return this.queryFromTranslateApi(i18nConfigVo.getTranslationName(), i18nConfigVo.getTranslationVersion(), languageTag, word);
            }, executorService))).flatMap(map -> map.entrySet().stream()).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
            Map<String, String> wordMap = wordsFutures.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, v -> {
                try {
                    return v.getValue().get();
                } catch (Exception e) {
                    log.error("future get translate api error", e);
                }
                return v.getKey();
            }));
            for (Map.Entry<String, String> entry : wordMap.entrySet()) {
                String word = entry.getKey();
                String translateWord = StringUtils.isBlank(entry.getValue()) ? word : entry.getValue();
                I18nConfigVo i18nConfigVo = keyI18nSettingMap.get(entry.getKey());
                if (i18nConfigVo == null) {
                    //未设置翻译组件配置，默认取内容库组件的翻译
                    i18nConfigVo = this.defaultI18nSetting();
                    keyI18nSettingMap.put(word, i18nConfigVo);
                }
                String cacheKey = this.genCacheKey(i18nConfigVo.getTranslationName(), i18nConfigVo.getTranslationVersion(), languageTag, word);
                PairMap<String, String> translatePair = new PairMap<>(word, translateWord);
                cachedI18ns.add(translatePair);
                needCachingMap.put(cacheKey, ObjectUtils.toJson(translatePair));
            }
        }
        if (MapUtils.isNotEmpty(needCachingMap)) {
            //加到redis缓存
            RedisSerializer<String> stringSerializer = redisTemplate.getStringSerializer();
            redisTemplate.executePipelined((RedisCallback<Object>) connection -> {
                for (Map.Entry<String, String> entry : needCachingMap.entrySet()) {
                    String key = entry.getKey();
                    String value = entry.getValue();
                    connection.set(stringSerializer.serialize(key), stringSerializer.serialize(value), Expiration.from(RedisCacheNames.ONE_WEEK, TimeUnit.SECONDS), RedisStringCommands.SetOption.UPSERT);
                }
                return null;
            }, stringSerializer);
        }
        //本地缓存
        Map<String, PairMap<String, String>> resultMap = cachedI18ns.stream().collect(Collectors.toMap(k -> this.genCacheKey(keyI18nSettingMap.get(k.getLeft()), languageTag, k.getLeft()), v -> v));
        entryLocalCache.putAll(resultMap);
        return cachedI18ns.stream().collect(Collectors.toMap(k -> this.genCacheKey(keyI18nSettingMap.get(k.getLeft()), languageTag, k.getLeft()), PairMap::getRight));
    }

    public String queryFromTranslateApi(String componentName, String version, String languageTag, String key) {
        TranslationValue translationValue = this.translationApi.get(componentName, languageTag, version, key, TranslationApi.PARAM_NAMESPACE_DEFAULT_VALUE, TranslationApi.PARAM_OS_DEFAULT_VALUE);
        return Optional.ofNullable(translationValue).map(TranslationValue::getValue).orElse(key);
    }

    public Map<String, String> translateContentTypes(Collection<ContentTypePo> contentTypePoList) {
        if (CollectionUtils.isEmpty(contentTypePoList)) {
            return Collections.emptyMap();
        }
        List<String> redisKeyList = new ArrayList<>(64);
        List<String> targetKeyList = new ArrayList<>(64);
        String languageTag = ContextUtils.getContextLanguageTag();
        Map<String, I18nConfigVo> keyI18nSettingMap = new HashMap<>(64);
        for (ContentTypePo contentTypePo : contentTypePoList) {
            String title = contentTypePo.getTitle();
            I18nConfigVo i18nConfigVo = this.getI18nConfig(title);
            if (i18nConfigVo == null) {
                i18nConfigVo = this.defaultI18nSetting();
                keyI18nSettingMap.put(contentTypePo.getType(), i18nConfigVo);
            }
            String redisKey = this.genCacheKey(i18nConfigVo.getTranslationName(), i18nConfigVo.getTranslationVersion(), languageTag, contentTypePo.getType());
            redisKeyList.add(redisKey);
            keyI18nSettingMap.put(contentTypePo.getType(), i18nConfigVo);
            targetKeyList.add(contentTypePo.getType());
        }
        return this.getI18nValues(redisKeyList, targetKeyList, languageTag, keyI18nSettingMap);
    }

    private I18nConfigVo defaultI18nSetting() {
        I18nConfigVo i18nConfigVo;
        i18nConfigVo = new I18nConfigVo();
        i18nConfigVo.setTranslationName("elearning-library");
        i18nConfigVo.setTranslationVersion("v0.0.1");
        return i18nConfigVo;
    }

    public Map<String, String> translateContentGroups(Collection<ContentTypeGroupPo> contentTypeGroupPoList) {
        if (CollectionUtils.isEmpty(contentTypeGroupPoList)) {
            return Collections.emptyMap();
        }
        List<String> redisKeyList = new ArrayList<>(64);
        List<String> targetKeyList = new ArrayList<>();
        String languageTag = ContextUtils.getContextLanguageTag();
        Map<String, I18nConfigVo> keyI18nSettingMap = new HashMap<>(64);
        for (ContentTypeGroupPo contentTypeGroupPo : contentTypeGroupPoList) {
            String title = contentTypeGroupPo.getTitle();
            I18nConfigVo i18nConfigVo = this.getI18nConfig(title);
            if (i18nConfigVo == null) {
                i18nConfigVo = this.defaultI18nSetting();
                keyI18nSettingMap.put(contentTypeGroupPo.getCode(), i18nConfigVo);
            }
            String redisKey = this.genCacheKey(i18nConfigVo.getTranslationName(), i18nConfigVo.getTranslationVersion(), languageTag, contentTypeGroupPo.getCode());
            redisKeyList.add(redisKey);
            keyI18nSettingMap.put(contentTypeGroupPo.getCode(), i18nConfigVo);
            targetKeyList.add(contentTypeGroupPo.getCode());
        }
        return this.getI18nValues(redisKeyList, targetKeyList, languageTag, keyI18nSettingMap);
    }

    /**
     * 生成缓存key
     *
     * @param i18nConfigVo
     * @param languageTag
     * @param key
     * @return
     */
    private String genCacheKey(I18nConfigVo i18nConfigVo, String languageTag, String key) {
        Assert.notNull(i18nConfigVo, "i18n config can't be null");
        return this.genCacheKey(i18nConfigVo.getTranslationName(), i18nConfigVo.getTranslationVersion(), languageTag, key);
    }

    /**
     * 生成缓存key
     *
     * @param componentName 组件名
     * @param version       翻译版本号
     * @param languageTag   语言
     * @param key           待翻译词条
     * @return 缓存key
     */
    private String genCacheKey(String componentName, String version, String languageTag, String key) {
        return RedisCacheNames.I18N_NEW + RedisCacheNames.SEPARATOR +
                componentName + RedisCacheNames.SEPARATOR +
                version + RedisCacheNames.SEPARATOR +
                languageTag + RedisCacheNames.SEPARATOR +
                key;
    }

    /**
     * 生成缓存key
     *
     * @param componentName 组件名
     * @param version       翻译版本号
     * @param languageTag   语言
     * @param keys          待翻译词条
     * @return 缓存key
     */
    private List<String> genCacheKeys(String componentName, String version, String languageTag, List<String> keys) {
        List<String> cacheKeys = new ArrayList<>(keys.size());
        for (String key : keys) {
            cacheKeys.add(this.genCacheKey(componentName, version, languageTag, key));
        }
        return cacheKeys;
    }

    /**
     * title设置国际化值
     *
     * @return String
     * @author Chenql
     * @date 2020/6/24 13:46
     */
    public String setContentTypeI18nValue(I18nConfigVo i18nConfigVo, String toTranslateWord) {
        if (i18nConfigVo == null || StringUtils.isBlank(toTranslateWord)) {
            return toTranslateWord;
        }
        return this.getI18nValues(toTranslateWord, i18nConfigVo);
    }

    public Integer randomCacheTime() {
        SecureRandom random = new SecureRandom();
        int maxHourExpireTime = 90 * 24;
        int minHourExpireTime = 90 * 24 - 60;
        return random.nextInt(maxHourExpireTime) % (maxHourExpireTime - minHourExpireTime + 1) + minHourExpireTime;
    }

    public I18nConfigVo getI18nConfig(String i18nConfigStr) {
        try {
            return ObjectUtils.fromJson(i18nConfigStr, I18nConfigVo.class);
        } catch (Exception e) {
            log.error("convert json string error", e);
        }
        return null;
    }
}

```

